---
title: "Maze Runner : the game"
description: "A 3D-looking first person randomly generated maze game on a 2D drawing platform."
hero_img: "../src/images/maze-runner/play_screen.png"
hero_img_alt: "screenshot of a game play scene where the play needs to navigate to the exit of the autogenerated maze."
hero_img_description: "Screenshot of a game play scene."
date: "12-05-2019"
order: "1"
color: "#A284D6"
tag: "tech"
---

A 3D looking first person randomly generated maze game on a 2D drawing platform made with Python and Pygame extension. 15-112 F19 final term project. Link to the code to be posted.

## Demo Video ##

<br/>

<iframe width="560" height="315" src="https://www.youtube.com/embed/eFa9c7_8Eyo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<br/>

#### How to Play: ####
'w' - move forward
's' - move backward
'a' - peak up (unable to move forward/backward while peaking)
'd' - go back down 
Before the 5-minute countdown reaches 0, the user must figure out the location of the exit and escape the maze. 

* Tip : Visit 'Setting' before hitting 'Play' to choose the difficulty of the maze! 


#### Process: ####
For the final term project, I wanted to create an interactive first person game. I came across an idea of escaping a maze from the first person perspective, and decided to come up with some possible features for this game concept.

Starting off, I first created a cube that changes its position, rotation, and scale based on the movement of the camera (the user's perspective) using pygame built-in functions and Object Oriented programming (OOP) style.

Then I added colors to distinguish faces of the cube.  

Now that I have checked that both interactivity and creation of multiple cube instances work, I moved onto the algorithm part of this project: randomly generating a maze based on the difficulty level. 
While thinking about possible ways to design this random maze generation algorithm, I came across a method called 'Recursive Division Method,' which creates a maze by recursively taking the following steps until the full maze is constructed:
1. Randomly select a row and a column to build two walls,
2. Randomly select a column or two on a row-wall and a row or two on a column-wall to create holes.
Since this method requires the total dimension to begin the process with, I decided to set three sets of dimensions for each difficulty level.

After writing a function that generates a maze using recursive division method, I ran the code several times to ensure different maze is being generated each time I run the game. As could be seen on the photos above, I could see that the algorithm is working properly to generate a random maze for each round of the game.
Now that the essential part (generating a maze) of the game is finished, I set the starting point to be somewhere behind the midpoint of the maze. In other words, I also randomized the starting location of the camera under a single restriction -- that is, assuming the exit of the maze is at row 0, the starting location must be greater than the half of the maze dimension -- to ensure the player doesn't start right in front of the exit by chance. (That would be no fun :D)
Katja, my mentor TA, suggested to add a record at the end of the game so that it displays the leaderboard to further encourage people to challenge themselves and the top score ever played. Using os.read and os.write, I let the game record the scores ever played, then display the top 5 scores on the ending page along with the player's score of that round. 


#### Reflection: ####
This term project gave me great insights to how much one could do and make using python and various python extensions. The idea of keeping track of vertex location to draw a 3D look in 2D was interesting and inspiring to learn, but if chance, I'd like to learn more about ray-tracing and create another simple game using ray-tracing method. 

Regarding "Maze Runner: the game", I'm proud of the outcome and I'd like to thank Katja for being an amazing mentor for this project. 
