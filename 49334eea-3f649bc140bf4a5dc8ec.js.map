{"version":3,"file":"49334eea-3f649bc140bf4a5dc8ec.js","mappings":"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","sources":["webpack://ashley-kim/./node_modules/@react-three/cannon/dist/index.js"],"sourcesContent":["import _objectWithoutProperties from \"/Users/ashk/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _construct from \"/Users/ashk/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _toConsumableArray from \"/Users/ashk/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/ashk/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/ashk/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/ashk/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/ashk/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/ashk/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _possibleConstructorReturn from \"/Users/ashk/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _getPrototypeOf from \"/Users/ashk/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _defineProperty from \"/Users/ashk/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _excluded = [\"angularFactor\", \"angularVelocity\", \"args\", \"collisionResponse\", \"linearFactor\", \"mass\", \"material\", \"onCollide\", \"position\", \"rotation\", \"shapes\", \"type\", \"velocity\"],\n  _excluded2 = [\"type\", \"args\", \"position\", \"rotation\", \"material\"],\n  _excluded3 = [\"onCollide\", \"onCollideBegin\", \"onCollideEnd\"],\n  _excluded4 = [\"bi\", \"bj\"],\n  _excluded5 = [\"body\", \"contact\", \"target\"],\n  _excluded6 = [\"uuid\"],\n  _excluded7 = [\"body\", \"ray\"];\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport \"core-js/modules/esnext.global-this.js\";\nimport \"core-js/modules/es.array.flat-map.js\";\nimport \"core-js/modules/es.array.unscopables.flat-map.js\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { useFrame, useThree } from '@react-three/fiber';\nimport { MeshBasicMaterial, SphereGeometry, BoxGeometry, PlaneGeometry, Mesh, CylinderGeometry, BufferGeometry, Float32BufferAttribute, Quaternion as Quaternion$2, Vector3, Matrix4, Scene, InstancedMesh, Object3D, Euler, MathUtils, DynamicDrawUsage } from 'three';\nimport { createContext, useContext, useState, useRef, useMemo, useEffect, useLayoutEffect, useCallback } from 'react';\nimport { jsxs, jsx } from 'react/jsx-runtime';\nvar events = {\n  exports: {}\n};\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function get() {\n    return defaultMaxListeners;\n  },\n  set: function set(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\nEventEmitter.init = function () {\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) {\n    args.push(arguments[i]);\n  }\n  var doError = type === 'error';\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n  if (handler === undefined) return false;\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) {\n      ReflectApply(listeners[i], this, args);\n    }\n  }\n  return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  checkListener(listener);\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n  return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0) return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: undefined,\n    target: target,\n    type: type,\n    listener: listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  checkListener(listener);\n  events = this._events;\n  if (events === undefined) return this;\n  list = events[type];\n  if (list === undefined) return this;\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n    if (position < 0) return this;\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1) events[type] = list[0];\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n  return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n  events = this._events;\n  if (events === undefined) return this;\n\n  // not listening for removeListener, no need to emit\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n  listeners = events[type];\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n  return this;\n};\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n  if (events === undefined) return [];\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n  if (events !== undefined) {\n    var evlistener = events[type];\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n  return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i) {\n    copy[i] = arr[i];\n  }\n  return copy;\n}\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) {\n    list[index] = list[index + 1];\n  }\n  list.pop();\n}\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    }\n    eventTargetAgnosticAddListener(emitter, name, resolver, {\n      once: true\n    });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, {\n        once: true\n      });\n    }\n  });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\nvar EventEmitter$1 = events.exports;\nfunction decodeBase64(base64, enableUnicode) {\n  var binaryString = atob(base64);\n  if (enableUnicode) {\n    var binaryView = new Uint8Array(binaryString.length);\n    for (var i = 0, n = binaryString.length; i < n; ++i) {\n      binaryView[i] = binaryString.charCodeAt(i);\n    }\n    return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));\n  }\n  return binaryString;\n}\nfunction createURL(base64, sourcemapArg, enableUnicodeArg) {\n  var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;\n  var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;\n  var source = decodeBase64(base64, enableUnicode);\n  var start = source.indexOf('\\n', 10) + 1;\n  var body = source.substring(start) + (sourcemap ? '\\/\\/# sourceMappingURL=' + sourcemap : '');\n  var blob = new Blob([body], {\n    type: 'application/javascript'\n  });\n  return URL.createObjectURL(blob);\n}\nfunction createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {\n  var url;\n  return function WorkerFactory(options) {\n    url = url || createURL(base64, sourcemapArg, enableUnicodeArg);\n    return new Worker(url, options);\n  };\n}\nvar WorkerFactory = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgLyoqCiAgICogUmVjb3JkcyB3aGF0IG9iamVjdHMgYXJlIGNvbGxpZGluZyB3aXRoIGVhY2ggb3RoZXIKICAgKi8KCiAgLyoqCiAgICogQSAzeDMgbWF0cml4LgogICAqIEF1dGhvcmVkIGJ5IHtAbGluayBodHRwOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS8gc2NodGVwcGV9CiAgICovCiAgY2xhc3MgTWF0MyB7CiAgICAvKioKICAgICAqIEEgdmVjdG9yIG9mIGxlbmd0aCA5LCBjb250YWluaW5nIGFsbCBtYXRyaXggZWxlbWVudHMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEBwYXJhbSBlbGVtZW50cyBBIHZlY3RvciBvZiBsZW5ndGggOSwgY29udGFpbmluZyBhbGwgbWF0cml4IGVsZW1lbnRzLgogICAgICovCiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykgewogICAgICBpZiAoZWxlbWVudHMgPT09IHZvaWQgMCkgewogICAgICAgIGVsZW1lbnRzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdOwogICAgICB9CgogICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7CiAgICB9CiAgICAvKioKICAgICAqIFNldHMgdGhlIG1hdHJpeCB0byBpZGVudGl0eQogICAgICogQHRvZG8gU2hvdWxkIHBlcmhhcHMgYmUgcmVuYW1lZCB0byBgc2V0SWRlbnRpdHkoKWAgdG8gYmUgbW9yZSBjbGVhci4KICAgICAqIEB0b2RvIENyZWF0ZSBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgaW1tZWRpYXRlbHkgY3JlYXRlcyBhbiBpZGVudGl0eSBtYXRyaXggZWcuIGBleWUoKWAKICAgICAqLwoKCiAgICBpZGVudGl0eSgpIHsKICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7CiAgICAgIGVbMF0gPSAxOwogICAgICBlWzFdID0gMDsKICAgICAgZVsyXSA9IDA7CiAgICAgIGVbM10gPSAwOwogICAgICBlWzRdID0gMTsKICAgICAgZVs1XSA9IDA7CiAgICAgIGVbNl0gPSAwOwogICAgICBlWzddID0gMDsKICAgICAgZVs4XSA9IDE7CiAgICB9CiAgICAvKioKICAgICAqIFNldCBhbGwgZWxlbWVudHMgdG8gemVybwogICAgICovCgoKICAgIHNldFplcm8oKSB7CiAgICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzOwogICAgICBlWzBdID0gMDsKICAgICAgZVsxXSA9IDA7CiAgICAgIGVbMl0gPSAwOwogICAgICBlWzNdID0gMDsKICAgICAgZVs0XSA9IDA7CiAgICAgIGVbNV0gPSAwOwogICAgICBlWzZdID0gMDsKICAgICAgZVs3XSA9IDA7CiAgICAgIGVbOF0gPSAwOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIHRoZSBtYXRyaXggZGlhZ29uYWwgZWxlbWVudHMgZnJvbSBhIFZlYzMKICAgICAqLwoKCiAgICBzZXRUcmFjZSh2ZWN0b3IpIHsKICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7CiAgICAgIGVbMF0gPSB2ZWN0b3IueDsKICAgICAgZVs0XSA9IHZlY3Rvci55OwogICAgICBlWzhdID0gdmVjdG9yLno7CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgdGhlIG1hdHJpeCBkaWFnb25hbCBlbGVtZW50cwogICAgICovCgoKICAgIGdldFRyYWNlKHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50czsKICAgICAgdGFyZ2V0LnggPSBlWzBdOwogICAgICB0YXJnZXQueSA9IGVbNF07CiAgICAgIHRhcmdldC56ID0gZVs4XTsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogTWF0cml4LVZlY3RvciBtdWx0aXBsaWNhdGlvbgogICAgICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoCiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsLCB0YXJnZXQgdG8gc2F2ZSB0aGUgcmVzdWx0IGluLgogICAgICovCgoKICAgIHZtdWx0KHYsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50czsKICAgICAgY29uc3QgeCA9IHYueDsKICAgICAgY29uc3QgeSA9IHYueTsKICAgICAgY29uc3QgeiA9IHYuejsKICAgICAgdGFyZ2V0LnggPSBlWzBdICogeCArIGVbMV0gKiB5ICsgZVsyXSAqIHo7CiAgICAgIHRhcmdldC55ID0gZVszXSAqIHggKyBlWzRdICogeSArIGVbNV0gKiB6OwogICAgICB0YXJnZXQueiA9IGVbNl0gKiB4ICsgZVs3XSAqIHkgKyBlWzhdICogejsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogTWF0cml4LXNjYWxhciBtdWx0aXBsaWNhdGlvbgogICAgICovCgoKICAgIHNtdWx0KHMpIHsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdGhpcy5lbGVtZW50c1tpXSAqPSBzOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIE1hdHJpeCBtdWx0aXBsaWNhdGlvbgogICAgICogQHBhcmFtIG1hdHJpeCBNYXRyaXggdG8gbXVsdGlwbHkgd2l0aCBmcm9tIGxlZnQgc2lkZS4KICAgICAqLwoKCiAgICBtbXVsdChtYXRyaXgsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgTWF0MygpOwogICAgICB9CgogICAgICBjb25zdCBBID0gdGhpcy5lbGVtZW50czsKICAgICAgY29uc3QgQiA9IG1hdHJpeC5lbGVtZW50czsKICAgICAgY29uc3QgVCA9IHRhcmdldC5lbGVtZW50czsKICAgICAgY29uc3QgYTExID0gQVswXSwKICAgICAgICAgICAgYTEyID0gQVsxXSwKICAgICAgICAgICAgYTEzID0gQVsyXSwKICAgICAgICAgICAgYTIxID0gQVszXSwKICAgICAgICAgICAgYTIyID0gQVs0XSwKICAgICAgICAgICAgYTIzID0gQVs1XSwKICAgICAgICAgICAgYTMxID0gQVs2XSwKICAgICAgICAgICAgYTMyID0gQVs3XSwKICAgICAgICAgICAgYTMzID0gQVs4XTsKICAgICAgY29uc3QgYjExID0gQlswXSwKICAgICAgICAgICAgYjEyID0gQlsxXSwKICAgICAgICAgICAgYjEzID0gQlsyXSwKICAgICAgICAgICAgYjIxID0gQlszXSwKICAgICAgICAgICAgYjIyID0gQls0XSwKICAgICAgICAgICAgYjIzID0gQls1XSwKICAgICAgICAgICAgYjMxID0gQls2XSwKICAgICAgICAgICAgYjMyID0gQls3XSwKICAgICAgICAgICAgYjMzID0gQls4XTsKICAgICAgVFswXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMTsKICAgICAgVFsxXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjsKICAgICAgVFsyXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMzsKICAgICAgVFszXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTsKICAgICAgVFs0XSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMjsKICAgICAgVFs1XSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMzsKICAgICAgVFs2XSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMTsKICAgICAgVFs3XSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMjsKICAgICAgVFs4XSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMzsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogU2NhbGUgZWFjaCBjb2x1bW4gb2YgdGhlIG1hdHJpeAogICAgICovCgoKICAgIHNjYWxlKHZlY3RvciwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBNYXQzKCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzOwogICAgICBjb25zdCB0ID0gdGFyZ2V0LmVsZW1lbnRzOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDM7IGkrKykgewogICAgICAgIHRbMyAqIGkgKyAwXSA9IHZlY3Rvci54ICogZVszICogaSArIDBdOwogICAgICAgIHRbMyAqIGkgKyAxXSA9IHZlY3Rvci55ICogZVszICogaSArIDFdOwogICAgICAgIHRbMyAqIGkgKyAyXSA9IHZlY3Rvci56ICogZVszICogaSArIDJdOwogICAgICB9CgogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBTb2x2ZSBBeD1iCiAgICAgKiBAcGFyYW0gYiBUaGUgcmlnaHQgaGFuZCBzaWRlCiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdmVjdG9yIHRvIHNhdmUgaW4uCiAgICAgKiBAcmV0dXJuIFRoZSBzb2x1dGlvbiB4CiAgICAgKiBAdG9kbyBzaG91bGQgcmV1c2UgYXJyYXlzCiAgICAgKi8KCgogICAgc29sdmUoYiwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIC8vIENvbnN0cnVjdCBlcXVhdGlvbnMKICAgICAgY29uc3QgbnIgPSAzOyAvLyBudW0gcm93cwoKICAgICAgY29uc3QgbmMgPSA0OyAvLyBudW0gY29scwoKICAgICAgY29uc3QgZXFucyA9IFtdOwogICAgICBsZXQgaTsKICAgICAgbGV0IGo7CgogICAgICBmb3IgKGkgPSAwOyBpIDwgbnIgKiBuYzsgaSsrKSB7CiAgICAgICAgZXFucy5wdXNoKDApOwogICAgICB9CgogICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7CiAgICAgICAgZm9yIChqID0gMDsgaiA8IDM7IGorKykgewogICAgICAgICAgZXFuc1tpICsgbmMgKiBqXSA9IHRoaXMuZWxlbWVudHNbaSArIDMgKiBqXTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGVxbnNbMyArIDQgKiAwXSA9IGIueDsKICAgICAgZXFuc1szICsgNCAqIDFdID0gYi55OwogICAgICBlcW5zWzMgKyA0ICogMl0gPSBiLno7IC8vIENvbXB1dGUgcmlnaHQgdXBwZXIgdHJpYW5ndWxhciB2ZXJzaW9uIG9mIHRoZSBtYXRyaXggLSBHYXVzcyBlbGltaW5hdGlvbgoKICAgICAgbGV0IG4gPSAzOwogICAgICBjb25zdCBrID0gbjsKICAgICAgbGV0IG5wOwogICAgICBjb25zdCBrcCA9IDQ7IC8vIG51bSByb3dzCgogICAgICBsZXQgcDsKCiAgICAgIGRvIHsKICAgICAgICBpID0gayAtIG47CgogICAgICAgIGlmIChlcW5zW2kgKyBuYyAqIGldID09PSAwKSB7CiAgICAgICAgICAvLyB0aGUgcGl2b3QgaXMgbnVsbCwgc3dhcCBsaW5lcwogICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHsKICAgICAgICAgICAgaWYgKGVxbnNbaSArIG5jICogal0gIT09IDApIHsKICAgICAgICAgICAgICBucCA9IGtwOwoKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAvLyBkbyBsaWduZSggaSApID0gbGlnbmUoIGkgKSArIGxpZ25lKCBrICkKICAgICAgICAgICAgICAgIHAgPSBrcCAtIG5wOwogICAgICAgICAgICAgICAgZXFuc1twICsgbmMgKiBpXSArPSBlcW5zW3AgKyBuYyAqIGpdOwogICAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApOwoKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKGVxbnNbaSArIG5jICogaV0gIT09IDApIHsKICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7CiAgICAgICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBlcW5zW2kgKyBuYyAqIGpdIC8gZXFuc1tpICsgbmMgKiBpXTsKICAgICAgICAgICAgbnAgPSBrcDsKCiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAvLyBkbyBsaWduZSggayApID0gbGlnbmUoIGsgKSAtIG11bHRpcGxpZXIgKiBsaWduZSggaSApCiAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7CiAgICAgICAgICAgICAgZXFuc1twICsgbmMgKiBqXSA9IHAgPD0gaSA/IDAgOiBlcW5zW3AgKyBuYyAqIGpdIC0gZXFuc1twICsgbmMgKiBpXSAqIG11bHRpcGxpZXI7CiAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSB3aGlsZSAoLS1uKTsgLy8gR2V0IHRoZSBzb2x1dGlvbgoKCiAgICAgIHRhcmdldC56ID0gZXFuc1syICogbmMgKyAzXSAvIGVxbnNbMiAqIG5jICsgMl07CiAgICAgIHRhcmdldC55ID0gKGVxbnNbMSAqIG5jICsgM10gLSBlcW5zWzEgKiBuYyArIDJdICogdGFyZ2V0LnopIC8gZXFuc1sxICogbmMgKyAxXTsKICAgICAgdGFyZ2V0LnggPSAoZXFuc1swICogbmMgKyAzXSAtIGVxbnNbMCAqIG5jICsgMl0gKiB0YXJnZXQueiAtIGVxbnNbMCAqIG5jICsgMV0gKiB0YXJnZXQueSkgLyBlcW5zWzAgKiBuYyArIDBdOwoKICAgICAgaWYgKGlzTmFOKHRhcmdldC54KSB8fCBpc05hTih0YXJnZXQueSkgfHwgaXNOYU4odGFyZ2V0LnopIHx8IHRhcmdldC54ID09PSBJbmZpbml0eSB8fCB0YXJnZXQueSA9PT0gSW5maW5pdHkgfHwgdGFyZ2V0LnogPT09IEluZmluaXR5KSB7CiAgICAgICAgdGhyb3cgYENvdWxkIG5vdCBzb2x2ZSBlcXVhdGlvbiEgR290IHg9WyR7dGFyZ2V0LnRvU3RyaW5nKCl9XSwgYj1bJHtiLnRvU3RyaW5nKCl9XSwgQT1bJHt0aGlzLnRvU3RyaW5nKCl9XWA7CiAgICAgIH0KCiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhbiBlbGVtZW50IGluIHRoZSBtYXRyaXggYnkgaW5kZXguIEluZGV4IHN0YXJ0cyBhdCAwLCBub3QgMSEhIQogICAgICogQHBhcmFtIHZhbHVlIElmIHByb3ZpZGVkLCB0aGUgbWF0cml4IGVsZW1lbnQgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS4KICAgICAqLwoKCiAgICBlKHJvdywgY29sdW1uLCB2YWx1ZSkgewogICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgewogICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW2NvbHVtbiArIDMgKiByb3ddOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIFNldCB2YWx1ZQogICAgICAgIHRoaXMuZWxlbWVudHNbY29sdW1uICsgMyAqIHJvd10gPSB2YWx1ZTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDb3B5IGFub3RoZXIgbWF0cml4IGludG8gdGhpcyBtYXRyaXggb2JqZWN0LgogICAgICovCgoKICAgIGNvcHkobWF0cml4KSB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4LmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdGhpcy5lbGVtZW50c1tpXSA9IG1hdHJpeC5lbGVtZW50c1tpXTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeC4KICAgICAqLwoKCiAgICB0b1N0cmluZygpIHsKICAgICAgbGV0IHIgPSAnJzsKICAgICAgY29uc3Qgc2VwID0gJywnOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHsKICAgICAgICByICs9IHRoaXMuZWxlbWVudHNbaV0gKyBzZXA7CiAgICAgIH0KCiAgICAgIHJldHVybiByOwogICAgfQogICAgLyoqCiAgICAgKiByZXZlcnNlIHRoZSBtYXRyaXgKICAgICAqIEBwYXJhbSB0YXJnZXQgVGFyZ2V0IG1hdHJpeCB0byBzYXZlIGluLgogICAgICogQHJldHVybiBUaGUgc29sdXRpb24geAogICAgICovCgoKICAgIHJldmVyc2UodGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBNYXQzKCk7CiAgICAgIH0KCiAgICAgIC8vIENvbnN0cnVjdCBlcXVhdGlvbnMKICAgICAgY29uc3QgbnIgPSAzOyAvLyBudW0gcm93cwoKICAgICAgY29uc3QgbmMgPSA2OyAvLyBudW0gY29scwoKICAgICAgY29uc3QgZXFucyA9IHJldmVyc2VfZXFuczsKICAgICAgbGV0IGk7CiAgICAgIGxldCBqOwoKICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykgewogICAgICAgIGZvciAoaiA9IDA7IGogPCAzOyBqKyspIHsKICAgICAgICAgIGVxbnNbaSArIG5jICogal0gPSB0aGlzLmVsZW1lbnRzW2kgKyAzICogal07CiAgICAgICAgfQogICAgICB9CgogICAgICBlcW5zWzMgKyA2ICogMF0gPSAxOwogICAgICBlcW5zWzMgKyA2ICogMV0gPSAwOwogICAgICBlcW5zWzMgKyA2ICogMl0gPSAwOwogICAgICBlcW5zWzQgKyA2ICogMF0gPSAwOwogICAgICBlcW5zWzQgKyA2ICogMV0gPSAxOwogICAgICBlcW5zWzQgKyA2ICogMl0gPSAwOwogICAgICBlcW5zWzUgKyA2ICogMF0gPSAwOwogICAgICBlcW5zWzUgKyA2ICogMV0gPSAwOwogICAgICBlcW5zWzUgKyA2ICogMl0gPSAxOyAvLyBDb21wdXRlIHJpZ2h0IHVwcGVyIHRyaWFuZ3VsYXIgdmVyc2lvbiBvZiB0aGUgbWF0cml4IC0gR2F1c3MgZWxpbWluYXRpb24KCiAgICAgIGxldCBuID0gMzsKICAgICAgY29uc3QgayA9IG47CiAgICAgIGxldCBucDsKICAgICAgY29uc3Qga3AgPSBuYzsgLy8gbnVtIHJvd3MKCiAgICAgIGxldCBwOwoKICAgICAgZG8gewogICAgICAgIGkgPSBrIC0gbjsKCiAgICAgICAgaWYgKGVxbnNbaSArIG5jICogaV0gPT09IDApIHsKICAgICAgICAgIC8vIHRoZSBwaXZvdCBpcyBudWxsLCBzd2FwIGxpbmVzCiAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGs7IGorKykgewogICAgICAgICAgICBpZiAoZXFuc1tpICsgbmMgKiBqXSAhPT0gMCkgewogICAgICAgICAgICAgIG5wID0ga3A7CgogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIC8vIGRvIGxpbmUoIGkgKSA9IGxpbmUoIGkgKSArIGxpbmUoIGsgKQogICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7CiAgICAgICAgICAgICAgICBlcW5zW3AgKyBuYyAqIGldICs9IGVxbnNbcCArIG5jICogal07CiAgICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7CgogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAoZXFuc1tpICsgbmMgKiBpXSAhPT0gMCkgewogICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHsKICAgICAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IGVxbnNbaSArIG5jICogal0gLyBlcW5zW2kgKyBuYyAqIGldOwogICAgICAgICAgICBucCA9IGtwOwoKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIC8vIGRvIGxpbmUoIGsgKSA9IGxpbmUoIGsgKSAtIG11bHRpcGxpZXIgKiBsaW5lKCBpICkKICAgICAgICAgICAgICBwID0ga3AgLSBucDsKICAgICAgICAgICAgICBlcW5zW3AgKyBuYyAqIGpdID0gcCA8PSBpID8gMCA6IGVxbnNbcCArIG5jICogal0gLSBlcW5zW3AgKyBuYyAqIGldICogbXVsdGlwbGllcjsKICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IHdoaWxlICgtLW4pOyAvLyBlbGltaW5hdGUgdGhlIHVwcGVyIGxlZnQgdHJpYW5nbGUgb2YgdGhlIG1hdHJpeAoKCiAgICAgIGkgPSAyOwoKICAgICAgZG8gewogICAgICAgIGogPSBpIC0gMTsKCiAgICAgICAgZG8gewogICAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IGVxbnNbaSArIG5jICogal0gLyBlcW5zW2kgKyBuYyAqIGldOwogICAgICAgICAgbnAgPSBuYzsKCiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIHAgPSBuYyAtIG5wOwogICAgICAgICAgICBlcW5zW3AgKyBuYyAqIGpdID0gZXFuc1twICsgbmMgKiBqXSAtIGVxbnNbcCArIG5jICogaV0gKiBtdWx0aXBsaWVyOwogICAgICAgICAgfSB3aGlsZSAoLS1ucCk7CiAgICAgICAgfSB3aGlsZSAoai0tKTsKICAgICAgfSB3aGlsZSAoLS1pKTsgLy8gb3BlcmF0aW9ucyBvbiB0aGUgZGlhZ29uYWwKCgogICAgICBpID0gMjsKCiAgICAgIGRvIHsKICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gMSAvIGVxbnNbaSArIG5jICogaV07CiAgICAgICAgbnAgPSBuYzsKCiAgICAgICAgZG8gewogICAgICAgICAgcCA9IG5jIC0gbnA7CiAgICAgICAgICBlcW5zW3AgKyBuYyAqIGldID0gZXFuc1twICsgbmMgKiBpXSAqIG11bHRpcGxpZXI7CiAgICAgICAgfSB3aGlsZSAoLS1ucCk7CiAgICAgIH0gd2hpbGUgKGktLSk7CgogICAgICBpID0gMjsKCiAgICAgIGRvIHsKICAgICAgICBqID0gMjsKCiAgICAgICAgZG8gewogICAgICAgICAgcCA9IGVxbnNbbnIgKyBqICsgbmMgKiBpXTsKCiAgICAgICAgICBpZiAoaXNOYU4ocCkgfHwgcCA9PT0gSW5maW5pdHkpIHsKICAgICAgICAgICAgdGhyb3cgYENvdWxkIG5vdCByZXZlcnNlISBBPVske3RoaXMudG9TdHJpbmcoKX1dYDsKICAgICAgICAgIH0KCiAgICAgICAgICB0YXJnZXQuZShpLCBqLCBwKTsKICAgICAgICB9IHdoaWxlIChqLS0pOwogICAgICB9IHdoaWxlIChpLS0pOwoKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHRoZSBtYXRyaXggZnJvbSBhIHF1YXRlcmlvbgogICAgICovCgoKICAgIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24ocSkgewogICAgICBjb25zdCB4ID0gcS54OwogICAgICBjb25zdCB5ID0gcS55OwogICAgICBjb25zdCB6ID0gcS56OwogICAgICBjb25zdCB3ID0gcS53OwogICAgICBjb25zdCB4MiA9IHggKyB4OwogICAgICBjb25zdCB5MiA9IHkgKyB5OwogICAgICBjb25zdCB6MiA9IHogKyB6OwogICAgICBjb25zdCB4eCA9IHggKiB4MjsKICAgICAgY29uc3QgeHkgPSB4ICogeTI7CiAgICAgIGNvbnN0IHh6ID0geCAqIHoyOwogICAgICBjb25zdCB5eSA9IHkgKiB5MjsKICAgICAgY29uc3QgeXogPSB5ICogejI7CiAgICAgIGNvbnN0IHp6ID0geiAqIHoyOwogICAgICBjb25zdCB3eCA9IHcgKiB4MjsKICAgICAgY29uc3Qgd3kgPSB3ICogeTI7CiAgICAgIGNvbnN0IHd6ID0gdyAqIHoyOwogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50czsKICAgICAgZVszICogMCArIDBdID0gMSAtICh5eSArIHp6KTsKICAgICAgZVszICogMCArIDFdID0geHkgLSB3ejsKICAgICAgZVszICogMCArIDJdID0geHogKyB3eTsKICAgICAgZVszICogMSArIDBdID0geHkgKyB3ejsKICAgICAgZVszICogMSArIDFdID0gMSAtICh4eCArIHp6KTsKICAgICAgZVszICogMSArIDJdID0geXogLSB3eDsKICAgICAgZVszICogMiArIDBdID0geHogLSB3eTsKICAgICAgZVszICogMiArIDFdID0geXogKyB3eDsKICAgICAgZVszICogMiArIDJdID0gMSAtICh4eCArIHl5KTsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIFRyYW5zcG9zZSB0aGUgbWF0cml4CiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsLiBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0LgogICAgICogQHJldHVybiBUaGUgdGFyZ2V0IE1hdDMsIG9yIGEgbmV3IE1hdDMgaWYgdGFyZ2V0IHdhcyBvbWl0dGVkLgogICAgICovCgoKICAgIHRyYW5zcG9zZSh0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IE1hdDMoKTsKICAgICAgfQoKICAgICAgY29uc3QgTSA9IHRoaXMuZWxlbWVudHM7CiAgICAgIGNvbnN0IFQgPSB0YXJnZXQuZWxlbWVudHM7CiAgICAgIGxldCB0bXA7IC8vU2V0IGRpYWdvbmFscwoKICAgICAgVFswXSA9IE1bMF07CiAgICAgIFRbNF0gPSBNWzRdOwogICAgICBUWzhdID0gTVs4XTsKICAgICAgdG1wID0gTVsxXTsKICAgICAgVFsxXSA9IE1bM107CiAgICAgIFRbM10gPSB0bXA7CiAgICAgIHRtcCA9IE1bMl07CiAgICAgIFRbMl0gPSBNWzZdOwogICAgICBUWzZdID0gdG1wOwogICAgICB0bXAgPSBNWzVdOwogICAgICBUWzVdID0gTVs3XTsKICAgICAgVFs3XSA9IHRtcDsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KCiAgfQogIGNvbnN0IHJldmVyc2VfZXFucyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTsKCiAgLyoqCiAgICogMy1kaW1lbnNpb25hbCB2ZWN0b3IKICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCB2ID0gbmV3IFZlYzMoMSwgMiwgMykKICAgKiAgICAgY29uc29sZS5sb2coJ3g9JyArIHYueCkgLy8geD0xCiAgICovCgogIGNsYXNzIFZlYzMgewogICAgY29uc3RydWN0b3IoeCwgeSwgeikgewogICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7CiAgICAgICAgeCA9IDAuMDsKICAgICAgfQoKICAgICAgaWYgKHkgPT09IHZvaWQgMCkgewogICAgICAgIHkgPSAwLjA7CiAgICAgIH0KCiAgICAgIGlmICh6ID09PSB2b2lkIDApIHsKICAgICAgICB6ID0gMC4wOwogICAgICB9CgogICAgICB0aGlzLnggPSB4OwogICAgICB0aGlzLnkgPSB5OwogICAgICB0aGlzLnogPSB6OwogICAgfQogICAgLyoqCiAgICAgKiBWZWN0b3IgY3Jvc3MgcHJvZHVjdAogICAgICogQHBhcmFtIHRhcmdldCBPcHRpb25hbCB0YXJnZXQgdG8gc2F2ZSBpbi4KICAgICAqLwoKCiAgICBjcm9zcyh2ZWN0b3IsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCB2eCA9IHZlY3Rvci54OwogICAgICBjb25zdCB2eSA9IHZlY3Rvci55OwogICAgICBjb25zdCB2eiA9IHZlY3Rvci56OwogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICB0YXJnZXQueCA9IHkgKiB2eiAtIHogKiB2eTsKICAgICAgdGFyZ2V0LnkgPSB6ICogdnggLSB4ICogdno7CiAgICAgIHRhcmdldC56ID0geCAqIHZ5IC0geSAqIHZ4OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBTZXQgdGhlIHZlY3RvcnMnIDMgZWxlbWVudHMKICAgICAqLwoKCiAgICBzZXQoeCwgeSwgeikgewogICAgICB0aGlzLnggPSB4OwogICAgICB0aGlzLnkgPSB5OwogICAgICB0aGlzLnogPSB6OwogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogU2V0IGFsbCBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3IgdG8gemVyby4KICAgICAqLwoKCiAgICBzZXRaZXJvKCkgewogICAgICB0aGlzLnggPSB0aGlzLnkgPSB0aGlzLnogPSAwOwogICAgfQogICAgLyoqCiAgICAgKiBWZWN0b3IgYWRkaXRpb24KICAgICAqLwoKCiAgICB2YWRkKHZlY3RvciwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQpIHsKICAgICAgICB0YXJnZXQueCA9IHZlY3Rvci54ICsgdGhpcy54OwogICAgICAgIHRhcmdldC55ID0gdmVjdG9yLnkgKyB0aGlzLnk7CiAgICAgICAgdGFyZ2V0LnogPSB2ZWN0b3IueiArIHRoaXMuejsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54ICsgdmVjdG9yLngsIHRoaXMueSArIHZlY3Rvci55LCB0aGlzLnogKyB2ZWN0b3Iueik7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogVmVjdG9yIHN1YnRyYWN0aW9uCiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsIHRhcmdldCB0byBzYXZlIGluLgogICAgICovCgoKICAgIHZzdWIodmVjdG9yLCB0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCkgewogICAgICAgIHRhcmdldC54ID0gdGhpcy54IC0gdmVjdG9yLng7CiAgICAgICAgdGFyZ2V0LnkgPSB0aGlzLnkgLSB2ZWN0b3IueTsKICAgICAgICB0YXJnZXQueiA9IHRoaXMueiAtIHZlY3Rvci56OwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggLSB2ZWN0b3IueCwgdGhpcy55IC0gdmVjdG9yLnksIHRoaXMueiAtIHZlY3Rvci56KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGNyb3NzIHByb2R1Y3QgbWF0cml4IGFfY3Jvc3MgZnJvbSBhIHZlY3Rvciwgc3VjaCB0aGF0IGEgeCBiID0gYV9jcm9zcyAqIGIgPSBjCiAgICAgKgogICAgICogU2VlIHtAbGluayBodHRwczovL3d3dzguY3MudW11LnNlL2t1cnNlci9UREJEMjQvVlQwNi9sZWN0dXJlcy9MZWN0dXJlNi5wZGYgVW1lw6UgVW5pdmVyc2l0eSBMZWN0dXJlfQogICAgICovCgoKICAgIGNyb3NzbWF0KCkgewogICAgICByZXR1cm4gbmV3IE1hdDMoWzAsIC10aGlzLnosIHRoaXMueSwgdGhpcy56LCAwLCAtdGhpcy54LCAtdGhpcy55LCB0aGlzLngsIDBdKTsKICAgIH0KICAgIC8qKgogICAgICogTm9ybWFsaXplIHRoZSB2ZWN0b3IuIE5vdGUgdGhhdCB0aGlzIGNoYW5nZXMgdGhlIHZhbHVlcyBpbiB0aGUgdmVjdG9yLgogICAgICAqIEByZXR1cm4gUmV0dXJucyB0aGUgbm9ybSBvZiB0aGUgdmVjdG9yCiAgICAgKi8KCgogICAgbm9ybWFsaXplKCkgewogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICBjb25zdCBuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7CgogICAgICBpZiAobiA+IDAuMCkgewogICAgICAgIGNvbnN0IGludk4gPSAxIC8gbjsKICAgICAgICB0aGlzLnggKj0gaW52TjsKICAgICAgICB0aGlzLnkgKj0gaW52TjsKICAgICAgICB0aGlzLnogKj0gaW52TjsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBNYWtlIHNvbWV0aGluZyB1cAogICAgICAgIHRoaXMueCA9IDA7CiAgICAgICAgdGhpcy55ID0gMDsKICAgICAgICB0aGlzLnogPSAwOwogICAgICB9CgogICAgICByZXR1cm4gbjsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSB2ZXJzaW9uIG9mIHRoaXMgdmVjdG9yIHRoYXQgaXMgb2YgbGVuZ3RoIDEuCiAgICAgKiBAcGFyYW0gdGFyZ2V0IE9wdGlvbmFsIHRhcmdldCB0byBzYXZlIGluCiAgICAgKiBAcmV0dXJuIFJldHVybnMgdGhlIHVuaXQgdmVjdG9yCiAgICAgKi8KCgogICAgdW5pdCh0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgY29uc3QgeCA9IHRoaXMueDsKICAgICAgY29uc3QgeSA9IHRoaXMueTsKICAgICAgY29uc3QgeiA9IHRoaXMuejsKICAgICAgbGV0IG5pbnYgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTsKCiAgICAgIGlmIChuaW52ID4gMC4wKSB7CiAgICAgICAgbmludiA9IDEuMCAvIG5pbnY7CiAgICAgICAgdGFyZ2V0LnggPSB4ICogbmludjsKICAgICAgICB0YXJnZXQueSA9IHkgKiBuaW52OwogICAgICAgIHRhcmdldC56ID0geiAqIG5pbnY7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGFyZ2V0LnggPSAxOwogICAgICAgIHRhcmdldC55ID0gMDsKICAgICAgICB0YXJnZXQueiA9IDA7CiAgICAgIH0KCiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3IKICAgICAqLwoKCiAgICBsZW5ndGgoKSB7CiAgICAgIGNvbnN0IHggPSB0aGlzLng7CiAgICAgIGNvbnN0IHkgPSB0aGlzLnk7CiAgICAgIGNvbnN0IHogPSB0aGlzLno7CiAgICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGUgdmVjdG9yLgogICAgICovCgoKICAgIGxlbmd0aFNxdWFyZWQoKSB7CiAgICAgIHJldHVybiB0aGlzLmRvdCh0aGlzKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50CiAgICAgKi8KCgogICAgZGlzdGFuY2VUbyhwKSB7CiAgICAgIGNvbnN0IHggPSB0aGlzLng7CiAgICAgIGNvbnN0IHkgPSB0aGlzLnk7CiAgICAgIGNvbnN0IHogPSB0aGlzLno7CiAgICAgIGNvbnN0IHB4ID0gcC54OwogICAgICBjb25zdCBweSA9IHAueTsKICAgICAgY29uc3QgcHogPSBwLno7CiAgICAgIHJldHVybiBNYXRoLnNxcnQoKHB4IC0geCkgKiAocHggLSB4KSArIChweSAtIHkpICogKHB5IC0geSkgKyAocHogLSB6KSAqIChweiAtIHopKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHNxdWFyZWQgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIGFub3RoZXIgcG9pbnQKICAgICAqLwoKCiAgICBkaXN0YW5jZVNxdWFyZWQocCkgewogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICBjb25zdCBweCA9IHAueDsKICAgICAgY29uc3QgcHkgPSBwLnk7CiAgICAgIGNvbnN0IHB6ID0gcC56OwogICAgICByZXR1cm4gKHB4IC0geCkgKiAocHggLSB4KSArIChweSAtIHkpICogKHB5IC0geSkgKyAocHogLSB6KSAqIChweiAtIHopOwogICAgfQogICAgLyoqCiAgICAgKiBNdWx0aXBseSBhbGwgdGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciB3aXRoIGEgc2NhbGFyLgogICAgICogQHBhcmFtIHRhcmdldCBUaGUgdmVjdG9yIHRvIHNhdmUgdGhlIHJlc3VsdCBpbi4KICAgICAqLwoKCiAgICBzY2FsZShzY2FsYXIsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICB0YXJnZXQueCA9IHNjYWxhciAqIHg7CiAgICAgIHRhcmdldC55ID0gc2NhbGFyICogeTsKICAgICAgdGFyZ2V0LnogPSBzY2FsYXIgKiB6OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBNdWx0aXBseSB0aGUgdmVjdG9yIHdpdGggYW4gb3RoZXIgdmVjdG9yLCBjb21wb25lbnQtd2lzZS4KICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHZlY3RvciB0byBzYXZlIHRoZSByZXN1bHQgaW4uCiAgICAgKi8KCgogICAgdm11bCh2ZWN0b3IsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0YXJnZXQueCA9IHZlY3Rvci54ICogdGhpcy54OwogICAgICB0YXJnZXQueSA9IHZlY3Rvci55ICogdGhpcy55OwogICAgICB0YXJnZXQueiA9IHZlY3Rvci56ICogdGhpcy56OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBTY2FsZSBhIHZlY3RvciBhbmQgYWRkIGl0IHRvIHRoaXMgdmVjdG9yLiBTYXZlIHRoZSByZXN1bHQgaW4gInRhcmdldCIuICh0YXJnZXQgPSB0aGlzICsgdmVjdG9yICogc2NhbGFyKQogICAgICogQHBhcmFtIHRhcmdldCBUaGUgdmVjdG9yIHRvIHNhdmUgdGhlIHJlc3VsdCBpbi4KICAgICAqLwoKCiAgICBhZGRTY2FsZWRWZWN0b3Ioc2NhbGFyLCB2ZWN0b3IsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0YXJnZXQueCA9IHRoaXMueCArIHNjYWxhciAqIHZlY3Rvci54OwogICAgICB0YXJnZXQueSA9IHRoaXMueSArIHNjYWxhciAqIHZlY3Rvci55OwogICAgICB0YXJnZXQueiA9IHRoaXMueiArIHNjYWxhciAqIHZlY3Rvci56OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBDYWxjdWxhdGUgZG90IHByb2R1Y3QKICAgICAqIEBwYXJhbSB2ZWN0b3IKICAgICAqLwoKCiAgICBkb3QodmVjdG9yKSB7CiAgICAgIHJldHVybiB0aGlzLnggKiB2ZWN0b3IueCArIHRoaXMueSAqIHZlY3Rvci55ICsgdGhpcy56ICogdmVjdG9yLno7CiAgICB9CgogICAgaXNaZXJvKCkgewogICAgICByZXR1cm4gdGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMCAmJiB0aGlzLnogPT09IDA7CiAgICB9CiAgICAvKioKICAgICAqIE1ha2UgdGhlIHZlY3RvciBwb2ludCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLgogICAgICogQHBhcmFtIHRhcmdldCBPcHRpb25hbCB0YXJnZXQgdG8gc2F2ZSBpbgogICAgICovCgoKICAgIG5lZ2F0ZSh0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgdGFyZ2V0LnggPSAtdGhpcy54OwogICAgICB0YXJnZXQueSA9IC10aGlzLnk7CiAgICAgIHRhcmdldC56ID0gLXRoaXMuejsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZSB0d28gYXJ0aWZpY2lhbCB0YW5nZW50cyB0byB0aGUgdmVjdG9yCiAgICAgKiBAcGFyYW0gdDEgVmVjdG9yIG9iamVjdCB0byBzYXZlIHRoZSBmaXJzdCB0YW5nZW50IGluCiAgICAgKiBAcGFyYW0gdDIgVmVjdG9yIG9iamVjdCB0byBzYXZlIHRoZSBzZWNvbmQgdGFuZ2VudCBpbgogICAgICovCgoKICAgIHRhbmdlbnRzKHQxLCB0MikgewogICAgICBjb25zdCBub3JtID0gdGhpcy5sZW5ndGgoKTsKCiAgICAgIGlmIChub3JtID4gMC4wKSB7CiAgICAgICAgY29uc3QgbiA9IFZlYzNfdGFuZ2VudHNfbjsKICAgICAgICBjb25zdCBpbm9ybSA9IDEgLyBub3JtOwogICAgICAgIG4uc2V0KHRoaXMueCAqIGlub3JtLCB0aGlzLnkgKiBpbm9ybSwgdGhpcy56ICogaW5vcm0pOwogICAgICAgIGNvbnN0IHJhbmRWZWMgPSBWZWMzX3RhbmdlbnRzX3JhbmRWZWM7CgogICAgICAgIGlmIChNYXRoLmFicyhuLngpIDwgMC45KSB7CiAgICAgICAgICByYW5kVmVjLnNldCgxLCAwLCAwKTsKICAgICAgICAgIG4uY3Jvc3MocmFuZFZlYywgdDEpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByYW5kVmVjLnNldCgwLCAxLCAwKTsKICAgICAgICAgIG4uY3Jvc3MocmFuZFZlYywgdDEpOwogICAgICAgIH0KCiAgICAgICAgbi5jcm9zcyh0MSwgdDIpOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIFRoZSBub3JtYWwgbGVuZ3RoIGlzIHplcm8sIG1ha2Ugc29tZXRoaW5nIHVwCiAgICAgICAgdDEuc2V0KDEsIDAsIDApOwogICAgICAgIHQyLnNldCgwLCAxLCAwKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyB0byBhIG1vcmUgcmVhZGFibGUgZm9ybWF0CiAgICAgKi8KCgogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiBgJHt0aGlzLnh9LCR7dGhpcy55fSwke3RoaXMuen1gOwogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyB0byBhbiBhcnJheQogICAgICovCgoKICAgIHRvQXJyYXkoKSB7CiAgICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMuel07CiAgICB9CiAgICAvKioKICAgICAqIENvcGllcyB2YWx1ZSBvZiBzb3VyY2UgdG8gdGhpcyB2ZWN0b3IuCiAgICAgKi8KCgogICAgY29weSh2ZWN0b3IpIHsKICAgICAgdGhpcy54ID0gdmVjdG9yLng7CiAgICAgIHRoaXMueSA9IHZlY3Rvci55OwogICAgICB0aGlzLnogPSB2ZWN0b3IuejsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIERvIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjdG9ycwogICAgICogQHBhcmFtIHQgQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLiAwIHdpbGwgbWFrZSB0aGlzIGZ1bmN0aW9uIHJldHVybiB1LCBhbmQgMSB3aWxsIG1ha2UgaXQgcmV0dXJuIHYuIE51bWJlcnMgaW4gYmV0d2VlbiB3aWxsIGdlbmVyYXRlIGEgdmVjdG9yIGluIGJldHdlZW4gdGhlbS4KICAgICAqLwoKCiAgICBsZXJwKHZlY3RvciwgdCwgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IHggPSB0aGlzLng7CiAgICAgIGNvbnN0IHkgPSB0aGlzLnk7CiAgICAgIGNvbnN0IHogPSB0aGlzLno7CiAgICAgIHRhcmdldC54ID0geCArICh2ZWN0b3IueCAtIHgpICogdDsKICAgICAgdGFyZ2V0LnkgPSB5ICsgKHZlY3Rvci55IC0geSkgKiB0OwogICAgICB0YXJnZXQueiA9IHogKyAodmVjdG9yLnogLSB6KSAqIHQ7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrIGlmIGEgdmVjdG9yIGVxdWFscyBpcyBhbG1vc3QgZXF1YWwgdG8gYW5vdGhlciBvbmUuCiAgICAgKi8KCgogICAgYWxtb3N0RXF1YWxzKHZlY3RvciwgcHJlY2lzaW9uKSB7CiAgICAgIGlmIChwcmVjaXNpb24gPT09IHZvaWQgMCkgewogICAgICAgIHByZWNpc2lvbiA9IDFlLTY7CiAgICAgIH0KCiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnggLSB2ZWN0b3IueCkgPiBwcmVjaXNpb24gfHwgTWF0aC5hYnModGhpcy55IC0gdmVjdG9yLnkpID4gcHJlY2lzaW9uIHx8IE1hdGguYWJzKHRoaXMueiAtIHZlY3Rvci56KSA+IHByZWNpc2lvbikgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrIGlmIGEgdmVjdG9yIGlzIGFsbW9zdCB6ZXJvCiAgICAgKi8KCgogICAgYWxtb3N0WmVybyhwcmVjaXNpb24pIHsKICAgICAgaWYgKHByZWNpc2lvbiA9PT0gdm9pZCAwKSB7CiAgICAgICAgcHJlY2lzaW9uID0gMWUtNjsKICAgICAgfQoKICAgICAgaWYgKE1hdGguYWJzKHRoaXMueCkgPiBwcmVjaXNpb24gfHwgTWF0aC5hYnModGhpcy55KSA+IHByZWNpc2lvbiB8fCBNYXRoLmFicyh0aGlzLnopID4gcHJlY2lzaW9uKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2sgaWYgdGhlIHZlY3RvciBpcyBhbnRpLXBhcmFsbGVsIHRvIGFub3RoZXIgdmVjdG9yLgogICAgICogQHBhcmFtIHByZWNpc2lvbiBTZXQgdG8gemVybyBmb3IgZXhhY3QgY29tcGFyaXNvbnMKICAgICAqLwoKCiAgICBpc0FudGlwYXJhbGxlbFRvKHZlY3RvciwgcHJlY2lzaW9uKSB7CiAgICAgIHRoaXMubmVnYXRlKGFudGlwX25lZyk7CiAgICAgIHJldHVybiBhbnRpcF9uZWcuYWxtb3N0RXF1YWxzKHZlY3RvciwgcHJlY2lzaW9uKTsKICAgIH0KICAgIC8qKgogICAgICogQ2xvbmUgdGhlIHZlY3RvcgogICAgICovCgoKICAgIGNsb25lKCkgewogICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54LCB0aGlzLnksIHRoaXMueik7CiAgICB9CgogIH0KICBWZWMzLlpFUk8gPSBuZXcgVmVjMygwLCAwLCAwKTsKICBWZWMzLlVOSVRfWCA9IG5ldyBWZWMzKDEsIDAsIDApOwogIFZlYzMuVU5JVF9ZID0gbmV3IFZlYzMoMCwgMSwgMCk7CiAgVmVjMy5VTklUX1ogPSBuZXcgVmVjMygwLCAwLCAxKTsKICBjb25zdCBWZWMzX3RhbmdlbnRzX24gPSBuZXcgVmVjMygpOwogIGNvbnN0IFZlYzNfdGFuZ2VudHNfcmFuZFZlYyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYW50aXBfbmVnID0gbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBjbGFzcy4KICAgKi8KICBjbGFzcyBBQUJCIHsKICAgIC8qKgogICAgICogVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3gKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3gKICAgICAqLwogICAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICB0aGlzLmxvd2VyQm91bmQgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnVwcGVyQm91bmQgPSBuZXcgVmVjMygpOwoKICAgICAgaWYgKG9wdGlvbnMubG93ZXJCb3VuZCkgewogICAgICAgIHRoaXMubG93ZXJCb3VuZC5jb3B5KG9wdGlvbnMubG93ZXJCb3VuZCk7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLnVwcGVyQm91bmQpIHsKICAgICAgICB0aGlzLnVwcGVyQm91bmQuY29weShvcHRpb25zLnVwcGVyQm91bmQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgQUFCQiBib3VuZHMgZnJvbSBhIHNldCBvZiBwb2ludHMuCiAgICAgKiBAcGFyYW0gcG9pbnRzIEFuIGFycmF5IG9mIFZlYzMncy4KICAgICAqIEByZXR1cm4gVGhlIHNlbGYgb2JqZWN0CiAgICAgKi8KCgogICAgc2V0RnJvbVBvaW50cyhwb2ludHMsIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBza2luU2l6ZSkgewogICAgICBjb25zdCBsID0gdGhpcy5sb3dlckJvdW5kOwogICAgICBjb25zdCB1ID0gdGhpcy51cHBlckJvdW5kOwogICAgICBjb25zdCBxID0gcXVhdGVybmlvbjsgLy8gU2V0IHRvIHRoZSBmaXJzdCBwb2ludAoKICAgICAgbC5jb3B5KHBvaW50c1swXSk7CgogICAgICBpZiAocSkgewogICAgICAgIHEudm11bHQobCwgbCk7CiAgICAgIH0KCiAgICAgIHUuY29weShsKTsKCiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgbGV0IHAgPSBwb2ludHNbaV07CgogICAgICAgIGlmIChxKSB7CiAgICAgICAgICBxLnZtdWx0KHAsIHRtcCQxKTsKICAgICAgICAgIHAgPSB0bXAkMTsKICAgICAgICB9CgogICAgICAgIGlmIChwLnggPiB1LngpIHsKICAgICAgICAgIHUueCA9IHAueDsKICAgICAgICB9CgogICAgICAgIGlmIChwLnggPCBsLngpIHsKICAgICAgICAgIGwueCA9IHAueDsKICAgICAgICB9CgogICAgICAgIGlmIChwLnkgPiB1LnkpIHsKICAgICAgICAgIHUueSA9IHAueTsKICAgICAgICB9CgogICAgICAgIGlmIChwLnkgPCBsLnkpIHsKICAgICAgICAgIGwueSA9IHAueTsKICAgICAgICB9CgogICAgICAgIGlmIChwLnogPiB1LnopIHsKICAgICAgICAgIHUueiA9IHAuejsKICAgICAgICB9CgogICAgICAgIGlmIChwLnogPCBsLnopIHsKICAgICAgICAgIGwueiA9IHAuejsKICAgICAgICB9CiAgICAgIH0gLy8gQWRkIG9mZnNldAoKCiAgICAgIGlmIChwb3NpdGlvbikgewogICAgICAgIHBvc2l0aW9uLnZhZGQobCwgbCk7CiAgICAgICAgcG9zaXRpb24udmFkZCh1LCB1KTsKICAgICAgfQoKICAgICAgaWYgKHNraW5TaXplKSB7CiAgICAgICAgbC54IC09IHNraW5TaXplOwogICAgICAgIGwueSAtPSBza2luU2l6ZTsKICAgICAgICBsLnogLT0gc2tpblNpemU7CiAgICAgICAgdS54ICs9IHNraW5TaXplOwogICAgICAgIHUueSArPSBza2luU2l6ZTsKICAgICAgICB1LnogKz0gc2tpblNpemU7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgLyoqCiAgICAgKiBDb3B5IGJvdW5kcyBmcm9tIGFuIEFBQkIgdG8gdGhpcyBBQUJCCiAgICAgKiBAcGFyYW0gYWFiYiBTb3VyY2UgdG8gY29weSBmcm9tCiAgICAgKiBAcmV0dXJuIFRoZSB0aGlzIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eQogICAgICovCgoKICAgIGNvcHkoYWFiYikgewogICAgICB0aGlzLmxvd2VyQm91bmQuY29weShhYWJiLmxvd2VyQm91bmQpOwogICAgICB0aGlzLnVwcGVyQm91bmQuY29weShhYWJiLnVwcGVyQm91bmQpOwogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogQ2xvbmUgYW4gQUFCQgogICAgICovCgoKICAgIGNsb25lKCkgewogICAgICByZXR1cm4gbmV3IEFBQkIoKS5jb3B5KHRoaXMpOwogICAgfQogICAgLyoqCiAgICAgKiBFeHRlbmQgdGhpcyBBQUJCIHNvIHRoYXQgaXQgY292ZXJzIHRoZSBnaXZlbiBBQUJCIHRvby4KICAgICAqLwoKCiAgICBleHRlbmQoYWFiYikgewogICAgICB0aGlzLmxvd2VyQm91bmQueCA9IE1hdGgubWluKHRoaXMubG93ZXJCb3VuZC54LCBhYWJiLmxvd2VyQm91bmQueCk7CiAgICAgIHRoaXMudXBwZXJCb3VuZC54ID0gTWF0aC5tYXgodGhpcy51cHBlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC54KTsKICAgICAgdGhpcy5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbih0aGlzLmxvd2VyQm91bmQueSwgYWFiYi5sb3dlckJvdW5kLnkpOwogICAgICB0aGlzLnVwcGVyQm91bmQueSA9IE1hdGgubWF4KHRoaXMudXBwZXJCb3VuZC55LCBhYWJiLnVwcGVyQm91bmQueSk7CiAgICAgIHRoaXMubG93ZXJCb3VuZC56ID0gTWF0aC5taW4odGhpcy5sb3dlckJvdW5kLnosIGFhYmIubG93ZXJCb3VuZC56KTsKICAgICAgdGhpcy51cHBlckJvdW5kLnogPSBNYXRoLm1heCh0aGlzLnVwcGVyQm91bmQueiwgYWFiYi51cHBlckJvdW5kLnopOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIEFBQkIgb3ZlcmxhcHMgdGhpcyBBQUJCLgogICAgICovCgoKICAgIG92ZXJsYXBzKGFhYmIpIHsKICAgICAgY29uc3QgbDEgPSB0aGlzLmxvd2VyQm91bmQ7CiAgICAgIGNvbnN0IHUxID0gdGhpcy51cHBlckJvdW5kOwogICAgICBjb25zdCBsMiA9IGFhYmIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdTIgPSBhYWJiLnVwcGVyQm91bmQ7IC8vICAgICAgbDIgICAgICAgIHUyCiAgICAgIC8vICAgICAgfC0tLS0tLS0tLXwKICAgICAgLy8gfC0tLS0tLS0tfAogICAgICAvLyBsMSAgICAgICB1MQoKICAgICAgY29uc3Qgb3ZlcmxhcHNYID0gbDIueCA8PSB1MS54ICYmIHUxLnggPD0gdTIueCB8fCBsMS54IDw9IHUyLnggJiYgdTIueCA8PSB1MS54OwogICAgICBjb25zdCBvdmVybGFwc1kgPSBsMi55IDw9IHUxLnkgJiYgdTEueSA8PSB1Mi55IHx8IGwxLnkgPD0gdTIueSAmJiB1Mi55IDw9IHUxLnk7CiAgICAgIGNvbnN0IG92ZXJsYXBzWiA9IGwyLnogPD0gdTEueiAmJiB1MS56IDw9IHUyLnogfHwgbDEueiA8PSB1Mi56ICYmIHUyLnogPD0gdTEuejsKICAgICAgcmV0dXJuIG92ZXJsYXBzWCAmJiBvdmVybGFwc1kgJiYgb3ZlcmxhcHNaOwogICAgfSAvLyBNb3N0bHkgZm9yIGRlYnVnZ2luZwoKCiAgICB2b2x1bWUoKSB7CiAgICAgIGNvbnN0IGwgPSB0aGlzLmxvd2VyQm91bmQ7CiAgICAgIGNvbnN0IHUgPSB0aGlzLnVwcGVyQm91bmQ7CiAgICAgIHJldHVybiAodS54IC0gbC54KSAqICh1LnkgLSBsLnkpICogKHUueiAtIGwueik7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBpcyBmdWxseSBjb250YWluZWQgaW4gdGhpcyBBQUJCLgogICAgICovCgoKICAgIGNvbnRhaW5zKGFhYmIpIHsKICAgICAgY29uc3QgbDEgPSB0aGlzLmxvd2VyQm91bmQ7CiAgICAgIGNvbnN0IHUxID0gdGhpcy51cHBlckJvdW5kOwogICAgICBjb25zdCBsMiA9IGFhYmIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdTIgPSBhYWJiLnVwcGVyQm91bmQ7IC8vICAgICAgbDIgICAgICAgIHUyCiAgICAgIC8vICAgICAgfC0tLS0tLS0tLXwKICAgICAgLy8gfC0tLS0tLS0tLS0tLS0tLXwKICAgICAgLy8gbDEgICAgICAgICAgICAgIHUxCgogICAgICByZXR1cm4gbDEueCA8PSBsMi54ICYmIHUxLnggPj0gdTIueCAmJiBsMS55IDw9IGwyLnkgJiYgdTEueSA+PSB1Mi55ICYmIGwxLnogPD0gbDIueiAmJiB1MS56ID49IHUyLno7CiAgICB9CgogICAgZ2V0Q29ybmVycyhhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7CiAgICAgIGNvbnN0IGwgPSB0aGlzLmxvd2VyQm91bmQ7CiAgICAgIGNvbnN0IHUgPSB0aGlzLnVwcGVyQm91bmQ7CiAgICAgIGEuY29weShsKTsKICAgICAgYi5zZXQodS54LCBsLnksIGwueik7CiAgICAgIGMuc2V0KHUueCwgdS55LCBsLnopOwogICAgICBkLnNldChsLngsIHUueSwgdS56KTsKICAgICAgZS5zZXQodS54LCBsLnksIHUueik7CiAgICAgIGYuc2V0KGwueCwgdS55LCBsLnopOwogICAgICBnLnNldChsLngsIGwueSwgdS56KTsKICAgICAgaC5jb3B5KHUpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFBQkIgaW4gYW5vdGhlciBmcmFtZS4KICAgICAqIEByZXR1cm4gVGhlICJ0YXJnZXQiIEFBQkIgb2JqZWN0LgogICAgICovCgoKICAgIHRvTG9jYWxGcmFtZShmcmFtZSwgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IGNvcm5lcnMgPSB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVyczsKICAgICAgY29uc3QgYSA9IGNvcm5lcnNbMF07CiAgICAgIGNvbnN0IGIgPSBjb3JuZXJzWzFdOwogICAgICBjb25zdCBjID0gY29ybmVyc1syXTsKICAgICAgY29uc3QgZCA9IGNvcm5lcnNbM107CiAgICAgIGNvbnN0IGUgPSBjb3JuZXJzWzRdOwogICAgICBjb25zdCBmID0gY29ybmVyc1s1XTsKICAgICAgY29uc3QgZyA9IGNvcm5lcnNbNl07CiAgICAgIGNvbnN0IGggPSBjb3JuZXJzWzddOyAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lCgogICAgICB0aGlzLmdldENvcm5lcnMoYSwgYiwgYywgZCwgZSwgZiwgZywgaCk7IC8vIFRyYW5zZm9ybSB0aGVtIHRvIG5ldyBsb2NhbCBmcmFtZQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDg7IGkrKykgewogICAgICAgIGNvbnN0IGNvcm5lciA9IGNvcm5lcnNbaV07CiAgICAgICAgZnJhbWUucG9pbnRUb0xvY2FsKGNvcm5lciwgY29ybmVyKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRhcmdldC5zZXRGcm9tUG9pbnRzKGNvcm5lcnMpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFBQkIgaW4gdGhlIGdsb2JhbCBmcmFtZS4KICAgICAqIEByZXR1cm4gVGhlICJ0YXJnZXQiIEFBQkIgb2JqZWN0LgogICAgICovCgoKICAgIHRvV29ybGRGcmFtZShmcmFtZSwgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IGNvcm5lcnMgPSB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVyczsKICAgICAgY29uc3QgYSA9IGNvcm5lcnNbMF07CiAgICAgIGNvbnN0IGIgPSBjb3JuZXJzWzFdOwogICAgICBjb25zdCBjID0gY29ybmVyc1syXTsKICAgICAgY29uc3QgZCA9IGNvcm5lcnNbM107CiAgICAgIGNvbnN0IGUgPSBjb3JuZXJzWzRdOwogICAgICBjb25zdCBmID0gY29ybmVyc1s1XTsKICAgICAgY29uc3QgZyA9IGNvcm5lcnNbNl07CiAgICAgIGNvbnN0IGggPSBjb3JuZXJzWzddOyAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lCgogICAgICB0aGlzLmdldENvcm5lcnMoYSwgYiwgYywgZCwgZSwgZiwgZywgaCk7IC8vIFRyYW5zZm9ybSB0aGVtIHRvIG5ldyBsb2NhbCBmcmFtZQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDg7IGkrKykgewogICAgICAgIGNvbnN0IGNvcm5lciA9IGNvcm5lcnNbaV07CiAgICAgICAgZnJhbWUucG9pbnRUb1dvcmxkKGNvcm5lciwgY29ybmVyKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRhcmdldC5zZXRGcm9tUG9pbnRzKGNvcm5lcnMpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVjayBpZiB0aGUgQUFCQiBpcyBoaXQgYnkgYSByYXkuCiAgICAgKi8KCgogICAgb3ZlcmxhcHNSYXkocmF5KSB7CiAgICAgIGNvbnN0IHsKICAgICAgICBkaXJlY3Rpb24sCiAgICAgICAgZnJvbQogICAgICB9ID0gcmF5OyAvLyBjb25zdCB0ID0gMAogICAgICAvLyByYXkuZGlyZWN0aW9uIGlzIHVuaXQgZGlyZWN0aW9uIHZlY3RvciBvZiByYXkKCiAgICAgIGNvbnN0IGRpckZyYWNYID0gMSAvIGRpcmVjdGlvbi54OwogICAgICBjb25zdCBkaXJGcmFjWSA9IDEgLyBkaXJlY3Rpb24ueTsKICAgICAgY29uc3QgZGlyRnJhY1ogPSAxIC8gZGlyZWN0aW9uLno7IC8vIHRoaXMubG93ZXJCb3VuZCBpcyB0aGUgY29ybmVyIG9mIEFBQkIgd2l0aCBtaW5pbWFsIGNvb3JkaW5hdGVzIC0gbGVmdCBib3R0b20sIHJ0IGlzIG1heGltYWwgY29ybmVyCgogICAgICBjb25zdCB0MSA9ICh0aGlzLmxvd2VyQm91bmQueCAtIGZyb20ueCkgKiBkaXJGcmFjWDsKICAgICAgY29uc3QgdDIgPSAodGhpcy51cHBlckJvdW5kLnggLSBmcm9tLngpICogZGlyRnJhY1g7CiAgICAgIGNvbnN0IHQzID0gKHRoaXMubG93ZXJCb3VuZC55IC0gZnJvbS55KSAqIGRpckZyYWNZOwogICAgICBjb25zdCB0NCA9ICh0aGlzLnVwcGVyQm91bmQueSAtIGZyb20ueSkgKiBkaXJGcmFjWTsKICAgICAgY29uc3QgdDUgPSAodGhpcy5sb3dlckJvdW5kLnogLSBmcm9tLnopICogZGlyRnJhY1o7CiAgICAgIGNvbnN0IHQ2ID0gKHRoaXMudXBwZXJCb3VuZC56IC0gZnJvbS56KSAqIGRpckZyYWNaOyAvLyBjb25zdCB0bWluID0gTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5taW4odDEsIHQyKSwgTWF0aC5taW4odDMsIHQ0KSkpOwogICAgICAvLyBjb25zdCB0bWF4ID0gTWF0aC5taW4oTWF0aC5taW4oTWF0aC5tYXgodDEsIHQyKSwgTWF0aC5tYXgodDMsIHQ0KSkpOwoKICAgICAgY29uc3QgdG1pbiA9IE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWluKHQxLCB0MiksIE1hdGgubWluKHQzLCB0NCkpLCBNYXRoLm1pbih0NSwgdDYpKTsKICAgICAgY29uc3QgdG1heCA9IE1hdGgubWluKE1hdGgubWluKE1hdGgubWF4KHQxLCB0MiksIE1hdGgubWF4KHQzLCB0NCkpLCBNYXRoLm1heCh0NSwgdDYpKTsgLy8gaWYgdG1heCA8IDAsIHJheSAobGluZSkgaXMgaW50ZXJzZWN0aW5nIEFBQkIsIGJ1dCB3aG9sZSBBQUJCIGlzIGJlaGluZyB1cwoKICAgICAgaWYgKHRtYXggPCAwKSB7CiAgICAgICAgLy90ID0gdG1heDsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gLy8gaWYgdG1pbiA+IHRtYXgsIHJheSBkb2Vzbid0IGludGVyc2VjdCBBQUJCCgoKICAgICAgaWYgKHRtaW4gPiB0bWF4KSB7CiAgICAgICAgLy90ID0gdG1heDsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICB9CiAgY29uc3QgdG1wJDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzID0gW25ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCldOwoKICAvKioKICAgKiBDb2xsaXNpb24gIm1hdHJpeCIuCiAgICogSXQncyBhY3R1YWxseSBhIHRyaWFuZ3VsYXItc2hhcGVkIGFycmF5IG9mIHdoZXRoZXIgdHdvIGJvZGllcyBhcmUgdG91Y2hpbmcgdGhpcyBzdGVwLCBmb3IgcmVmZXJlbmNlIG5leHQgc3RlcAogICAqLwogIGNsYXNzIEFycmF5Q29sbGlzaW9uTWF0cml4IHsKICAgIC8qKgogICAgICogVGhlIG1hdHJpeCBzdG9yYWdlLgogICAgICovCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgdGhpcy5tYXRyaXggPSBbXTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGFuIGVsZW1lbnQKICAgICAqLwoKCiAgICBnZXQoYmksIGJqKSB7CiAgICAgIGxldCB7CiAgICAgICAgaW5kZXg6IGkKICAgICAgfSA9IGJpOwogICAgICBsZXQgewogICAgICAgIGluZGV4OiBqCiAgICAgIH0gPSBiajsKCiAgICAgIGlmIChqID4gaSkgewogICAgICAgIGNvbnN0IHRlbXAgPSBqOwogICAgICAgIGogPSBpOwogICAgICAgIGkgPSB0ZW1wOwogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5tYXRyaXhbKGkgKiAoaSArIDEpID4+IDEpICsgaiAtIDFdOwogICAgfQogICAgLyoqCiAgICAgKiBTZXQgYW4gZWxlbWVudAogICAgICovCgoKICAgIHNldChiaSwgYmosIHZhbHVlKSB7CiAgICAgIGxldCB7CiAgICAgICAgaW5kZXg6IGkKICAgICAgfSA9IGJpOwogICAgICBsZXQgewogICAgICAgIGluZGV4OiBqCiAgICAgIH0gPSBiajsKCiAgICAgIGlmIChqID4gaSkgewogICAgICAgIGNvbnN0IHRlbXAgPSBqOwogICAgICAgIGogPSBpOwogICAgICAgIGkgPSB0ZW1wOwogICAgICB9CgogICAgICB0aGlzLm1hdHJpeFsoaSAqIChpICsgMSkgPj4gMSkgKyBqIC0gMV0gPSB2YWx1ZSA/IDEgOiAwOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIGFsbCBlbGVtZW50cyB0byB6ZXJvCiAgICAgKi8KCgogICAgcmVzZXQoKSB7CiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5tYXRyaXgubGVuZ3RoOyBpICE9PSBsOyBpKyspIHsKICAgICAgICB0aGlzLm1hdHJpeFtpXSA9IDA7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogU2V0cyB0aGUgbWF4IG51bWJlciBvZiBvYmplY3RzCiAgICAgKi8KCgogICAgc2V0TnVtT2JqZWN0cyhuKSB7CiAgICAgIHRoaXMubWF0cml4Lmxlbmd0aCA9IG4gKiAobiAtIDEpID4+IDE7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQmFzZSBjbGFzcyBmb3Igb2JqZWN0cyB0aGF0IGRpc3BhdGNoZXMgZXZlbnRzLgogICAqLwogIGNsYXNzIEV2ZW50VGFyZ2V0IHsKICAgIC8qKgogICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyCiAgICAgKiBAcmV0dXJuIFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS4KICAgICAqLwogICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHsKICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTsKICAgICAgfQoKICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzOwoKICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgbGlzdGVuZXJzW3R5cGVdID0gW107CiAgICAgIH0KCiAgICAgIGlmICghbGlzdGVuZXJzW3R5cGVdLmluY2x1ZGVzKGxpc3RlbmVyKSkgewogICAgICAgIGxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrIGlmIGFuIGV2ZW50IGxpc3RlbmVyIGlzIGFkZGVkCiAgICAgKi8KCgogICAgaGFzRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyczsKCiAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbdHlwZV0uaW5jbHVkZXMobGlzdGVuZXIpKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KCiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2sgaWYgYW55IGV2ZW50IGxpc3RlbmVyIG9mIHRoZSBnaXZlbiB0eXBlIGlzIGFkZGVkCiAgICAgKi8KCgogICAgaGFzQW55RXZlbnRMaXN0ZW5lcih0eXBlKSB7CiAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzOwogICAgICByZXR1cm4gbGlzdGVuZXJzW3R5cGVdICE9PSB1bmRlZmluZWQ7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lcgogICAgICogQHJldHVybiBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuCiAgICAgKi8KCgogICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfQoKICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzOwoKICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0KCiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpOwoKICAgICAgaWYgKGluZGV4ICE9PSAtMSkgewogICAgICAgIGxpc3RlbmVyc1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpOwogICAgICB9CgogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogRW1pdCBhbiBldmVudC4KICAgICAqIEByZXR1cm4gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LgogICAgICovCgoKICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHsKICAgICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0KCiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyczsKICAgICAgY29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1tldmVudC50eXBlXTsKCiAgICAgIGlmIChsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQpIHsKICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzOwoKICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxpc3RlbmVyQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICBsaXN0ZW5lckFycmF5W2ldLmNhbGwodGhpcywgZXZlbnQpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQSBRdWF0ZXJuaW9uIGRlc2NyaWJlcyBhIHJvdGF0aW9uIGluIDNEIHNwYWNlLiBUaGUgUXVhdGVybmlvbiBpcyBtYXRoZW1hdGljYWxseSBkZWZpbmVkIGFzIFEgPSB4KmkgKyB5KmogKyB6KmsgKyB3LCB3aGVyZSAoaSxqLGspIGFyZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9ycy4gKHgseSx6KSBjYW4gYmUgc2VlbiBhcyBhIHZlY3RvciByZWxhdGVkIHRvIHRoZSBheGlzIG9mIHJvdGF0aW9uLCB3aGlsZSB0aGUgcmVhbCBtdWx0aXBsaWVyLCB3LCBpcyByZWxhdGVkIHRvIHRoZSBhbW91bnQgb2Ygcm90YXRpb24uCiAgICogQHBhcmFtIHggTXVsdGlwbGllciBvZiB0aGUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvciBpLgogICAqIEBwYXJhbSB5IE11bHRpcGxpZXIgb2YgdGhlIGltYWdpbmFyeSBiYXNpcyB2ZWN0b3Igai4KICAgKiBAcGFyYW0geiBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGsuCiAgICogQHBhcmFtIHcgTXVsdGlwbGllciBvZiB0aGUgcmVhbCBwYXJ0LgogICAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWF0ZXJuaW9uCiAgICovCgogIGNsYXNzIFF1YXRlcm5pb24gewogICAgY29uc3RydWN0b3IoeCwgeSwgeiwgdykgewogICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7CiAgICAgICAgeCA9IDA7CiAgICAgIH0KCiAgICAgIGlmICh5ID09PSB2b2lkIDApIHsKICAgICAgICB5ID0gMDsKICAgICAgfQoKICAgICAgaWYgKHogPT09IHZvaWQgMCkgewogICAgICAgIHogPSAwOwogICAgICB9CgogICAgICBpZiAodyA9PT0gdm9pZCAwKSB7CiAgICAgICAgdyA9IDE7CiAgICAgIH0KCiAgICAgIHRoaXMueCA9IHg7CiAgICAgIHRoaXMueSA9IHk7CiAgICAgIHRoaXMueiA9IHo7CiAgICAgIHRoaXMudyA9IHc7CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIHF1YXRlcm5pb24uCiAgICAgKi8KCgogICAgc2V0KHgsIHksIHosIHcpIHsKICAgICAgdGhpcy54ID0geDsKICAgICAgdGhpcy55ID0geTsKICAgICAgdGhpcy56ID0gejsKICAgICAgdGhpcy53ID0gdzsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnQgdG8gYSByZWFkYWJsZSBmb3JtYXQKICAgICAqIEByZXR1cm4gIngseSx6LHciCiAgICAgKi8KCgogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiBgJHt0aGlzLnh9LCR7dGhpcy55fSwke3RoaXMuen0sJHt0aGlzLnd9YDsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydCB0byBhbiBBcnJheQogICAgICogQHJldHVybiBbeCwgeSwgeiwgd10KICAgICAqLwoKCiAgICB0b0FycmF5KCkgewogICAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMud107CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgcXVhdGVybmlvbiBjb21wb25lbnRzIGdpdmVuIGFuIGF4aXMgYW5kIGFuIGFuZ2xlIGluIHJhZGlhbnMuCiAgICAgKi8KCgogICAgc2V0RnJvbUF4aXNBbmdsZSh2ZWN0b3IsIGFuZ2xlKSB7CiAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZSAqIDAuNSk7CiAgICAgIHRoaXMueCA9IHZlY3Rvci54ICogczsKICAgICAgdGhpcy55ID0gdmVjdG9yLnkgKiBzOwogICAgICB0aGlzLnogPSB2ZWN0b3IueiAqIHM7CiAgICAgIHRoaXMudyA9IE1hdGguY29zKGFuZ2xlICogMC41KTsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnRzIHRoZSBxdWF0ZXJuaW9uIHRvIFsgYXhpcywgYW5nbGUgXSByZXByZXNlbnRhdGlvbi4KICAgICAqIEBwYXJhbSB0YXJnZXRBeGlzIEEgdmVjdG9yIG9iamVjdCB0byByZXVzZSBmb3Igc3RvcmluZyB0aGUgYXhpcy4KICAgICAqIEByZXR1cm4gQW4gYXJyYXksIGZpcnN0IGVsZW1lbnQgaXMgdGhlIGF4aXMgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGFuZ2xlIGluIHJhZGlhbnMuCiAgICAgKi8KCgogICAgdG9BeGlzQW5nbGUodGFyZ2V0QXhpcykgewogICAgICBpZiAodGFyZ2V0QXhpcyA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0QXhpcyA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHRoaXMubm9ybWFsaXplKCk7IC8vIGlmIHc+MSBhY29zIGFuZCBzcXJ0IHdpbGwgcHJvZHVjZSBlcnJvcnMsIHRoaXMgY2FudCBoYXBwZW4gaWYgcXVhdGVybmlvbiBpcyBub3JtYWxpc2VkCgogICAgICBjb25zdCBhbmdsZSA9IDIgKiBNYXRoLmFjb3ModGhpcy53KTsKICAgICAgY29uc3QgcyA9IE1hdGguc3FydCgxIC0gdGhpcy53ICogdGhpcy53KTsgLy8gYXNzdW1pbmcgcXVhdGVybmlvbiBub3JtYWxpc2VkIHRoZW4gdyBpcyBsZXNzIHRoYW4gMSwgc28gdGVybSBhbHdheXMgcG9zaXRpdmUuCgogICAgICBpZiAocyA8IDAuMDAxKSB7CiAgICAgICAgLy8gdGVzdCB0byBhdm9pZCBkaXZpZGUgYnkgemVybywgcyBpcyBhbHdheXMgcG9zaXRpdmUgZHVlIHRvIHNxcnQKICAgICAgICAvLyBpZiBzIGNsb3NlIHRvIHplcm8gdGhlbiBkaXJlY3Rpb24gb2YgYXhpcyBub3QgaW1wb3J0YW50CiAgICAgICAgdGFyZ2V0QXhpcy54ID0gdGhpcy54OyAvLyBpZiBpdCBpcyBpbXBvcnRhbnQgdGhhdCBheGlzIGlzIG5vcm1hbGlzZWQgdGhlbiByZXBsYWNlIHdpdGggeD0xOyB5PXo9MDsKCiAgICAgICAgdGFyZ2V0QXhpcy55ID0gdGhpcy55OwogICAgICAgIHRhcmdldEF4aXMueiA9IHRoaXMuejsKICAgICAgfSBlbHNlIHsKICAgICAgICB0YXJnZXRBeGlzLnggPSB0aGlzLnggLyBzOyAvLyBub3JtYWxpc2UgYXhpcwoKICAgICAgICB0YXJnZXRBeGlzLnkgPSB0aGlzLnkgLyBzOwogICAgICAgIHRhcmdldEF4aXMueiA9IHRoaXMueiAvIHM7CiAgICAgIH0KCiAgICAgIHJldHVybiBbdGFyZ2V0QXhpcywgYW5nbGVdOwogICAgfQogICAgLyoqCiAgICAgKiBTZXQgdGhlIHF1YXRlcm5pb24gdmFsdWUgZ2l2ZW4gdHdvIHZlY3RvcnMuIFRoZSByZXN1bHRpbmcgcm90YXRpb24gd2lsbCBiZSB0aGUgbmVlZGVkIHJvdGF0aW9uIHRvIHJvdGF0ZSB1IHRvIHYuCiAgICAgKi8KCgogICAgc2V0RnJvbVZlY3RvcnModSwgdikgewogICAgICBpZiAodS5pc0FudGlwYXJhbGxlbFRvKHYpKSB7CiAgICAgICAgY29uc3QgdDEgPSBzZnZfdDE7CiAgICAgICAgY29uc3QgdDIgPSBzZnZfdDI7CiAgICAgICAgdS50YW5nZW50cyh0MSwgdDIpOwogICAgICAgIHRoaXMuc2V0RnJvbUF4aXNBbmdsZSh0MSwgTWF0aC5QSSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgYSA9IHUuY3Jvc3Modik7CiAgICAgICAgdGhpcy54ID0gYS54OwogICAgICAgIHRoaXMueSA9IGEueTsKICAgICAgICB0aGlzLnogPSBhLno7CiAgICAgICAgdGhpcy53ID0gTWF0aC5zcXJ0KHUubGVuZ3RoKCkgKiogMiAqIHYubGVuZ3RoKCkgKiogMikgKyB1LmRvdCh2KTsKICAgICAgICB0aGlzLm5vcm1hbGl6ZSgpOwogICAgICB9CgogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogTXVsdGlwbHkgdGhlIHF1YXRlcm5pb24gd2l0aCBhbiBvdGhlciBxdWF0ZXJuaW9uLgogICAgICovCgoKICAgIG11bHQocXVhdCwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IGF4ID0gdGhpcy54OwogICAgICBjb25zdCBheSA9IHRoaXMueTsKICAgICAgY29uc3QgYXogPSB0aGlzLno7CiAgICAgIGNvbnN0IGF3ID0gdGhpcy53OwogICAgICBjb25zdCBieCA9IHF1YXQueDsKICAgICAgY29uc3QgYnkgPSBxdWF0Lnk7CiAgICAgIGNvbnN0IGJ6ID0gcXVhdC56OwogICAgICBjb25zdCBidyA9IHF1YXQudzsKICAgICAgdGFyZ2V0LnggPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5OwogICAgICB0YXJnZXQueSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7CiAgICAgIHRhcmdldC56ID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDsKICAgICAgdGFyZ2V0LncgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGludmVyc2UgcXVhdGVybmlvbiByb3RhdGlvbi4KICAgICAqLwoKCiAgICBpbnZlcnNlKHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgUXVhdGVybmlvbigpOwogICAgICB9CgogICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICBjb25zdCB3ID0gdGhpcy53OwogICAgICB0aGlzLmNvbmp1Z2F0ZSh0YXJnZXQpOwogICAgICBjb25zdCBpbm9ybTIgPSAxIC8gKHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3KTsKICAgICAgdGFyZ2V0LnggKj0gaW5vcm0yOwogICAgICB0YXJnZXQueSAqPSBpbm9ybTI7CiAgICAgIHRhcmdldC56ICo9IGlub3JtMjsKICAgICAgdGFyZ2V0LncgKj0gaW5vcm0yOwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIHF1YXRlcm5pb24gY29uanVnYXRlCiAgICAgKi8KCgogICAgY29uanVnYXRlKHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgUXVhdGVybmlvbigpOwogICAgICB9CgogICAgICB0YXJnZXQueCA9IC10aGlzLng7CiAgICAgIHRhcmdldC55ID0gLXRoaXMueTsKICAgICAgdGFyZ2V0LnogPSAtdGhpcy56OwogICAgICB0YXJnZXQudyA9IHRoaXMudzsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIC8qKgogICAgICogTm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uLiBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIHF1YXRlcm5pb24uCiAgICAgKi8KCgogICAgbm9ybWFsaXplKCkgewogICAgICBsZXQgbCA9IE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncpOwoKICAgICAgaWYgKGwgPT09IDApIHsKICAgICAgICB0aGlzLnggPSAwOwogICAgICAgIHRoaXMueSA9IDA7CiAgICAgICAgdGhpcy56ID0gMDsKICAgICAgICB0aGlzLncgPSAwOwogICAgICB9IGVsc2UgewogICAgICAgIGwgPSAxIC8gbDsKICAgICAgICB0aGlzLnggKj0gbDsKICAgICAgICB0aGlzLnkgKj0gbDsKICAgICAgICB0aGlzLnogKj0gbDsKICAgICAgICB0aGlzLncgKj0gbDsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIEFwcHJveGltYXRpb24gb2YgcXVhdGVybmlvbiBub3JtYWxpemF0aW9uLiBXb3JrcyBiZXN0IHdoZW4gcXVhdCBpcyBhbHJlYWR5IGFsbW9zdC1ub3JtYWxpemVkLgogICAgICogQGF1dGhvciB1bnBoYXNlZCwgaHR0cHM6Ly9naXRodWIuY29tL3VucGhhc2VkCiAgICAgKi8KCgogICAgbm9ybWFsaXplRmFzdCgpIHsKICAgICAgY29uc3QgZiA9ICgzLjAgLSAodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53KSkgLyAyLjA7CgogICAgICBpZiAoZiA9PT0gMCkgewogICAgICAgIHRoaXMueCA9IDA7CiAgICAgICAgdGhpcy55ID0gMDsKICAgICAgICB0aGlzLnogPSAwOwogICAgICAgIHRoaXMudyA9IDA7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy54ICo9IGY7CiAgICAgICAgdGhpcy55ICo9IGY7CiAgICAgICAgdGhpcy56ICo9IGY7CiAgICAgICAgdGhpcy53ICo9IGY7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgLyoqCiAgICAgKiBNdWx0aXBseSB0aGUgcXVhdGVybmlvbiBieSBhIHZlY3RvcgogICAgICovCgoKICAgIHZtdWx0KHYsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBjb25zdCB4ID0gdi54OwogICAgICBjb25zdCB5ID0gdi55OwogICAgICBjb25zdCB6ID0gdi56OwogICAgICBjb25zdCBxeCA9IHRoaXMueDsKICAgICAgY29uc3QgcXkgPSB0aGlzLnk7CiAgICAgIGNvbnN0IHF6ID0gdGhpcy56OwogICAgICBjb25zdCBxdyA9IHRoaXMudzsgLy8gcSp2CgogICAgICBjb25zdCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTsKICAgICAgY29uc3QgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7CiAgICAgIGNvbnN0IGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4OwogICAgICBjb25zdCBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7CiAgICAgIHRhcmdldC54ID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTsKICAgICAgdGFyZ2V0LnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6OwogICAgICB0YXJnZXQueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7CiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CiAgICAvKioKICAgICAqIENvcGllcyB2YWx1ZSBvZiBzb3VyY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLgogICAgICogQHJldHVybiB0aGlzCiAgICAgKi8KCgogICAgY29weShxdWF0KSB7CiAgICAgIHRoaXMueCA9IHF1YXQueDsKICAgICAgdGhpcy55ID0gcXVhdC55OwogICAgICB0aGlzLnogPSBxdWF0Lno7CiAgICAgIHRoaXMudyA9IHF1YXQudzsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnQgdGhlIHF1YXRlcm5pb24gdG8gZXVsZXIgYW5nbGUgcmVwcmVzZW50YXRpb24uIE9yZGVyOiBZWlgsIGFzIHRoaXMgcGFnZSBkZXNjcmliZXM6IGh0dHBzOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9zdGFuZGFyZHMvaW5kZXguaHRtCiAgICAgKiBAcGFyYW0gb3JkZXIgVGhyZWUtY2hhcmFjdGVyIHN0cmluZywgZGVmYXVsdHMgdG8gIllaWCIKICAgICAqLwoKCiAgICB0b0V1bGVyKHRhcmdldCwgb3JkZXIpIHsKICAgICAgaWYgKG9yZGVyID09PSB2b2lkIDApIHsKICAgICAgICBvcmRlciA9ICdZWlgnOwogICAgICB9CgogICAgICBsZXQgaGVhZGluZzsKICAgICAgbGV0IGF0dGl0dWRlOwogICAgICBsZXQgYmFuazsKICAgICAgY29uc3QgeCA9IHRoaXMueDsKICAgICAgY29uc3QgeSA9IHRoaXMueTsKICAgICAgY29uc3QgeiA9IHRoaXMuejsKICAgICAgY29uc3QgdyA9IHRoaXMudzsKCiAgICAgIHN3aXRjaCAob3JkZXIpIHsKICAgICAgICBjYXNlICdZWlgnOgogICAgICAgICAgY29uc3QgdGVzdCA9IHggKiB5ICsgeiAqIHc7CgogICAgICAgICAgaWYgKHRlc3QgPiAwLjQ5OSkgewogICAgICAgICAgICAvLyBzaW5ndWxhcml0eSBhdCBub3J0aCBwb2xlCiAgICAgICAgICAgIGhlYWRpbmcgPSAyICogTWF0aC5hdGFuMih4LCB3KTsKICAgICAgICAgICAgYXR0aXR1ZGUgPSBNYXRoLlBJIC8gMjsKICAgICAgICAgICAgYmFuayA9IDA7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKHRlc3QgPCAtMC40OTkpIHsKICAgICAgICAgICAgLy8gc2luZ3VsYXJpdHkgYXQgc291dGggcG9sZQogICAgICAgICAgICBoZWFkaW5nID0gLTIgKiBNYXRoLmF0YW4yKHgsIHcpOwogICAgICAgICAgICBhdHRpdHVkZSA9IC1NYXRoLlBJIC8gMjsKICAgICAgICAgICAgYmFuayA9IDA7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGhlYWRpbmcgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICBjb25zdCBzcXggPSB4ICogeDsKICAgICAgICAgICAgY29uc3Qgc3F5ID0geSAqIHk7CiAgICAgICAgICAgIGNvbnN0IHNxeiA9IHogKiB6OwogICAgICAgICAgICBoZWFkaW5nID0gTWF0aC5hdGFuMigyICogeSAqIHcgLSAyICogeCAqIHosIDEgLSAyICogc3F5IC0gMiAqIHNxeik7IC8vIEhlYWRpbmcKCiAgICAgICAgICAgIGF0dGl0dWRlID0gTWF0aC5hc2luKDIgKiB0ZXN0KTsgLy8gYXR0aXR1ZGUKCiAgICAgICAgICAgIGJhbmsgPSBNYXRoLmF0YW4yKDIgKiB4ICogdyAtIDIgKiB5ICogeiwgMSAtIDIgKiBzcXggLSAyICogc3F6KTsgLy8gYmFuawogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFdWxlciBvcmRlciAke29yZGVyfSBub3Qgc3VwcG9ydGVkIHlldC5gKTsKICAgICAgfQoKICAgICAgdGFyZ2V0LnkgPSBoZWFkaW5nOwogICAgICB0YXJnZXQueiA9IGF0dGl0dWRlOwogICAgICB0YXJnZXQueCA9IGJhbms7CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgcXVhdGVybmlvbiBjb21wb25lbnRzIGdpdmVuIEV1bGVyIGFuZ2xlIHJlcHJlc2VudGF0aW9uLgogICAgICoKICAgICAqIEBwYXJhbSBvcmRlciBUaGUgb3JkZXIgdG8gYXBwbHkgYW5nbGVzOiAnWFlaJyBvciAnWVhaJyBvciBhbnkgb3RoZXIgY29tYmluYXRpb24uCiAgICAgKgogICAgICogU2VlIHtAbGluayBodHRwczovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlLzIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzIE1hdGhXb3Jrc30gcmVmZXJlbmNlCiAgICAgKi8KCgogICAgc2V0RnJvbUV1bGVyKHgsIHksIHosIG9yZGVyKSB7CiAgICAgIGlmIChvcmRlciA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3JkZXIgPSAnWFlaJzsKICAgICAgfQoKICAgICAgY29uc3QgYzEgPSBNYXRoLmNvcyh4IC8gMik7CiAgICAgIGNvbnN0IGMyID0gTWF0aC5jb3MoeSAvIDIpOwogICAgICBjb25zdCBjMyA9IE1hdGguY29zKHogLyAyKTsKICAgICAgY29uc3QgczEgPSBNYXRoLnNpbih4IC8gMik7CiAgICAgIGNvbnN0IHMyID0gTWF0aC5zaW4oeSAvIDIpOwogICAgICBjb25zdCBzMyA9IE1hdGguc2luKHogLyAyKTsKCiAgICAgIGlmIChvcmRlciA9PT0gJ1hZWicpIHsKICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7CiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzOwogICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMzsKICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7CiAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWFonKSB7CiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzOwogICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMzsKICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7CiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzOwogICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWlhZJykgewogICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMzsKICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7CiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzOwogICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMzsKICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pZWCcpIHsKICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7CiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzOwogICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMzsKICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7CiAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWlgnKSB7CiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzOwogICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMzsKICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7CiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzOwogICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWFpZJykgewogICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMzsKICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7CiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzOwogICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMzsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CgogICAgY2xvbmUoKSB7CiAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbih0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpOwogICAgfQogICAgLyoqCiAgICAgKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0CiAgICAgKgogICAgICogQHBhcmFtIHRvUXVhdCBzZWNvbmQgb3BlcmFuZAogICAgICogQHBhcmFtIHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgc2VsZiBxdWF0ZXJuaW9uIGFuZCB0b1F1YXQKICAgICAqIEBwYXJhbSB0YXJnZXQgQSBxdWF0ZXJuaW9uIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uIElmIG5vdCBwcm92aWRlZCwgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZC4KICAgICAqIEByZXR1cm5zIHtRdWF0ZXJuaW9ufSBUaGUgInRhcmdldCIgb2JqZWN0CiAgICAgKi8KCgogICAgc2xlcnAodG9RdWF0LCB0LCB0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFF1YXRlcm5pb24oKTsKICAgICAgfQoKICAgICAgY29uc3QgYXggPSB0aGlzLng7CiAgICAgIGNvbnN0IGF5ID0gdGhpcy55OwogICAgICBjb25zdCBheiA9IHRoaXMuejsKICAgICAgY29uc3QgYXcgPSB0aGlzLnc7CiAgICAgIGxldCBieCA9IHRvUXVhdC54OwogICAgICBsZXQgYnkgPSB0b1F1YXQueTsKICAgICAgbGV0IGJ6ID0gdG9RdWF0Lno7CiAgICAgIGxldCBidyA9IHRvUXVhdC53OwogICAgICBsZXQgb21lZ2E7CiAgICAgIGxldCBjb3NvbTsKICAgICAgbGV0IHNpbm9tOwogICAgICBsZXQgc2NhbGUwOwogICAgICBsZXQgc2NhbGUxOyAvLyBjYWxjIGNvc2luZQoKICAgICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3OyAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSkKCiAgICAgIGlmIChjb3NvbSA8IDAuMCkgewogICAgICAgIGNvc29tID0gLWNvc29tOwogICAgICAgIGJ4ID0gLWJ4OwogICAgICAgIGJ5ID0gLWJ5OwogICAgICAgIGJ6ID0gLWJ6OwogICAgICAgIGJ3ID0gLWJ3OwogICAgICB9IC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHMKCgogICAgICBpZiAoMS4wIC0gY29zb20gPiAwLjAwMDAwMSkgewogICAgICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKQogICAgICAgIG9tZWdhID0gTWF0aC5hY29zKGNvc29tKTsKICAgICAgICBzaW5vbSA9IE1hdGguc2luKG9tZWdhKTsKICAgICAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTsKICAgICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gImZyb20iIGFuZCAidG8iIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlCiAgICAgICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbgogICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7CiAgICAgICAgc2NhbGUxID0gdDsKICAgICAgfSAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzCgoKICAgICAgdGFyZ2V0LnggPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4OwogICAgICB0YXJnZXQueSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7CiAgICAgIHRhcmdldC56ID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejsKICAgICAgdGFyZ2V0LncgPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3OwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqCiAgICAgKiBSb3RhdGUgYW4gYWJzb2x1dGUgb3JpZW50YXRpb24gcXVhdGVybmlvbiBnaXZlbiBhbiBhbmd1bGFyIHZlbG9jaXR5IGFuZCBhIHRpbWUgc3RlcC4KICAgICAqLwoKCiAgICBpbnRlZ3JhdGUoYW5ndWxhclZlbG9jaXR5LCBkdCwgYW5ndWxhckZhY3RvciwgdGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IGF4ID0gYW5ndWxhclZlbG9jaXR5LnggKiBhbmd1bGFyRmFjdG9yLngsCiAgICAgICAgICAgIGF5ID0gYW5ndWxhclZlbG9jaXR5LnkgKiBhbmd1bGFyRmFjdG9yLnksCiAgICAgICAgICAgIGF6ID0gYW5ndWxhclZlbG9jaXR5LnogKiBhbmd1bGFyRmFjdG9yLnosCiAgICAgICAgICAgIGJ4ID0gdGhpcy54LAogICAgICAgICAgICBieSA9IHRoaXMueSwKICAgICAgICAgICAgYnogPSB0aGlzLnosCiAgICAgICAgICAgIGJ3ID0gdGhpcy53OwogICAgICBjb25zdCBoYWxmX2R0ID0gZHQgKiAwLjU7CiAgICAgIHRhcmdldC54ICs9IGhhbGZfZHQgKiAoYXggKiBidyArIGF5ICogYnogLSBheiAqIGJ5KTsKICAgICAgdGFyZ2V0LnkgKz0gaGFsZl9kdCAqIChheSAqIGJ3ICsgYXogKiBieCAtIGF4ICogYnopOwogICAgICB0YXJnZXQueiArPSBoYWxmX2R0ICogKGF6ICogYncgKyBheCAqIGJ5IC0gYXkgKiBieCk7CiAgICAgIHRhcmdldC53ICs9IGhhbGZfZHQgKiAoLWF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBieik7CiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CgogIH0KICBjb25zdCBzZnZfdDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNmdl90MiA9IG5ldyBWZWMzKCk7CgogIC8qKgogICAqIFRoZSBhdmFpbGFibGUgc2hhcGUgdHlwZXMuCiAgICovCiAgY29uc3QgU0hBUEVfVFlQRVMgPSB7CiAgICAvKiogU1BIRVJFICovCiAgICBTUEhFUkU6IDEsCgogICAgLyoqIFBMQU5FICovCiAgICBQTEFORTogMiwKCiAgICAvKiogQk9YICovCiAgICBCT1g6IDQsCgogICAgLyoqIENPTVBPVU5EICovCiAgICBDT01QT1VORDogOCwKCiAgICAvKiogQ09OVkVYUE9MWUhFRFJPTiAqLwogICAgQ09OVkVYUE9MWUhFRFJPTjogMTYsCgogICAgLyoqIEhFSUdIVEZJRUxEICovCiAgICBIRUlHSFRGSUVMRDogMzIsCgogICAgLyoqIFBBUlRJQ0xFICovCiAgICBQQVJUSUNMRTogNjQsCgogICAgLyoqIENZTElOREVSICovCiAgICBDWUxJTkRFUjogMTI4LAoKICAgIC8qKiBUUklNRVNIICovCiAgICBUUklNRVNIOiAyNTYKICB9OwogIC8qKgogICAqIFNoYXBlVHlwZQogICAqLwoKICAvKioKICAgKiBCYXNlIGNsYXNzIGZvciBzaGFwZXMKICAgKi8KICBjbGFzcyBTaGFwZSB7CiAgICAvKioKICAgICAqIElkZW50aWZpZXIgb2YgdGhlIFNoYXBlLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIHNoYXBlLiBNdXN0IGJlIHNldCB0byBhbiBpbnQgPiAwIGJ5IHN1YmNsYXNzZXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBsb2NhbCBib3VuZGluZyBzcGhlcmUgcmFkaXVzIG9mIHRoaXMgc2hhcGUuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC4KICAgICAqIEBkZWZhdWx0IHRydWUKICAgICAqLwoKICAgIC8qKgogICAgICogQGRlZmF1bHQgMQogICAgICovCgogICAgLyoqCiAgICAgKiBAZGVmYXVsdCAtMQogICAgICovCgogICAgLyoqCiAgICAgKiBPcHRpb25hbCBtYXRlcmlhbCBvZiB0aGUgc2hhcGUgdGhhdCByZWd1bGF0ZXMgY29udGFjdCBwcm9wZXJ0aWVzLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGUgYm9keSB0byB3aGljaCB0aGUgc2hhcGUgaXMgYWRkZWQgdG8uCiAgICAgKi8KCiAgICAvKioKICAgICAqIEFsbCB0aGUgU2hhcGUgdHlwZXMuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgdGhpcy5pZCA9IFNoYXBlLmlkQ291bnRlcisrOwogICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGUgfHwgMDsKICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IDA7CiAgICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlID8gb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZSA6IHRydWU7CiAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogMTsKICAgICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2sgOiAtMTsKICAgICAgdGhpcy5tYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWwgPyBvcHRpb25zLm1hdGVyaWFsIDogbnVsbDsKICAgICAgdGhpcy5ib2R5ID0gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZXMgdGhlIGJvdW5kaW5nIHNwaGVyZSByYWRpdXMuCiAgICAgKiBUaGUgcmVzdWx0IGlzIHN0b3JlZCBpbiB0aGUgcHJvcGVydHkgYC5ib3VuZGluZ1NwaGVyZVJhZGl1c2AKICAgICAqLwoKCiAgICB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIHsKICAgICAgdGhyb3cgYGNvbXB1dGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSAke3RoaXMudHlwZX1gOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIHZvbHVtZSBvZiB0aGlzIHNoYXBlCiAgICAgKi8KCgogICAgdm9sdW1lKCkgewogICAgICB0aHJvdyBgdm9sdW1lKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlICR7dGhpcy50eXBlfWA7CiAgICB9CiAgICAvKioKICAgICAqIENhbGN1bGF0ZXMgdGhlIGluZXJ0aWEgaW4gdGhlIGxvY2FsIGZyYW1lIGZvciB0aGlzIHNoYXBlLgogICAgICogQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfbW9tZW50c19vZl9pbmVydGlhCiAgICAgKi8KCgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICB0aHJvdyBgY2FsY3VsYXRlTG9jYWxJbmVydGlhKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlICR7dGhpcy50eXBlfWA7CiAgICB9CiAgICAvKioKICAgICAqIEB0b2RvIHVzZSBhYnN0cmFjdCBmb3IgdGhlc2Uga2luZCBvZiBtZXRob2RzCiAgICAgKi8KCgogICAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHsKICAgICAgdGhyb3cgYGNhbGN1bGF0ZVdvcmxkQUFCQigpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSAke3RoaXMudHlwZX1gOwogICAgfQoKICB9CiAgU2hhcGUuaWRDb3VudGVyID0gMDsKICBTaGFwZS50eXBlcyA9IFNIQVBFX1RZUEVTOwoKICAvKioKICAgKiBUcmFuc2Zvcm1hdGlvbiB1dGlsaXRpZXMuCiAgICovCiAgY2xhc3MgVHJhbnNmb3JtIHsKICAgIC8qKgogICAgICogcG9zaXRpb24KICAgICAqLwoKICAgIC8qKgogICAgICogcXVhdGVybmlvbgogICAgICovCiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpOwoKICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24pIHsKICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkob3B0aW9ucy5wb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLnF1YXRlcm5pb24pIHsKICAgICAgICB0aGlzLnF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhIGdsb2JhbCBwb2ludCBpbiBsb2NhbCB0cmFuc2Zvcm0gY29vcmRpbmF0ZXMuCiAgICAgKi8KCgogICAgcG9pbnRUb0xvY2FsKHdvcmxkUG9pbnQsIHJlc3VsdCkgewogICAgICByZXR1cm4gVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgd29ybGRQb2ludCwgcmVzdWx0KTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGEgbG9jYWwgcG9pbnQgaW4gZ2xvYmFsIHRyYW5zZm9ybSBjb29yZGluYXRlcy4KICAgICAqLwoKCiAgICBwb2ludFRvV29ybGQobG9jYWxQb2ludCwgcmVzdWx0KSB7CiAgICAgIHJldHVybiBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCBsb2NhbFBvaW50LCByZXN1bHQpOwogICAgfQogICAgLyoqCiAgICAgKiB2ZWN0b3JUb1dvcmxkRnJhbWUKICAgICAqLwoKCiAgICB2ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxWZWN0b3IsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxWZWN0b3IsIHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIHBvaW50VG9Mb2NhbEZyYW1lCiAgICAgKi8KCgogICAgc3RhdGljIHBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCB3b3JsZFBvaW50LCByZXN1bHQpIHsKICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgcmVzdWx0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgd29ybGRQb2ludC52c3ViKHBvc2l0aW9uLCByZXN1bHQpOwogICAgICBxdWF0ZXJuaW9uLmNvbmp1Z2F0ZSh0bXBRdWF0JDEpOwogICAgICB0bXBRdWF0JDEudm11bHQocmVzdWx0LCByZXN1bHQpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBwb2ludFRvV29ybGRGcmFtZQogICAgICovCgoKICAgIHN0YXRpYyBwb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdGVybmlvbiwgbG9jYWxQb2ludCwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHF1YXRlcm5pb24udm11bHQobG9jYWxQb2ludCwgcmVzdWx0KTsKICAgICAgcmVzdWx0LnZhZGQocG9zaXRpb24sIHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIHZlY3RvclRvV29ybGRGcmFtZQogICAgICovCgoKICAgIHN0YXRpYyB2ZWN0b3JUb1dvcmxkRnJhbWUocXVhdGVybmlvbiwgbG9jYWxWZWN0b3IsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBxdWF0ZXJuaW9uLnZtdWx0KGxvY2FsVmVjdG9yLCByZXN1bHQpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiB2ZWN0b3JUb0xvY2FsRnJhbWUKICAgICAqLwoKCiAgICBzdGF0aWMgdmVjdG9yVG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCB3b3JsZFZlY3RvciwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHF1YXRlcm5pb24udyAqPSAtMTsKICAgICAgcXVhdGVybmlvbi52bXVsdCh3b3JsZFZlY3RvciwgcmVzdWx0KTsKICAgICAgcXVhdGVybmlvbi53ICo9IC0xOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQoKICB9CiAgY29uc3QgdG1wUXVhdCQxID0gbmV3IFF1YXRlcm5pb24oKTsKCiAgLyoqCiAgICogQSBzZXQgb2YgcG9seWdvbnMgZGVzY3JpYmluZyBhIGNvbnZleCBzaGFwZS4KICAgKgogICAqIFRoZSBzaGFwZSBNVVNUIGJlIGNvbnZleCBmb3IgdGhlIGNvZGUgdG8gd29yayBwcm9wZXJseS4gTm8gcG9seWdvbnMgbWF5IGJlIGNvcGxhbmFyIChjb250YWluZWQKICAgKiBpbiB0aGUgc2FtZSAzRCBwbGFuZSksIGluc3RlYWQgdGhlc2Ugc2hvdWxkIGJlIG1lcmdlZCBpbnRvIG9uZSBwb2x5Z29uLgogICAqCiAgICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW8gKG9yaWdpbmFsIGF1dGhvciwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvL3RocmVlLmpzL2NvbW1pdC84NTAyNmYwYzc2OWU0MDAwMTQ4YTY3ZDQ1YTllOWI5YzUxMDg4MzZmKQogICAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUKICAgKiBAc2VlIGh0dHBzOi8vd3d3LmFsdGRldmJsb2dhZGF5LmNvbS8yMDExLzA1LzEzL2NvbnRhY3QtZ2VuZXJhdGlvbi1iZXR3ZWVuLTNkLWNvbnZleC1tZXNoZXMvCiAgICoKICAgKiBAdG9kbyBNb3ZlIHRoZSBjbGlwcGluZyBmdW5jdGlvbnMgdG8gQ29udGFjdEdlbmVyYXRvcj8KICAgKiBAdG9kbyBBdXRvbWF0aWNhbGx5IG1lcmdlIGNvcGxhbmFyIHBvbHlnb25zIGluIGNvbnN0cnVjdG9yLgogICAqIEBleGFtcGxlCiAgICogICAgIGNvbnN0IGNvbnZleFNoYXBlID0gbmV3IENBTk5PTi5Db252ZXhQb2x5aGVkcm9uKHsgdmVydGljZXMsIGZhY2VzIH0pCiAgICogICAgIGNvbnN0IGNvbnZleEJvZHkgPSBuZXcgQ0FOTk9OLkJvZHkoeyBtYXNzOiAxLCBzaGFwZTogY29udmV4U2hhcGUgfSkKICAgKiAgICAgd29ybGQuYWRkQm9keShjb252ZXhCb2R5KQogICAqLwogIGNsYXNzIENvbnZleFBvbHloZWRyb24gZXh0ZW5kcyBTaGFwZSB7CiAgICAvKiogdmVydGljZXMgKi8KCiAgICAvKioKICAgICAqIEFycmF5IG9mIGludGVnZXIgYXJyYXlzLCBpbmRpY2F0aW5nIHdoaWNoIHZlcnRpY2VzIGVhY2ggZmFjZSBjb25zaXN0cyBvZgogICAgICovCgogICAgLyoqIGZhY2VOb3JtYWxzICovCgogICAgLyoqIHdvcmxkVmVydGljZXMgKi8KCiAgICAvKiogd29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlICovCgogICAgLyoqIHdvcmxkRmFjZU5vcm1hbHMgKi8KCiAgICAvKiogd29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlICovCgogICAgLyoqCiAgICAgKiBJZiBnaXZlbiwgdGhlc2UgbG9jYWxseSBkZWZpbmVkLCBub3JtYWxpemVkIGF4ZXMgYXJlIHRoZSBvbmx5IG9uZXMgYmVpbmcgY2hlY2tlZCB3aGVuIGRvaW5nIHNlcGFyYXRpbmcgYXhpcyBjaGVjay4KICAgICAqLwoKICAgIC8qKiB1bmlxdWVFZGdlcyAqLwoKICAgIC8qKgogICAgICogQHBhcmFtIHZlcnRpY2VzIEFuIGFycmF5IG9mIFZlYzMncwogICAgICogQHBhcmFtIGZhY2VzIEFycmF5IG9mIGludGVnZXIgYXJyYXlzLCBkZXNjcmliaW5nIHdoaWNoIHZlcnRpY2VzIHRoYXQgaXMgaW5jbHVkZWQgaW4gZWFjaCBmYWNlLgogICAgICovCiAgICBjb25zdHJ1Y3Rvcihwcm9wcykgewogICAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkgewogICAgICAgIHByb3BzID0ge307CiAgICAgIH0KCiAgICAgIGNvbnN0IHsKICAgICAgICB2ZXJ0aWNlcyA9IFtdLAogICAgICAgIGZhY2VzID0gW10sCiAgICAgICAgbm9ybWFscyA9IFtdLAogICAgICAgIGF4ZXMsCiAgICAgICAgYm91bmRpbmdTcGhlcmVSYWRpdXMKICAgICAgfSA9IHByb3BzOwogICAgICBzdXBlcih7CiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTgogICAgICB9KTsKICAgICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzOwogICAgICB0aGlzLmZhY2VzID0gZmFjZXM7CiAgICAgIHRoaXMuZmFjZU5vcm1hbHMgPSBub3JtYWxzOwoKICAgICAgaWYgKHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgdGhpcy5jb21wdXRlTm9ybWFscygpOwogICAgICB9CgogICAgICBpZiAoIWJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBib3VuZGluZ1NwaGVyZVJhZGl1czsKICAgICAgfQoKICAgICAgdGhpcy53b3JsZFZlcnRpY2VzID0gW107IC8vIFdvcmxkIHRyYW5zZm9ybWVkIHZlcnNpb24gb2YgLnZlcnRpY2VzCgogICAgICB0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSA9IHRydWU7CiAgICAgIHRoaXMud29ybGRGYWNlTm9ybWFscyA9IFtdOyAvLyBXb3JsZCB0cmFuc2Zvcm1lZCB2ZXJzaW9uIG9mIC5mYWNlTm9ybWFscwoKICAgICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzTmVlZHNVcGRhdGUgPSB0cnVlOwogICAgICB0aGlzLnVuaXF1ZUF4ZXMgPSBheGVzID8gYXhlcy5zbGljZSgpIDogbnVsbDsKICAgICAgdGhpcy51bmlxdWVFZGdlcyA9IFtdOwogICAgICB0aGlzLmNvbXB1dGVFZGdlcygpOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyB1bmlxdWVFZGdlcwogICAgICovCgoKICAgIGNvbXB1dGVFZGdlcygpIHsKICAgICAgY29uc3QgZmFjZXMgPSB0aGlzLmZhY2VzOwogICAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7CiAgICAgIGNvbnN0IGVkZ2VzID0gdGhpcy51bmlxdWVFZGdlczsKICAgICAgZWRnZXMubGVuZ3RoID0gMDsKICAgICAgY29uc3QgZWRnZSA9IG5ldyBWZWMzKCk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gZmFjZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBmYWNlID0gZmFjZXNbaV07CiAgICAgICAgY29uc3QgbnVtVmVydGljZXMgPSBmYWNlLmxlbmd0aDsKCiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogIT09IG51bVZlcnRpY2VzOyBqKyspIHsKICAgICAgICAgIGNvbnN0IGsgPSAoaiArIDEpICUgbnVtVmVydGljZXM7CiAgICAgICAgICB2ZXJ0aWNlc1tmYWNlW2pdXS52c3ViKHZlcnRpY2VzW2ZhY2Vba11dLCBlZGdlKTsKICAgICAgICAgIGVkZ2Uubm9ybWFsaXplKCk7CiAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTsKCiAgICAgICAgICBmb3IgKGxldCBwID0gMDsgcCAhPT0gZWRnZXMubGVuZ3RoOyBwKyspIHsKICAgICAgICAgICAgaWYgKGVkZ2VzW3BdLmFsbW9zdEVxdWFscyhlZGdlKSB8fCBlZGdlc1twXS5hbG1vc3RFcXVhbHMoZWRnZSkpIHsKICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoIWZvdW5kKSB7CiAgICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZS5jbG9uZSgpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZSB0aGUgbm9ybWFscyBvZiB0aGUgZmFjZXMuCiAgICAgKiBXaWxsIHJldXNlIGV4aXN0aW5nIFZlYzMgb2JqZWN0cyBpbiB0aGUgYGZhY2VOb3JtYWxzYCBhcnJheSBpZiB0aGV5IGV4aXN0LgogICAgICovCgoKICAgIGNvbXB1dGVOb3JtYWxzKCkgewogICAgICB0aGlzLmZhY2VOb3JtYWxzLmxlbmd0aCA9IHRoaXMuZmFjZXMubGVuZ3RoOyAvLyBHZW5lcmF0ZSBub3JtYWxzCgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAvLyBDaGVjayBzbyBhbGwgdmVydGljZXMgZXhpc3RzIGZvciB0aGlzIGZhY2UKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuZmFjZXNbaV0ubGVuZ3RoOyBqKyspIHsKICAgICAgICAgIGlmICghdGhpcy52ZXJ0aWNlc1t0aGlzLmZhY2VzW2ldW2pdXSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnRleCAke3RoaXMuZmFjZXNbaV1bal19IG5vdCBmb3VuZCFgKTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGNvbnN0IG4gPSB0aGlzLmZhY2VOb3JtYWxzW2ldIHx8IG5ldyBWZWMzKCk7CiAgICAgICAgdGhpcy5nZXRGYWNlTm9ybWFsKGksIG4pOwogICAgICAgIG4ubmVnYXRlKG4pOwogICAgICAgIHRoaXMuZmFjZU5vcm1hbHNbaV0gPSBuOwogICAgICAgIGNvbnN0IHZlcnRleCA9IHRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVswXV07CgogICAgICAgIGlmIChuLmRvdCh2ZXJ0ZXgpIDwgMCkgewogICAgICAgICAgY29uc29sZS5lcnJvcihgLmZhY2VOb3JtYWxzWyR7aX1dID0gVmVjMygke24udG9TdHJpbmcoKX0pIGxvb2tzIGxpa2UgaXQgcG9pbnRzIGludG8gdGhlIHNoYXBlPyBUaGUgdmVydGljZXMgZm9sbG93LiBNYWtlIHN1cmUgdGhleSBhcmUgb3JkZXJlZCBDQ1cgYXJvdW5kIHRoZSBub3JtYWwsIHVzaW5nIHRoZSByaWdodCBoYW5kIHJ1bGUuYCk7CgogICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmZhY2VzW2ldLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICAgIGNvbnNvbGUud2FybihgLnZlcnRpY2VzWyR7dGhpcy5mYWNlc1tpXVtqXX1dID0gVmVjMygke3RoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVtqXV0udG9TdHJpbmcoKX0pYCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGUgdGhlIG5vcm1hbCBvZiBhIGZhY2UgZnJvbSBpdHMgdmVydGljZXMKICAgICAqLwoKCiAgICBnZXRGYWNlTm9ybWFsKGksIHRhcmdldCkgewogICAgICBjb25zdCBmID0gdGhpcy5mYWNlc1tpXTsKICAgICAgY29uc3QgdmEgPSB0aGlzLnZlcnRpY2VzW2ZbMF1dOwogICAgICBjb25zdCB2YiA9IHRoaXMudmVydGljZXNbZlsxXV07CiAgICAgIGNvbnN0IHZjID0gdGhpcy52ZXJ0aWNlc1tmWzJdXTsKICAgICAgQ29udmV4UG9seWhlZHJvbi5jb21wdXRlTm9ybWFsKHZhLCB2YiwgdmMsIHRhcmdldCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBmYWNlIG5vcm1hbCBnaXZlbiAzIHZlcnRpY2VzCiAgICAgKi8KCgogICAgc3RhdGljIGNvbXB1dGVOb3JtYWwodmEsIHZiLCB2YywgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IGNiID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgYWIgPSBuZXcgVmVjMygpOwogICAgICB2Yi52c3ViKHZhLCBhYik7CiAgICAgIHZjLnZzdWIodmIsIGNiKTsKICAgICAgY2IuY3Jvc3MoYWIsIHRhcmdldCk7CgogICAgICBpZiAoIXRhcmdldC5pc1plcm8oKSkgewogICAgICAgIHRhcmdldC5ub3JtYWxpemUoKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBAcGFyYW0gbWluRGlzdCBDbGFtcCBkaXN0YW5jZQogICAgICogQHBhcmFtIHJlc3VsdCBUaGUgYW4gYXJyYXkgb2YgY29udGFjdCBwb2ludCBvYmplY3RzLCBzZWUgY2xpcEZhY2VBZ2FpbnN0SHVsbAogICAgICovCgoKICAgIGNsaXBBZ2FpbnN0SHVsbChwb3NBLCBxdWF0QSwgaHVsbEIsIHBvc0IsIHF1YXRCLCBzZXBhcmF0aW5nTm9ybWFsLCBtaW5EaXN0LCBtYXhEaXN0LCByZXN1bHQpIHsKICAgICAgY29uc3QgV29ybGROb3JtYWwgPSBuZXcgVmVjMygpOwogICAgICBsZXQgY2xvc2VzdEZhY2VCID0gLTE7CiAgICAgIGxldCBkbWF4ID0gLU51bWJlci5NQVhfVkFMVUU7CgogICAgICBmb3IgKGxldCBmYWNlID0gMDsgZmFjZSA8IGh1bGxCLmZhY2VzLmxlbmd0aDsgZmFjZSsrKSB7CiAgICAgICAgV29ybGROb3JtYWwuY29weShodWxsQi5mYWNlTm9ybWFsc1tmYWNlXSk7CiAgICAgICAgcXVhdEIudm11bHQoV29ybGROb3JtYWwsIFdvcmxkTm9ybWFsKTsKICAgICAgICBjb25zdCBkID0gV29ybGROb3JtYWwuZG90KHNlcGFyYXRpbmdOb3JtYWwpOwoKICAgICAgICBpZiAoZCA+IGRtYXgpIHsKICAgICAgICAgIGRtYXggPSBkOwogICAgICAgICAgY2xvc2VzdEZhY2VCID0gZmFjZTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGNvbnN0IHdvcmxkVmVydHNCMSA9IFtdOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBodWxsQi5mYWNlc1tjbG9zZXN0RmFjZUJdLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgYiA9IGh1bGxCLnZlcnRpY2VzW2h1bGxCLmZhY2VzW2Nsb3Nlc3RGYWNlQl1baV1dOwogICAgICAgIGNvbnN0IHdvcmxkYiA9IG5ldyBWZWMzKCk7CiAgICAgICAgd29ybGRiLmNvcHkoYik7CiAgICAgICAgcXVhdEIudm11bHQod29ybGRiLCB3b3JsZGIpOwogICAgICAgIHBvc0IudmFkZCh3b3JsZGIsIHdvcmxkYik7CiAgICAgICAgd29ybGRWZXJ0c0IxLnB1c2god29ybGRiKTsKICAgICAgfQoKICAgICAgaWYgKGNsb3Nlc3RGYWNlQiA+PSAwKSB7CiAgICAgICAgdGhpcy5jbGlwRmFjZUFnYWluc3RIdWxsKHNlcGFyYXRpbmdOb3JtYWwsIHBvc0EsIHF1YXRBLCB3b3JsZFZlcnRzQjEsIG1pbkRpc3QsIG1heERpc3QsIHJlc3VsdCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogRmluZCB0aGUgc2VwYXJhdGluZyBheGlzIGJldHdlZW4gdGhpcyBodWxsIGFuZCBhbm90aGVyCiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgdmVjdG9yIHRvIHNhdmUgdGhlIGF4aXMgaW4KICAgICAqIEByZXR1cm4gUmV0dXJucyBmYWxzZSBpZiBhIHNlcGFyYXRpb24gaXMgZm91bmQsIGVsc2UgdHJ1ZQogICAgICovCgoKICAgIGZpbmRTZXBhcmF0aW5nQXhpcyhodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCLCB0YXJnZXQsIGZhY2VMaXN0QSwgZmFjZUxpc3RCKSB7CiAgICAgIGNvbnN0IGZhY2VBTm9ybWFsV1MzID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgV29ybGRub3JtYWwxID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgZGVsdGFDID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3Qgd29ybGRFZGdlMCA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHdvcmxkRWRnZTEgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBDcm9zcyA9IG5ldyBWZWMzKCk7CiAgICAgIGxldCBkbWluID0gTnVtYmVyLk1BWF9WQUxVRTsKICAgICAgY29uc3QgaHVsbEEgPSB0aGlzOwoKICAgICAgaWYgKCFodWxsQS51bmlxdWVBeGVzKSB7CiAgICAgICAgY29uc3QgbnVtRmFjZXNBID0gZmFjZUxpc3RBID8gZmFjZUxpc3RBLmxlbmd0aCA6IGh1bGxBLmZhY2VzLmxlbmd0aDsgLy8gVGVzdCBmYWNlIG5vcm1hbHMgZnJvbSBodWxsQQoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUZhY2VzQTsgaSsrKSB7CiAgICAgICAgICBjb25zdCBmaSA9IGZhY2VMaXN0QSA/IGZhY2VMaXN0QVtpXSA6IGk7IC8vIEdldCB3b3JsZCBmYWNlIG5vcm1hbAoKICAgICAgICAgIGZhY2VBTm9ybWFsV1MzLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmldKTsKICAgICAgICAgIHF1YXRBLnZtdWx0KGZhY2VBTm9ybWFsV1MzLCBmYWNlQU5vcm1hbFdTMyk7CiAgICAgICAgICBjb25zdCBkID0gaHVsbEEudGVzdFNlcEF4aXMoZmFjZUFOb3JtYWxXUzMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpOwoKICAgICAgICAgIGlmIChkID09PSBmYWxzZSkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGQgPCBkbWluKSB7CiAgICAgICAgICAgIGRtaW4gPSBkOwogICAgICAgICAgICB0YXJnZXQuY29weShmYWNlQU5vcm1hbFdTMyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vIFRlc3QgdW5pcXVlIGF4ZXMKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gaHVsbEEudW5pcXVlQXhlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgLy8gR2V0IHdvcmxkIGF4aXMKICAgICAgICAgIHF1YXRBLnZtdWx0KGh1bGxBLnVuaXF1ZUF4ZXNbaV0sIGZhY2VBTm9ybWFsV1MzKTsKICAgICAgICAgIGNvbnN0IGQgPSBodWxsQS50ZXN0U2VwQXhpcyhmYWNlQU5vcm1hbFdTMywgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7CgogICAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoZCA8IGRtaW4pIHsKICAgICAgICAgICAgZG1pbiA9IGQ7CiAgICAgICAgICAgIHRhcmdldC5jb3B5KGZhY2VBTm9ybWFsV1MzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICghaHVsbEIudW5pcXVlQXhlcykgewogICAgICAgIC8vIFRlc3QgZmFjZSBub3JtYWxzIGZyb20gaHVsbEIKICAgICAgICBjb25zdCBudW1GYWNlc0IgPSBmYWNlTGlzdEIgPyBmYWNlTGlzdEIubGVuZ3RoIDogaHVsbEIuZmFjZXMubGVuZ3RoOwoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUZhY2VzQjsgaSsrKSB7CiAgICAgICAgICBjb25zdCBmaSA9IGZhY2VMaXN0QiA/IGZhY2VMaXN0QltpXSA6IGk7CiAgICAgICAgICBXb3JsZG5vcm1hbDEuY29weShodWxsQi5mYWNlTm9ybWFsc1tmaV0pOwogICAgICAgICAgcXVhdEIudm11bHQoV29ybGRub3JtYWwxLCBXb3JsZG5vcm1hbDEpOwogICAgICAgICAgY29uc3QgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKFdvcmxkbm9ybWFsMSwgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7CgogICAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoZCA8IGRtaW4pIHsKICAgICAgICAgICAgZG1pbiA9IGQ7CiAgICAgICAgICAgIHRhcmdldC5jb3B5KFdvcmxkbm9ybWFsMSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vIFRlc3QgdW5pcXVlIGF4ZXMgaW4gQgogICAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBodWxsQi51bmlxdWVBeGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBxdWF0Qi52bXVsdChodWxsQi51bmlxdWVBeGVzW2ldLCBXb3JsZG5vcm1hbDEpOwogICAgICAgICAgY29uc3QgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKFdvcmxkbm9ybWFsMSwgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7CgogICAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoZCA8IGRtaW4pIHsKICAgICAgICAgICAgZG1pbiA9IGQ7CiAgICAgICAgICAgIHRhcmdldC5jb3B5KFdvcmxkbm9ybWFsMSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIFRlc3QgZWRnZXMKCgogICAgICBmb3IgKGxldCBlMCA9IDA7IGUwICE9PSBodWxsQS51bmlxdWVFZGdlcy5sZW5ndGg7IGUwKyspIHsKICAgICAgICAvLyBHZXQgd29ybGQgZWRnZQogICAgICAgIHF1YXRBLnZtdWx0KGh1bGxBLnVuaXF1ZUVkZ2VzW2UwXSwgd29ybGRFZGdlMCk7CgogICAgICAgIGZvciAobGV0IGUxID0gMDsgZTEgIT09IGh1bGxCLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgZTErKykgewogICAgICAgICAgLy8gR2V0IHdvcmxkIGVkZ2UgMgogICAgICAgICAgcXVhdEIudm11bHQoaHVsbEIudW5pcXVlRWRnZXNbZTFdLCB3b3JsZEVkZ2UxKTsKICAgICAgICAgIHdvcmxkRWRnZTAuY3Jvc3Mod29ybGRFZGdlMSwgQ3Jvc3MpOwoKICAgICAgICAgIGlmICghQ3Jvc3MuYWxtb3N0WmVybygpKSB7CiAgICAgICAgICAgIENyb3NzLm5vcm1hbGl6ZSgpOwogICAgICAgICAgICBjb25zdCBkaXN0ID0gaHVsbEEudGVzdFNlcEF4aXMoQ3Jvc3MsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpOwoKICAgICAgICAgICAgaWYgKGRpc3QgPT09IGZhbHNlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoZGlzdCA8IGRtaW4pIHsKICAgICAgICAgICAgICBkbWluID0gZGlzdDsKICAgICAgICAgICAgICB0YXJnZXQuY29weShDcm9zcyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHBvc0IudnN1Yihwb3NBLCBkZWx0YUMpOwoKICAgICAgaWYgKGRlbHRhQy5kb3QodGFyZ2V0KSA+IDAuMCkgewogICAgICAgIHRhcmdldC5uZWdhdGUodGFyZ2V0KTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIFRlc3Qgc2VwYXJhdGluZyBheGlzIGFnYWluc3QgdHdvIGh1bGxzLiBCb3RoIGh1bGxzIGFyZSBwcm9qZWN0ZWQgb250byB0aGUgYXhpcyBhbmQgdGhlIG92ZXJsYXAgc2l6ZSBpcyByZXR1cm5lZCBpZiB0aGVyZSBpcyBvbmUuCiAgICAgKiBAcmV0dXJuIFRoZSBvdmVybGFwIGRlcHRoLCBvciBGQUxTRSBpZiBubyBwZW5ldHJhdGlvbi4KICAgICAqLwoKCiAgICB0ZXN0U2VwQXhpcyhheGlzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKSB7CiAgICAgIGNvbnN0IGh1bGxBID0gdGhpczsKICAgICAgQ29udmV4UG9seWhlZHJvbi5wcm9qZWN0KGh1bGxBLCBheGlzLCBwb3NBLCBxdWF0QSwgbWF4bWluQSk7CiAgICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdChodWxsQiwgYXhpcywgcG9zQiwgcXVhdEIsIG1heG1pbkIpOwogICAgICBjb25zdCBtYXhBID0gbWF4bWluQVswXTsKICAgICAgY29uc3QgbWluQSA9IG1heG1pbkFbMV07CiAgICAgIGNvbnN0IG1heEIgPSBtYXhtaW5CWzBdOwogICAgICBjb25zdCBtaW5CID0gbWF4bWluQlsxXTsKCiAgICAgIGlmIChtYXhBIDwgbWluQiB8fCBtYXhCIDwgbWluQSkgewogICAgICAgIHJldHVybiBmYWxzZTsgLy8gU2VwYXJhdGVkCiAgICAgIH0KCiAgICAgIGNvbnN0IGQwID0gbWF4QSAtIG1pbkI7CiAgICAgIGNvbnN0IGQxID0gbWF4QiAtIG1pbkE7CiAgICAgIGNvbnN0IGRlcHRoID0gZDAgPCBkMSA/IGQwIDogZDE7CiAgICAgIHJldHVybiBkZXB0aDsKICAgIH0KICAgIC8qKgogICAgICogY2FsY3VsYXRlTG9jYWxJbmVydGlhCiAgICAgKi8KCgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhCiAgICAgIC8vIEV4YWN0IGluZXJ0aWEgY2FsY3VsYXRpb24gaXMgb3ZlcmtpbGwsIGJ1dCBzZWUgaHR0cDovL2dlb21ldHJpY3Rvb2xzLmNvbS9Eb2N1bWVudGF0aW9uL1BvbHloZWRyYWxNYXNzUHJvcGVydGllcy5wZGYgZm9yIHRoZSBjb3JyZWN0IHdheSB0byBkbyBpdAogICAgICBjb25zdCBhYWJibWF4ID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgYWFiYm1pbiA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuY29tcHV0ZUxvY2FsQUFCQihhYWJibWluLCBhYWJibWF4KTsKICAgICAgY29uc3QgeCA9IGFhYmJtYXgueCAtIGFhYmJtaW4ueDsKICAgICAgY29uc3QgeSA9IGFhYmJtYXgueSAtIGFhYmJtaW4ueTsKICAgICAgY29uc3QgeiA9IGFhYmJtYXgueiAtIGFhYmJtaW4uejsKICAgICAgdGFyZ2V0LnggPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogeSAqIDIgKiB5ICsgMiAqIHogKiAyICogeik7CiAgICAgIHRhcmdldC55ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoMiAqIHggKiAyICogeCArIDIgKiB6ICogMiAqIHopOwogICAgICB0YXJnZXQueiA9IDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiB5ICogMiAqIHkgKyAyICogeCAqIDIgKiB4KTsKICAgIH0KICAgIC8qKgogICAgICogQHBhcmFtIGZhY2VfaSBJbmRleCBvZiB0aGUgZmFjZQogICAgICovCgoKICAgIGdldFBsYW5lQ29uc3RhbnRPZkZhY2UoZmFjZV9pKSB7CiAgICAgIGNvbnN0IGYgPSB0aGlzLmZhY2VzW2ZhY2VfaV07CiAgICAgIGNvbnN0IG4gPSB0aGlzLmZhY2VOb3JtYWxzW2ZhY2VfaV07CiAgICAgIGNvbnN0IHYgPSB0aGlzLnZlcnRpY2VzW2ZbMF1dOwogICAgICBjb25zdCBjID0gLW4uZG90KHYpOwogICAgICByZXR1cm4gYzsKICAgIH0KICAgIC8qKgogICAgICogQ2xpcCBhIGZhY2UgYWdhaW5zdCBhIGh1bGwuCiAgICAgKiBAcGFyYW0gd29ybGRWZXJ0c0IxIEFuIGFycmF5IG9mIFZlYzMgd2l0aCB2ZXJ0aWNlcyBpbiB0aGUgd29ybGQgZnJhbWUuCiAgICAgKiBAcGFyYW0gbWluRGlzdCBEaXN0YW5jZSBjbGFtcGluZwogICAgICogQHBhcmFtIEFycmF5IHJlc3VsdCBBcnJheSB0byBzdG9yZSByZXN1bHRpbmcgY29udGFjdCBwb2ludHMgaW4uIFdpbGwgYmUgb2JqZWN0cyB3aXRoIHByb3BlcnRpZXM6IHBvaW50LCBkZXB0aCwgbm9ybWFsLiBUaGVzZSBhcmUgcmVwcmVzZW50ZWQgaW4gd29ybGQgY29vcmRpbmF0ZXMuCiAgICAgKi8KCgogICAgY2xpcEZhY2VBZ2FpbnN0SHVsbChzZXBhcmF0aW5nTm9ybWFsLCBwb3NBLCBxdWF0QSwgd29ybGRWZXJ0c0IxLCBtaW5EaXN0LCBtYXhEaXN0LCByZXN1bHQpIHsKICAgICAgY29uc3QgZmFjZUFOb3JtYWxXUyA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IGVkZ2UwID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgV29ybGRFZGdlMCA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHdvcmxkUGxhbmVBbm9ybWFsMSA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHBsYW5lTm9ybWFsV1MxID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3Qgd29ybGRBMSA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IGxvY2FsUGxhbmVOb3JtYWwgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBwbGFuZU5vcm1hbFdTID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgaHVsbEEgPSB0aGlzOwogICAgICBjb25zdCB3b3JsZFZlcnRzQjIgPSBbXTsKICAgICAgY29uc3QgcFZ0eEluID0gd29ybGRWZXJ0c0IxOwogICAgICBjb25zdCBwVnR4T3V0ID0gd29ybGRWZXJ0c0IyOwogICAgICBsZXQgY2xvc2VzdEZhY2VBID0gLTE7CiAgICAgIGxldCBkbWluID0gTnVtYmVyLk1BWF9WQUxVRTsgLy8gRmluZCB0aGUgZmFjZSB3aXRoIG5vcm1hbCBjbG9zZXN0IHRvIHRoZSBzZXBhcmF0aW5nIGF4aXMKCiAgICAgIGZvciAobGV0IGZhY2UgPSAwOyBmYWNlIDwgaHVsbEEuZmFjZXMubGVuZ3RoOyBmYWNlKyspIHsKICAgICAgICBmYWNlQU5vcm1hbFdTLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmFjZV0pOwogICAgICAgIHF1YXRBLnZtdWx0KGZhY2VBTm9ybWFsV1MsIGZhY2VBTm9ybWFsV1MpOwogICAgICAgIGNvbnN0IGQgPSBmYWNlQU5vcm1hbFdTLmRvdChzZXBhcmF0aW5nTm9ybWFsKTsKCiAgICAgICAgaWYgKGQgPCBkbWluKSB7CiAgICAgICAgICBkbWluID0gZDsKICAgICAgICAgIGNsb3Nlc3RGYWNlQSA9IGZhY2U7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoY2xvc2VzdEZhY2VBIDwgMCkgewogICAgICAgIHJldHVybjsKICAgICAgfSAvLyBHZXQgdGhlIGZhY2UgYW5kIGNvbnN0cnVjdCBjb25uZWN0ZWQgZmFjZXMKCgogICAgICBjb25zdCBwb2x5QSA9IGh1bGxBLmZhY2VzW2Nsb3Nlc3RGYWNlQV07CiAgICAgIHBvbHlBLmNvbm5lY3RlZEZhY2VzID0gW107CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGh1bGxBLmZhY2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBodWxsQS5mYWNlc1tpXS5sZW5ndGg7IGorKykgewogICAgICAgICAgaWYgKAogICAgICAgICAgLyogU2hhcmluZyBhIHZlcnRleCovCiAgICAgICAgICBwb2x5QS5pbmRleE9mKGh1bGxBLmZhY2VzW2ldW2pdKSAhPT0gLTEgJiYKICAgICAgICAgIC8qIE5vdCB0aGUgb25lIHdlIGFyZSBsb29raW5nIGZvciBjb25uZWN0aW9ucyBmcm9tICovCiAgICAgICAgICBpICE9PSBjbG9zZXN0RmFjZUEgJiYKICAgICAgICAgIC8qIE5vdCBhbHJlYWR5IGFkZGVkICovCiAgICAgICAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcy5pbmRleE9mKGkpID09PSAtMSkgewogICAgICAgICAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcy5wdXNoKGkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSAvLyBDbGlwIHRoZSBwb2x5Z29uIHRvIHRoZSBiYWNrIG9mIHRoZSBwbGFuZXMgb2YgYWxsIGZhY2VzIG9mIGh1bGwgQSwKICAgICAgLy8gdGhhdCBhcmUgYWRqYWNlbnQgdG8gdGhlIHdpdG5lc3MgZmFjZQoKCiAgICAgIGNvbnN0IG51bVZlcnRpY2VzQSA9IHBvbHlBLmxlbmd0aDsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydGljZXNBOyBpKyspIHsKICAgICAgICBjb25zdCBhID0gaHVsbEEudmVydGljZXNbcG9seUFbaV1dOwogICAgICAgIGNvbnN0IGIgPSBodWxsQS52ZXJ0aWNlc1twb2x5QVsoaSArIDEpICUgbnVtVmVydGljZXNBXV07CiAgICAgICAgYS52c3ViKGIsIGVkZ2UwKTsKICAgICAgICBXb3JsZEVkZ2UwLmNvcHkoZWRnZTApOwogICAgICAgIHF1YXRBLnZtdWx0KFdvcmxkRWRnZTAsIFdvcmxkRWRnZTApOwogICAgICAgIHBvc0EudmFkZChXb3JsZEVkZ2UwLCBXb3JsZEVkZ2UwKTsKICAgICAgICB3b3JsZFBsYW5lQW5vcm1hbDEuY29weSh0aGlzLmZhY2VOb3JtYWxzW2Nsb3Nlc3RGYWNlQV0pOwogICAgICAgIHF1YXRBLnZtdWx0KHdvcmxkUGxhbmVBbm9ybWFsMSwgd29ybGRQbGFuZUFub3JtYWwxKTsKICAgICAgICBwb3NBLnZhZGQod29ybGRQbGFuZUFub3JtYWwxLCB3b3JsZFBsYW5lQW5vcm1hbDEpOwogICAgICAgIFdvcmxkRWRnZTAuY3Jvc3Mod29ybGRQbGFuZUFub3JtYWwxLCBwbGFuZU5vcm1hbFdTMSk7CiAgICAgICAgcGxhbmVOb3JtYWxXUzEubmVnYXRlKHBsYW5lTm9ybWFsV1MxKTsKICAgICAgICB3b3JsZEExLmNvcHkoYSk7CiAgICAgICAgcXVhdEEudm11bHQod29ybGRBMSwgd29ybGRBMSk7CiAgICAgICAgcG9zQS52YWRkKHdvcmxkQTEsIHdvcmxkQTEpOwogICAgICAgIGNvbnN0IG90aGVyRmFjZSA9IHBvbHlBLmNvbm5lY3RlZEZhY2VzW2ldOwogICAgICAgIGxvY2FsUGxhbmVOb3JtYWwuY29weSh0aGlzLmZhY2VOb3JtYWxzW290aGVyRmFjZV0pOwogICAgICAgIGNvbnN0IGxvY2FsUGxhbmVFcSA9IHRoaXMuZ2V0UGxhbmVDb25zdGFudE9mRmFjZShvdGhlckZhY2UpOwogICAgICAgIHBsYW5lTm9ybWFsV1MuY29weShsb2NhbFBsYW5lTm9ybWFsKTsKICAgICAgICBxdWF0QS52bXVsdChwbGFuZU5vcm1hbFdTLCBwbGFuZU5vcm1hbFdTKTsKICAgICAgICBjb25zdCBwbGFuZUVxV1MgPSBsb2NhbFBsYW5lRXEgLSBwbGFuZU5vcm1hbFdTLmRvdChwb3NBKTsgLy8gQ2xpcCBmYWNlIGFnYWluc3Qgb3VyIGNvbnN0cnVjdGVkIHBsYW5lCgogICAgICAgIHRoaXMuY2xpcEZhY2VBZ2FpbnN0UGxhbmUocFZ0eEluLCBwVnR4T3V0LCBwbGFuZU5vcm1hbFdTLCBwbGFuZUVxV1MpOyAvLyBUaHJvdyBhd2F5IGFsbCBjbGlwcGVkIHBvaW50cywgYnV0IHNhdmUgdGhlIHJlbWFpbmluZyB1bnRpbCBuZXh0IGNsaXAKCiAgICAgICAgd2hpbGUgKHBWdHhJbi5sZW5ndGgpIHsKICAgICAgICAgIHBWdHhJbi5zaGlmdCgpOwogICAgICAgIH0KCiAgICAgICAgd2hpbGUgKHBWdHhPdXQubGVuZ3RoKSB7CiAgICAgICAgICBwVnR4SW4ucHVzaChwVnR4T3V0LnNoaWZ0KCkpOwogICAgICAgIH0KICAgICAgfSAvLyBvbmx5IGtlZXAgY29udGFjdCBwb2ludHMgdGhhdCBhcmUgYmVoaW5kIHRoZSB3aXRuZXNzIGZhY2UKCgogICAgICBsb2NhbFBsYW5lTm9ybWFsLmNvcHkodGhpcy5mYWNlTm9ybWFsc1tjbG9zZXN0RmFjZUFdKTsKICAgICAgY29uc3QgbG9jYWxQbGFuZUVxID0gdGhpcy5nZXRQbGFuZUNvbnN0YW50T2ZGYWNlKGNsb3Nlc3RGYWNlQSk7CiAgICAgIHBsYW5lTm9ybWFsV1MuY29weShsb2NhbFBsYW5lTm9ybWFsKTsKICAgICAgcXVhdEEudm11bHQocGxhbmVOb3JtYWxXUywgcGxhbmVOb3JtYWxXUyk7CiAgICAgIGNvbnN0IHBsYW5lRXFXUyA9IGxvY2FsUGxhbmVFcSAtIHBsYW5lTm9ybWFsV1MuZG90KHBvc0EpOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwVnR4SW4ubGVuZ3RoOyBpKyspIHsKICAgICAgICBsZXQgZGVwdGggPSBwbGFuZU5vcm1hbFdTLmRvdChwVnR4SW5baV0pICsgcGxhbmVFcVdTOyAvLyA/Pz8KCiAgICAgICAgaWYgKGRlcHRoIDw9IG1pbkRpc3QpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKGBjbGFtcGVkOiBkZXB0aD0ke2RlcHRofSB0byBtaW5EaXN0PSR7bWluRGlzdH1gKTsKICAgICAgICAgIGRlcHRoID0gbWluRGlzdDsKICAgICAgICB9CgogICAgICAgIGlmIChkZXB0aCA8PSBtYXhEaXN0KSB7CiAgICAgICAgICBjb25zdCBwb2ludCA9IHBWdHhJbltpXTsKCiAgICAgICAgICBpZiAoZGVwdGggPD0gMWUtNikgewogICAgICAgICAgICBjb25zdCBwID0gewogICAgICAgICAgICAgIHBvaW50LAogICAgICAgICAgICAgIG5vcm1hbDogcGxhbmVOb3JtYWxXUywKICAgICAgICAgICAgICBkZXB0aAogICAgICAgICAgICB9OwogICAgICAgICAgICByZXN1bHQucHVzaChwKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ2xpcCBhIGZhY2UgaW4gYSBodWxsIGFnYWluc3QgdGhlIGJhY2sgb2YgYSBwbGFuZS4KICAgICAqIEBwYXJhbSBwbGFuZUNvbnN0YW50IFRoZSBjb25zdGFudCBpbiB0aGUgbWF0aGVtYXRpY2FsIHBsYW5lIGVxdWF0aW9uCiAgICAgKi8KCgogICAgY2xpcEZhY2VBZ2FpbnN0UGxhbmUoaW5WZXJ0aWNlcywgb3V0VmVydGljZXMsIHBsYW5lTm9ybWFsLCBwbGFuZUNvbnN0YW50KSB7CiAgICAgIGxldCBuX2RvdF9maXJzdDsKICAgICAgbGV0IG5fZG90X2xhc3Q7CiAgICAgIGNvbnN0IG51bVZlcnRzID0gaW5WZXJ0aWNlcy5sZW5ndGg7CgogICAgICBpZiAobnVtVmVydHMgPCAyKSB7CiAgICAgICAgcmV0dXJuIG91dFZlcnRpY2VzOwogICAgICB9CgogICAgICBsZXQgZmlyc3RWZXJ0ZXggPSBpblZlcnRpY2VzW2luVmVydGljZXMubGVuZ3RoIC0gMV07CiAgICAgIGxldCBsYXN0VmVydGV4ID0gaW5WZXJ0aWNlc1swXTsKICAgICAgbl9kb3RfZmlyc3QgPSBwbGFuZU5vcm1hbC5kb3QoZmlyc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDsKCiAgICAgIGZvciAobGV0IHZpID0gMDsgdmkgPCBudW1WZXJ0czsgdmkrKykgewogICAgICAgIGxhc3RWZXJ0ZXggPSBpblZlcnRpY2VzW3ZpXTsKICAgICAgICBuX2RvdF9sYXN0ID0gcGxhbmVOb3JtYWwuZG90KGxhc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDsKCiAgICAgICAgaWYgKG5fZG90X2ZpcnN0IDwgMCkgewogICAgICAgICAgaWYgKG5fZG90X2xhc3QgPCAwKSB7CiAgICAgICAgICAgIC8vIFN0YXJ0IDwgMCwgZW5kIDwgMCwgc28gb3V0cHV0IGxhc3RWZXJ0ZXgKICAgICAgICAgICAgY29uc3QgbmV3diA9IG5ldyBWZWMzKCk7CiAgICAgICAgICAgIG5ld3YuY29weShsYXN0VmVydGV4KTsKICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIFN0YXJ0IDwgMCwgZW5kID49IDAsIHNvIG91dHB1dCBpbnRlcnNlY3Rpb24KICAgICAgICAgICAgY29uc3QgbmV3diA9IG5ldyBWZWMzKCk7CiAgICAgICAgICAgIGZpcnN0VmVydGV4LmxlcnAobGFzdFZlcnRleCwgbl9kb3RfZmlyc3QgLyAobl9kb3RfZmlyc3QgLSBuX2RvdF9sYXN0KSwgbmV3dik7CiAgICAgICAgICAgIG91dFZlcnRpY2VzLnB1c2gobmV3dik7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChuX2RvdF9sYXN0IDwgMCkgewogICAgICAgICAgICAvLyBTdGFydCA+PSAwLCBlbmQgPCAwIHNvIG91dHB1dCBpbnRlcnNlY3Rpb24gYW5kIGVuZAogICAgICAgICAgICBjb25zdCBuZXd2ID0gbmV3IFZlYzMoKTsKICAgICAgICAgICAgZmlyc3RWZXJ0ZXgubGVycChsYXN0VmVydGV4LCBuX2RvdF9maXJzdCAvIChuX2RvdF9maXJzdCAtIG5fZG90X2xhc3QpLCBuZXd2KTsKICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTsKICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChsYXN0VmVydGV4KTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGZpcnN0VmVydGV4ID0gbGFzdFZlcnRleDsKICAgICAgICBuX2RvdF9maXJzdCA9IG5fZG90X2xhc3Q7CiAgICAgIH0KCiAgICAgIHJldHVybiBvdXRWZXJ0aWNlczsKICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlcyBgLndvcmxkVmVydGljZXNgIGFuZCBzZXRzIGAud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlYCB0byBmYWxzZS4KICAgICAqLwoKCiAgICBjb21wdXRlV29ybGRWZXJ0aWNlcyhwb3NpdGlvbiwgcXVhdCkgewogICAgICB3aGlsZSAodGhpcy53b3JsZFZlcnRpY2VzLmxlbmd0aCA8IHRoaXMudmVydGljZXMubGVuZ3RoKSB7CiAgICAgICAgdGhpcy53b3JsZFZlcnRpY2VzLnB1c2gobmV3IFZlYzMoKSk7CiAgICAgIH0KCiAgICAgIGNvbnN0IHZlcnRzID0gdGhpcy52ZXJ0aWNlczsKICAgICAgY29uc3Qgd29ybGRWZXJ0cyA9IHRoaXMud29ybGRWZXJ0aWNlczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgcXVhdC52bXVsdCh2ZXJ0c1tpXSwgd29ybGRWZXJ0c1tpXSk7CiAgICAgICAgcG9zaXRpb24udmFkZCh3b3JsZFZlcnRzW2ldLCB3b3JsZFZlcnRzW2ldKTsKICAgICAgfQoKICAgICAgdGhpcy53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgPSBmYWxzZTsKICAgIH0KCiAgICBjb21wdXRlTG9jYWxBQUJCKGFhYmJtaW4sIGFhYmJtYXgpIHsKICAgICAgY29uc3QgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzOwogICAgICBhYWJibWluLnNldChOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTsKICAgICAgYWFiYm1heC5zZXQoLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCB2ID0gdmVydGljZXNbaV07CgogICAgICAgIGlmICh2LnggPCBhYWJibWluLngpIHsKICAgICAgICAgIGFhYmJtaW4ueCA9IHYueDsKICAgICAgICB9IGVsc2UgaWYgKHYueCA+IGFhYmJtYXgueCkgewogICAgICAgICAgYWFiYm1heC54ID0gdi54OwogICAgICAgIH0KCiAgICAgICAgaWYgKHYueSA8IGFhYmJtaW4ueSkgewogICAgICAgICAgYWFiYm1pbi55ID0gdi55OwogICAgICAgIH0gZWxzZSBpZiAodi55ID4gYWFiYm1heC55KSB7CiAgICAgICAgICBhYWJibWF4LnkgPSB2Lnk7CiAgICAgICAgfQoKICAgICAgICBpZiAodi56IDwgYWFiYm1pbi56KSB7CiAgICAgICAgICBhYWJibWluLnogPSB2Lno7CiAgICAgICAgfSBlbHNlIGlmICh2LnogPiBhYWJibWF4LnopIHsKICAgICAgICAgIGFhYmJtYXgueiA9IHYuejsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlcyBgd29ybGRWZXJ0aWNlc2AgYW5kIHNldHMgYHdvcmxkVmVydGljZXNOZWVkc1VwZGF0ZWAgdG8gZmFsc2UuCiAgICAgKi8KCgogICAgY29tcHV0ZVdvcmxkRmFjZU5vcm1hbHMocXVhdCkgewogICAgICBjb25zdCBOID0gdGhpcy5mYWNlTm9ybWFscy5sZW5ndGg7CgogICAgICB3aGlsZSAodGhpcy53b3JsZEZhY2VOb3JtYWxzLmxlbmd0aCA8IE4pIHsKICAgICAgICB0aGlzLndvcmxkRmFjZU5vcm1hbHMucHVzaChuZXcgVmVjMygpKTsKICAgICAgfQoKICAgICAgY29uc3Qgbm9ybWFscyA9IHRoaXMuZmFjZU5vcm1hbHM7CiAgICAgIGNvbnN0IHdvcmxkTm9ybWFscyA9IHRoaXMud29ybGRGYWNlTm9ybWFsczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOOyBpKyspIHsKICAgICAgICBxdWF0LnZtdWx0KG5vcm1hbHNbaV0sIHdvcmxkTm9ybWFsc1tpXSk7CiAgICAgIH0KCiAgICAgIHRoaXMud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlID0gZmFsc2U7CiAgICB9CiAgICAvKioKICAgICAqIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzCiAgICAgKi8KCgogICAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7CiAgICAgIC8vIEFzc3VtZSBwb2ludHMgYXJlIGRpc3RyaWJ1dGVkIHdpdGggbG9jYWwgKDAsMCwwKSBhcyBjZW50ZXIKICAgICAgbGV0IG1heDIgPSAwOwogICAgICBjb25zdCB2ZXJ0cyA9IHRoaXMudmVydGljZXM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gdmVydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBub3JtMiA9IHZlcnRzW2ldLmxlbmd0aFNxdWFyZWQoKTsKCiAgICAgICAgaWYgKG5vcm0yID4gbWF4MikgewogICAgICAgICAgbWF4MiA9IG5vcm0yOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE1hdGguc3FydChtYXgyKTsKICAgIH0KICAgIC8qKgogICAgICogY2FsY3VsYXRlV29ybGRBQUJCCiAgICAgKi8KCgogICAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHsKICAgICAgY29uc3QgdmVydHMgPSB0aGlzLnZlcnRpY2VzOwogICAgICBsZXQgbWlueDsKICAgICAgbGV0IG1pbnk7CiAgICAgIGxldCBtaW56OwogICAgICBsZXQgbWF4eDsKICAgICAgbGV0IG1heHk7CiAgICAgIGxldCBtYXh6OwogICAgICBsZXQgdGVtcFdvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICB0ZW1wV29ybGRWZXJ0ZXguY29weSh2ZXJ0c1tpXSk7CiAgICAgICAgcXVhdC52bXVsdCh0ZW1wV29ybGRWZXJ0ZXgsIHRlbXBXb3JsZFZlcnRleCk7CiAgICAgICAgcG9zLnZhZGQodGVtcFdvcmxkVmVydGV4LCB0ZW1wV29ybGRWZXJ0ZXgpOwogICAgICAgIGNvbnN0IHYgPSB0ZW1wV29ybGRWZXJ0ZXg7CgogICAgICAgIGlmIChtaW54ID09PSB1bmRlZmluZWQgfHwgdi54IDwgbWlueCkgewogICAgICAgICAgbWlueCA9IHYueDsKICAgICAgICB9CgogICAgICAgIGlmIChtYXh4ID09PSB1bmRlZmluZWQgfHwgdi54ID4gbWF4eCkgewogICAgICAgICAgbWF4eCA9IHYueDsKICAgICAgICB9CgogICAgICAgIGlmIChtaW55ID09PSB1bmRlZmluZWQgfHwgdi55IDwgbWlueSkgewogICAgICAgICAgbWlueSA9IHYueTsKICAgICAgICB9CgogICAgICAgIGlmIChtYXh5ID09PSB1bmRlZmluZWQgfHwgdi55ID4gbWF4eSkgewogICAgICAgICAgbWF4eSA9IHYueTsKICAgICAgICB9CgogICAgICAgIGlmIChtaW56ID09PSB1bmRlZmluZWQgfHwgdi56IDwgbWlueikgewogICAgICAgICAgbWlueiA9IHYuejsKICAgICAgICB9CgogICAgICAgIGlmIChtYXh6ID09PSB1bmRlZmluZWQgfHwgdi56ID4gbWF4eikgewogICAgICAgICAgbWF4eiA9IHYuejsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIG1pbi5zZXQobWlueCwgbWlueSwgbWlueik7CiAgICAgIG1heC5zZXQobWF4eCwgbWF4eSwgbWF4eik7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhcHByb3hpbWF0ZSBjb252ZXggdm9sdW1lCiAgICAgKi8KCgogICAgdm9sdW1lKCkgewogICAgICByZXR1cm4gNC4wICogTWF0aC5QSSAqIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgLyAzLjA7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhbiBhdmVyYWdlIG9mIGFsbCB0aGUgdmVydGljZXMgcG9zaXRpb25zCiAgICAgKi8KCgogICAgZ2V0QXZlcmFnZVBvaW50TG9jYWwodGFyZ2V0KSB7CiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgewogICAgICAgIHRhcmdldCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IHZlcnRzID0gdGhpcy52ZXJ0aWNlczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICB0YXJnZXQudmFkZCh2ZXJ0c1tpXSwgdGFyZ2V0KTsKICAgICAgfQoKICAgICAgdGFyZ2V0LnNjYWxlKDEgLyB2ZXJ0cy5sZW5ndGgsIHRhcmdldCk7CiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9CiAgICAvKioKICAgICAqIFRyYW5zZm9ybSBhbGwgbG9jYWwgcG9pbnRzLiBXaWxsIGNoYW5nZSB0aGUgLnZlcnRpY2VzCiAgICAgKi8KCgogICAgdHJhbnNmb3JtQWxsUG9pbnRzKG9mZnNldCwgcXVhdCkgewogICAgICBjb25zdCBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7CiAgICAgIGNvbnN0IHZlcnRzID0gdGhpcy52ZXJ0aWNlczsgLy8gQXBwbHkgcm90YXRpb24KCiAgICAgIGlmIChxdWF0KSB7CiAgICAgICAgLy8gUm90YXRlIHZlcnRpY2VzCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHsKICAgICAgICAgIGNvbnN0IHYgPSB2ZXJ0c1tpXTsKICAgICAgICAgIHF1YXQudm11bHQodiwgdik7CiAgICAgICAgfSAvLyBSb3RhdGUgZmFjZSBub3JtYWxzCgoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLmZhY2VOb3JtYWxzW2ldOwogICAgICAgICAgcXVhdC52bXVsdCh2LCB2KTsKICAgICAgICB9CiAgICAgICAgLyoKICAgICAgICAgICAgICAvLyBSb3RhdGUgZWRnZXMKICAgICAgICAgICAgICBmb3IobGV0IGk9MDsgaTx0aGlzLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgaSsrKXsKICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMudW5pcXVlRWRnZXNbaV07CiAgICAgICAgICAgICAgICAgIHF1YXQudm11bHQodix2KTsKICAgICAgICAgICAgICB9Ki8KCiAgICAgIH0gLy8gQXBwbHkgb2Zmc2V0CgoKICAgICAgaWYgKG9mZnNldCkgewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7CiAgICAgICAgICBjb25zdCB2ID0gdmVydHNbaV07CiAgICAgICAgICB2LnZhZGQob2Zmc2V0LCB2KTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgcCBpcyBpbnNpZGUgdGhlIHBvbHloZWRyYS4gTXVzdCBiZSBpbiBsb2NhbCBjb29yZHMuCiAgICAgKiBUaGUgcG9pbnQgbGllcyBvdXRzaWRlIG9mIHRoZSBjb252ZXggaHVsbCBvZiB0aGUgb3RoZXIgcG9pbnRzIGlmIGFuZCBvbmx5IGlmIHRoZSBkaXJlY3Rpb24KICAgICAqIG9mIGFsbCB0aGUgdmVjdG9ycyBmcm9tIGl0IHRvIHRob3NlIG90aGVyIHBvaW50cyBhcmUgb24gbGVzcyB0aGFuIG9uZSBoYWxmIG9mIGEgc3BoZXJlIGFyb3VuZCBpdC4KICAgICAqIEBwYXJhbSBwIEEgcG9pbnQgZ2l2ZW4gaW4gbG9jYWwgY29vcmRpbmF0ZXMKICAgICAqLwoKCiAgICBwb2ludElzSW5zaWRlKHApIHsKICAgICAgY29uc3QgdmVydHMgPSB0aGlzLnZlcnRpY2VzOwogICAgICBjb25zdCBmYWNlcyA9IHRoaXMuZmFjZXM7CiAgICAgIGNvbnN0IG5vcm1hbHMgPSB0aGlzLmZhY2VOb3JtYWxzOwogICAgICBjb25zdCBwb3NpdGl2ZVJlc3VsdCA9IG51bGw7CiAgICAgIGNvbnN0IHBvaW50SW5zaWRlID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5nZXRBdmVyYWdlUG9pbnRMb2NhbChwb2ludEluc2lkZSk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBsZXQgbiA9IG5vcm1hbHNbaV07CiAgICAgICAgY29uc3QgdiA9IHZlcnRzW2ZhY2VzW2ldWzBdXTsgLy8gV2Ugb25seSBuZWVkIG9uZSBwb2ludCBpbiB0aGUgZmFjZQogICAgICAgIC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpcwoKICAgICAgICBjb25zdCB2VG9QID0gbmV3IFZlYzMoKTsKICAgICAgICBwLnZzdWIodiwgdlRvUCk7CiAgICAgICAgY29uc3QgcjEgPSBuLmRvdCh2VG9QKTsKICAgICAgICBjb25zdCB2VG9Qb2ludEluc2lkZSA9IG5ldyBWZWMzKCk7CiAgICAgICAgcG9pbnRJbnNpZGUudnN1Yih2LCB2VG9Qb2ludEluc2lkZSk7CiAgICAgICAgY29uc3QgcjIgPSBuLmRvdCh2VG9Qb2ludEluc2lkZSk7CgogICAgICAgIGlmIChyMSA8IDAgJiYgcjIgPiAwIHx8IHIxID4gMCAmJiByMiA8IDApIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gRW5jb3VudGVyZWQgc29tZSBvdGhlciBzaWduLiBFeGl0LgogICAgICAgIH0KICAgICAgfSAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIGRvdCBwcm9kdWN0cyB3ZXJlIG9mIHRoZSBzYW1lIHNpZ24uCgoKICAgICAgcmV0dXJuIHBvc2l0aXZlUmVzdWx0ID8gMSA6IC0xOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgbWF4IGFuZCBtaW4gZG90IHByb2R1Y3Qgb2YgYSBjb252ZXggaHVsbCBhdCBwb3NpdGlvbiAocG9zLHF1YXQpIHByb2plY3RlZCBvbnRvIGFuIGF4aXMuCiAgICAgKiBSZXN1bHRzIGFyZSBzYXZlZCBpbiB0aGUgYXJyYXkgbWF4bWluLgogICAgICogQHBhcmFtIHJlc3VsdCByZXN1bHRbMF0gYW5kIHJlc3VsdFsxXSB3aWxsIGJlIHNldCB0byBtYXhpbXVtIGFuZCBtaW5pbXVtLCByZXNwZWN0aXZlbHkuCiAgICAgKi8KCgogICAgc3RhdGljIHByb2plY3Qoc2hhcGUsIGF4aXMsIHBvcywgcXVhdCwgcmVzdWx0KSB7CiAgICAgIGNvbnN0IG4gPSBzaGFwZS52ZXJ0aWNlcy5sZW5ndGg7CiAgICAgIGNvbnN0IGxvY2FsQXhpcyA9IHByb2plY3RfbG9jYWxBeGlzOwogICAgICBsZXQgbWF4ID0gMDsKICAgICAgbGV0IG1pbiA9IDA7CiAgICAgIGNvbnN0IGxvY2FsT3JpZ2luID0gcHJvamVjdF9sb2NhbE9yaWdpbjsKICAgICAgY29uc3QgdnMgPSBzaGFwZS52ZXJ0aWNlczsKICAgICAgbG9jYWxPcmlnaW4uc2V0WmVybygpOyAvLyBUcmFuc2Zvcm0gdGhlIGF4aXMgdG8gbG9jYWwKCiAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb0xvY2FsRnJhbWUocG9zLCBxdWF0LCBheGlzLCBsb2NhbEF4aXMpOwogICAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zLCBxdWF0LCBsb2NhbE9yaWdpbiwgbG9jYWxPcmlnaW4pOwogICAgICBjb25zdCBhZGQgPSBsb2NhbE9yaWdpbi5kb3QobG9jYWxBeGlzKTsKICAgICAgbWluID0gbWF4ID0gdnNbMF0uZG90KGxvY2FsQXhpcyk7CgogICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG47IGkrKykgewogICAgICAgIGNvbnN0IHZhbCA9IHZzW2ldLmRvdChsb2NhbEF4aXMpOwoKICAgICAgICBpZiAodmFsID4gbWF4KSB7CiAgICAgICAgICBtYXggPSB2YWw7CiAgICAgICAgfQoKICAgICAgICBpZiAodmFsIDwgbWluKSB7CiAgICAgICAgICBtaW4gPSB2YWw7CiAgICAgICAgfQogICAgICB9CgogICAgICBtaW4gLT0gYWRkOwogICAgICBtYXggLT0gYWRkOwoKICAgICAgaWYgKG1pbiA+IG1heCkgewogICAgICAgIC8vIEluY29uc2lzdGVudCAtIHN3YXAKICAgICAgICBjb25zdCB0ZW1wID0gbWluOwogICAgICAgIG1pbiA9IG1heDsKICAgICAgICBtYXggPSB0ZW1wOwogICAgICB9IC8vIE91dHB1dAoKCiAgICAgIHJlc3VsdFswXSA9IG1heDsKICAgICAgcmVzdWx0WzFdID0gbWluOwogICAgfQoKICB9CiAgY29uc3QgbWF4bWluQSA9IFtdOwogIGNvbnN0IG1heG1pbkIgPSBbXTsKICBuZXcgVmVjMygpOwogIGNvbnN0IHByb2plY3RfbG9jYWxBeGlzID0gbmV3IFZlYzMoKTsKICBjb25zdCBwcm9qZWN0X2xvY2FsT3JpZ2luID0gbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQSAzZCBib3ggc2hhcGUuCiAgICogQGV4YW1wbGUKICAgKiAgICAgY29uc3Qgc2l6ZSA9IDEKICAgKiAgICAgY29uc3QgaGFsZkV4dGVudHMgPSBuZXcgQ0FOTk9OLlZlYzMoc2l6ZSwgc2l6ZSwgc2l6ZSkKICAgKiAgICAgY29uc3QgYm94U2hhcGUgPSBuZXcgQ0FOTk9OLkJveChoYWxmRXh0ZW50cykKICAgKiAgICAgY29uc3QgYm94Qm9keSA9IG5ldyBDQU5OT04uQm9keSh7IG1hc3M6IDEsIHNoYXBlOiBib3hTaGFwZSB9KQogICAqICAgICB3b3JsZC5hZGRCb2R5KGJveEJvZHkpCiAgICovCiAgY2xhc3MgQm94IGV4dGVuZHMgU2hhcGUgewogICAgLyoqCiAgICAgKiBUaGUgaGFsZiBleHRlbnRzIG9mIHRoZSBib3guCiAgICAgKi8KCiAgICAvKioKICAgICAqIFVzZWQgYnkgdGhlIGNvbnRhY3QgZ2VuZXJhdG9yIHRvIG1ha2UgY29udGFjdHMgd2l0aCBvdGhlciBjb252ZXggcG9seWhlZHJhIGZvciBleGFtcGxlLgogICAgICovCiAgICBjb25zdHJ1Y3RvcihoYWxmRXh0ZW50cykgewogICAgICBzdXBlcih7CiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuQk9YCiAgICAgIH0pOwogICAgICB0aGlzLmhhbGZFeHRlbnRzID0gaGFsZkV4dGVudHM7CiAgICAgIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gbnVsbDsKICAgICAgdGhpcy51cGRhdGVDb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24oKTsKICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpOwogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBjb252ZXggcG9seWhlZHJvbiByZXByZXNlbnRhdGlvbiB1c2VkIGZvciBzb21lIGNvbGxpc2lvbnMuCiAgICAgKi8KCgogICAgdXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uKCkgewogICAgICBjb25zdCBzeCA9IHRoaXMuaGFsZkV4dGVudHMueDsKICAgICAgY29uc3Qgc3kgPSB0aGlzLmhhbGZFeHRlbnRzLnk7CiAgICAgIGNvbnN0IHN6ID0gdGhpcy5oYWxmRXh0ZW50cy56OwogICAgICBjb25zdCBWID0gVmVjMzsKICAgICAgY29uc3QgdmVydGljZXMgPSBbbmV3IFYoLXN4LCAtc3ksIC1zeiksIG5ldyBWKHN4LCAtc3ksIC1zeiksIG5ldyBWKHN4LCBzeSwgLXN6KSwgbmV3IFYoLXN4LCBzeSwgLXN6KSwgbmV3IFYoLXN4LCAtc3ksIHN6KSwgbmV3IFYoc3gsIC1zeSwgc3opLCBuZXcgVihzeCwgc3ksIHN6KSwgbmV3IFYoLXN4LCBzeSwgc3opXTsKICAgICAgY29uc3QgZmFjZXMgPSBbWzMsIDIsIDEsIDBdLCAvLyAtegogICAgICBbNCwgNSwgNiwgN10sIC8vICt6CiAgICAgIFs1LCA0LCAwLCAxXSwgLy8gLXkKICAgICAgWzIsIDMsIDcsIDZdLCAvLyAreQogICAgICBbMCwgNCwgNywgM10sIC8vIC14CiAgICAgIFsxLCAyLCA2LCA1XSAvLyAreAogICAgICBdOwogICAgICBjb25zdCBheGVzID0gW25ldyBWKDAsIDAsIDEpLCBuZXcgVigwLCAxLCAwKSwgbmV3IFYoMSwgMCwgMCldOwogICAgICBjb25zdCBoID0gbmV3IENvbnZleFBvbHloZWRyb24oewogICAgICAgIHZlcnRpY2VzLAogICAgICAgIGZhY2VzLAogICAgICAgIGF4ZXMKICAgICAgfSk7CiAgICAgIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gaDsKICAgICAgaC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7CiAgICB9CiAgICAvKioKICAgICAqIENhbGN1bGF0ZSB0aGUgaW5lcnRpYSBvZiB0aGUgYm94LgogICAgICovCgoKICAgIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYShtYXNzLCB0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgQm94LmNhbGN1bGF0ZUluZXJ0aWEodGhpcy5oYWxmRXh0ZW50cywgbWFzcywgdGFyZ2V0KTsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KCiAgICBzdGF0aWMgY2FsY3VsYXRlSW5lcnRpYShoYWxmRXh0ZW50cywgbWFzcywgdGFyZ2V0KSB7CiAgICAgIGNvbnN0IGUgPSBoYWxmRXh0ZW50czsKICAgICAgdGFyZ2V0LnggPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogZS55ICogMiAqIGUueSArIDIgKiBlLnogKiAyICogZS56KTsKICAgICAgdGFyZ2V0LnkgPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogZS54ICogMiAqIGUueCArIDIgKiBlLnogKiAyICogZS56KTsKICAgICAgdGFyZ2V0LnogPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogZS55ICogMiAqIGUueSArIDIgKiBlLnggKiAyICogZS54KTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSBib3ggNiBzaWRlIG5vcm1hbHMKICAgICAqIEBwYXJhbSBzaXhUYXJnZXRWZWN0b3JzIEFuIGFycmF5IG9mIDYgdmVjdG9ycywgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBzaWRlIG5vcm1hbHMgaW4uCiAgICAgKiBAcGFyYW0gcXVhdCBPcmllbnRhdGlvbiB0byBhcHBseSB0byB0aGUgbm9ybWFsIHZlY3RvcnMuIElmIG5vdCBwcm92aWRlZCwgdGhlIHZlY3RvcnMgd2lsbCBiZSBpbiByZXNwZWN0IHRvIHRoZSBsb2NhbCBmcmFtZS4KICAgICAqLwoKCiAgICBnZXRTaWRlTm9ybWFscyhzaXhUYXJnZXRWZWN0b3JzLCBxdWF0KSB7CiAgICAgIGNvbnN0IHNpZGVzID0gc2l4VGFyZ2V0VmVjdG9yczsKICAgICAgY29uc3QgZXggPSB0aGlzLmhhbGZFeHRlbnRzOwogICAgICBzaWRlc1swXS5zZXQoZXgueCwgMCwgMCk7CiAgICAgIHNpZGVzWzFdLnNldCgwLCBleC55LCAwKTsKICAgICAgc2lkZXNbMl0uc2V0KDAsIDAsIGV4LnopOwogICAgICBzaWRlc1szXS5zZXQoLWV4LngsIDAsIDApOwogICAgICBzaWRlc1s0XS5zZXQoMCwgLWV4LnksIDApOwogICAgICBzaWRlc1s1XS5zZXQoMCwgMCwgLWV4LnopOwoKICAgICAgaWYgKHF1YXQgIT09IHVuZGVmaW5lZCkgewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBzaWRlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgcXVhdC52bXVsdChzaWRlc1tpXSwgc2lkZXNbaV0pOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHNpZGVzOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSB2b2x1bWUgb2YgdGhlIGJveC4KICAgICAqLwoKCiAgICB2b2x1bWUoKSB7CiAgICAgIHJldHVybiA4LjAgKiB0aGlzLmhhbGZFeHRlbnRzLnggKiB0aGlzLmhhbGZFeHRlbnRzLnkgKiB0aGlzLmhhbGZFeHRlbnRzLno7CiAgICB9CiAgICAvKioKICAgICAqIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzCiAgICAgKi8KCgogICAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7CiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSB0aGlzLmhhbGZFeHRlbnRzLmxlbmd0aCgpOwogICAgfQogICAgLyoqCiAgICAgKiBmb3JFYWNoV29ybGRDb3JuZXIKICAgICAqLwoKCiAgICBmb3JFYWNoV29ybGRDb3JuZXIocG9zLCBxdWF0LCBjYWxsYmFjaykgewogICAgICBjb25zdCBlID0gdGhpcy5oYWxmRXh0ZW50czsKICAgICAgY29uc3QgY29ybmVycyA9IFtbZS54LCBlLnksIGUuel0sIFstZS54LCBlLnksIGUuel0sIFstZS54LCAtZS55LCBlLnpdLCBbLWUueCwgLWUueSwgLWUuel0sIFtlLngsIC1lLnksIC1lLnpdLCBbZS54LCBlLnksIC1lLnpdLCBbLWUueCwgZS55LCAtZS56XSwgW2UueCwgLWUueSwgZS56XV07CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcm5lcnMubGVuZ3RoOyBpKyspIHsKICAgICAgICB3b3JsZENvcm5lclRlbXBQb3Muc2V0KGNvcm5lcnNbaV1bMF0sIGNvcm5lcnNbaV1bMV0sIGNvcm5lcnNbaV1bMl0pOwogICAgICAgIHF1YXQudm11bHQod29ybGRDb3JuZXJUZW1wUG9zLCB3b3JsZENvcm5lclRlbXBQb3MpOwogICAgICAgIHBvcy52YWRkKHdvcmxkQ29ybmVyVGVtcFBvcywgd29ybGRDb3JuZXJUZW1wUG9zKTsKICAgICAgICBjYWxsYmFjayh3b3JsZENvcm5lclRlbXBQb3MueCwgd29ybGRDb3JuZXJUZW1wUG9zLnksIHdvcmxkQ29ybmVyVGVtcFBvcy56KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBjYWxjdWxhdGVXb3JsZEFBQkIKICAgICAqLwoKCiAgICBjYWxjdWxhdGVXb3JsZEFBQkIocG9zLCBxdWF0LCBtaW4sIG1heCkgewogICAgICBjb25zdCBlID0gdGhpcy5oYWxmRXh0ZW50czsKICAgICAgd29ybGRDb3JuZXJzVGVtcFswXS5zZXQoZS54LCBlLnksIGUueik7CiAgICAgIHdvcmxkQ29ybmVyc1RlbXBbMV0uc2V0KC1lLngsIGUueSwgZS56KTsKICAgICAgd29ybGRDb3JuZXJzVGVtcFsyXS5zZXQoLWUueCwgLWUueSwgZS56KTsKICAgICAgd29ybGRDb3JuZXJzVGVtcFszXS5zZXQoLWUueCwgLWUueSwgLWUueik7CiAgICAgIHdvcmxkQ29ybmVyc1RlbXBbNF0uc2V0KGUueCwgLWUueSwgLWUueik7CiAgICAgIHdvcmxkQ29ybmVyc1RlbXBbNV0uc2V0KGUueCwgZS55LCAtZS56KTsKICAgICAgd29ybGRDb3JuZXJzVGVtcFs2XS5zZXQoLWUueCwgZS55LCAtZS56KTsKICAgICAgd29ybGRDb3JuZXJzVGVtcFs3XS5zZXQoZS54LCAtZS55LCBlLnopOwogICAgICBjb25zdCB3YyA9IHdvcmxkQ29ybmVyc1RlbXBbMF07CiAgICAgIHF1YXQudm11bHQod2MsIHdjKTsKICAgICAgcG9zLnZhZGQod2MsIHdjKTsKICAgICAgbWF4LmNvcHkod2MpOwogICAgICBtaW4uY29weSh3Yyk7CgogICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykgewogICAgICAgIGNvbnN0IHdjID0gd29ybGRDb3JuZXJzVGVtcFtpXTsKICAgICAgICBxdWF0LnZtdWx0KHdjLCB3Yyk7CiAgICAgICAgcG9zLnZhZGQod2MsIHdjKTsKICAgICAgICBjb25zdCB4ID0gd2MueDsKICAgICAgICBjb25zdCB5ID0gd2MueTsKICAgICAgICBjb25zdCB6ID0gd2MuejsKCiAgICAgICAgaWYgKHggPiBtYXgueCkgewogICAgICAgICAgbWF4LnggPSB4OwogICAgICAgIH0KCiAgICAgICAgaWYgKHkgPiBtYXgueSkgewogICAgICAgICAgbWF4LnkgPSB5OwogICAgICAgIH0KCiAgICAgICAgaWYgKHogPiBtYXgueikgewogICAgICAgICAgbWF4LnogPSB6OwogICAgICAgIH0KCiAgICAgICAgaWYgKHggPCBtaW4ueCkgewogICAgICAgICAgbWluLnggPSB4OwogICAgICAgIH0KCiAgICAgICAgaWYgKHkgPCBtaW4ueSkgewogICAgICAgICAgbWluLnkgPSB5OwogICAgICAgIH0KCiAgICAgICAgaWYgKHogPCBtaW4ueikgewogICAgICAgICAgbWluLnogPSB6OwogICAgICAgIH0KICAgICAgfSAvLyBHZXQgZWFjaCBheGlzIG1heAogICAgICAvLyBtaW4uc2V0KEluZmluaXR5LEluZmluaXR5LEluZmluaXR5KTsKICAgICAgLy8gbWF4LnNldCgtSW5maW5pdHksLUluZmluaXR5LC1JbmZpbml0eSk7CiAgICAgIC8vIHRoaXMuZm9yRWFjaFdvcmxkQ29ybmVyKHBvcyxxdWF0LGZ1bmN0aW9uKHgseSx6KXsKICAgICAgLy8gICAgIGlmKHggPiBtYXgueCl7CiAgICAgIC8vICAgICAgICAgbWF4LnggPSB4OwogICAgICAvLyAgICAgfQogICAgICAvLyAgICAgaWYoeSA+IG1heC55KXsKICAgICAgLy8gICAgICAgICBtYXgueSA9IHk7CiAgICAgIC8vICAgICB9CiAgICAgIC8vICAgICBpZih6ID4gbWF4LnopewogICAgICAvLyAgICAgICAgIG1heC56ID0gejsKICAgICAgLy8gICAgIH0KICAgICAgLy8gICAgIGlmKHggPCBtaW4ueCl7CiAgICAgIC8vICAgICAgICAgbWluLnggPSB4OwogICAgICAvLyAgICAgfQogICAgICAvLyAgICAgaWYoeSA8IG1pbi55KXsKICAgICAgLy8gICAgICAgICBtaW4ueSA9IHk7CiAgICAgIC8vICAgICB9CiAgICAgIC8vICAgICBpZih6IDwgbWluLnopewogICAgICAvLyAgICAgICAgIG1pbi56ID0gejsKICAgICAgLy8gICAgIH0KICAgICAgLy8gfSk7CgogICAgfQoKICB9CiAgY29uc3Qgd29ybGRDb3JuZXJUZW1wUG9zID0gbmV3IFZlYzMoKTsKICBjb25zdCB3b3JsZENvcm5lcnNUZW1wID0gW25ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCksIG5ldyBWZWMzKCldOwoKICAvKioKICAgKiBCT0RZX1RZUEVTCiAgICovCiAgY29uc3QgQk9EWV9UWVBFUyA9IHsKICAgIC8qKiBEWU5BTUlDICovCiAgICBEWU5BTUlDOiAxLAoKICAgIC8qKiBTVEFUSUMgKi8KICAgIFNUQVRJQzogMiwKCiAgICAvKiogS0lORU1BVElDICovCiAgICBLSU5FTUFUSUM6IDQKICB9OwogIC8qKgogICAqIEJvZHlUeXBlCiAgICovCgogIC8qKgogICAqIEJPRFlfU0xFRVBfU1RBVEVTCiAgICovCiAgY29uc3QgQk9EWV9TTEVFUF9TVEFURVMgPSB7CiAgICAvKiogQVdBS0UgKi8KICAgIEFXQUtFOiAwLAoKICAgIC8qKiBTTEVFUFkgKi8KICAgIFNMRUVQWTogMSwKCiAgICAvKiogU0xFRVBJTkcgKi8KICAgIFNMRUVQSU5HOiAyCiAgfTsKICAvKioKICAgKiBCb2R5U2xlZXBTdGF0ZQogICAqLwoKICAvKioKICAgKiBCYXNlIGNsYXNzIGZvciBhbGwgYm9keSB0eXBlcy4KICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCBzaGFwZSA9IG5ldyBDQU5OT04uU3BoZXJlKDEpCiAgICogICAgIGNvbnN0IGJvZHkgPSBuZXcgQ0FOTk9OLkJvZHkoewogICAqICAgICAgIG1hc3M6IDEsCiAgICogICAgICAgc2hhcGUsCiAgICogICAgIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSkKICAgKi8KICBjbGFzcyBCb2R5IGV4dGVuZHMgRXZlbnRUYXJnZXQgewogICAgLyoqCiAgICAgKiBEaXNwYXRjaGVkIGFmdGVyIHR3byBib2RpZXMgY29sbGlkZS4gVGhpcyBldmVudCBpcyBkaXNwYXRjaGVkIG9uIGVhY2gKICAgICAqIG9mIHRoZSB0d28gYm9kaWVzIGludm9sdmVkIGluIHRoZSBjb2xsaXNpb24uCiAgICAgKiBAZXZlbnQgY29sbGlkZQogICAgICogQHBhcmFtIGJvZHkgVGhlIGJvZHkgdGhhdCB3YXMgaW52b2x2ZWQgaW4gdGhlIGNvbGxpc2lvbi4KICAgICAqIEBwYXJhbSBjb250YWN0IFRoZSBkZXRhaWxzIG9mIHRoZSBjb2xsaXNpb24uCiAgICAgKi8KCiAgICAvKioKICAgICAqIEEgZHluYW1pYyBib2R5IGlzIGZ1bGx5IHNpbXVsYXRlZC4gQ2FuIGJlIG1vdmVkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLCBidXQgbm9ybWFsbHkgdGhleSBtb3ZlIGFjY29yZGluZyB0byBmb3JjZXMuIEEgZHluYW1pYyBib2R5IGNhbiBjb2xsaWRlIHdpdGggYWxsIGJvZHkgdHlwZXMuIEEgZHluYW1pYyBib2R5IGFsd2F5cyBoYXMgZmluaXRlLCBub24temVybyBtYXNzLgogICAgICovCgogICAgLyoqCiAgICAgKiBBIHN0YXRpYyBib2R5IGRvZXMgbm90IG1vdmUgZHVyaW5nIHNpbXVsYXRpb24gYW5kIGJlaGF2ZXMgYXMgaWYgaXQgaGFzIGluZmluaXRlIG1hc3MuIFN0YXRpYyBib2RpZXMgY2FuIGJlIG1vdmVkIG1hbnVhbGx5IGJ5IHNldHRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5LiBUaGUgdmVsb2NpdHkgb2YgYSBzdGF0aWMgYm9keSBpcyBhbHdheXMgemVyby4gU3RhdGljIGJvZGllcyBkbyBub3QgY29sbGlkZSB3aXRoIG90aGVyIHN0YXRpYyBvciBraW5lbWF0aWMgYm9kaWVzLgogICAgICovCgogICAgLyoqCiAgICAgKiBBIGtpbmVtYXRpYyBib2R5IG1vdmVzIHVuZGVyIHNpbXVsYXRpb24gYWNjb3JkaW5nIHRvIGl0cyB2ZWxvY2l0eS4gVGhleSBkbyBub3QgcmVzcG9uZCB0byBmb3JjZXMuIFRoZXkgY2FuIGJlIG1vdmVkIG1hbnVhbGx5LCBidXQgbm9ybWFsbHkgYSBraW5lbWF0aWMgYm9keSBpcyBtb3ZlZCBieSBzZXR0aW5nIGl0cyB2ZWxvY2l0eS4gQSBraW5lbWF0aWMgYm9keSBiZWhhdmVzIGFzIGlmIGl0IGhhcyBpbmZpbml0ZSBtYXNzLiBLaW5lbWF0aWMgYm9kaWVzIGRvIG5vdCBjb2xsaWRlIHdpdGggb3RoZXIgc3RhdGljIG9yIGtpbmVtYXRpYyBib2RpZXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEFXQUtFCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNMRUVQWQogICAgICovCgogICAgLyoqCiAgICAgKiBTTEVFUElORwogICAgICovCgogICAgLyoqCiAgICAgKiBEaXNwYXRjaGVkIGFmdGVyIGEgc2xlZXBpbmcgYm9keSBoYXMgd29rZW4gdXAuCiAgICAgKiBAZXZlbnQgd2FrZXVwCiAgICAgKi8KCiAgICAvKioKICAgICAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBnb25lIGluIHRvIHRoZSBzbGVlcHkgc3RhdGUuCiAgICAgKiBAZXZlbnQgc2xlZXB5CiAgICAgKi8KCiAgICAvKioKICAgICAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBmYWxsZW4gYXNsZWVwLgogICAgICogQGV2ZW50IHNsZWVwCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgc3VwZXIoKTsKICAgICAgdGhpcy5pZCA9IEJvZHkuaWRDb3VudGVyKys7CiAgICAgIHRoaXMuaW5kZXggPSAtMTsKICAgICAgdGhpcy53b3JsZCA9IG51bGw7CiAgICAgIHRoaXMudmxhbWJkYSA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2Ygb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9PT0gJ251bWJlcicgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogMTsKICAgICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gdHlwZW9mIG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayA9PT0gJ251bWJlcicgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2sgOiAtMTsKICAgICAgdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IHR5cGVvZiBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlIDogdHJ1ZTsKICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24gPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmluaXRQb3NpdGlvbiA9IG5ldyBWZWMzKCk7CgogICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbikgewogICAgICAgIHRoaXMucG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTsKICAgICAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTsKICAgICAgICB0aGlzLmludGVycG9sYXRlZFBvc2l0aW9uLmNvcHkob3B0aW9ucy5wb3NpdGlvbik7CiAgICAgICAgdGhpcy5pbml0UG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTsKICAgICAgfQoKICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWMzKCk7CgogICAgICBpZiAob3B0aW9ucy52ZWxvY2l0eSkgewogICAgICAgIHRoaXMudmVsb2NpdHkuY29weShvcHRpb25zLnZlbG9jaXR5KTsKICAgICAgfQoKICAgICAgdGhpcy5pbml0VmVsb2NpdHkgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmZvcmNlID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgbWFzcyA9IHR5cGVvZiBvcHRpb25zLm1hc3MgPT09ICdudW1iZXInID8gb3B0aW9ucy5tYXNzIDogMDsKICAgICAgdGhpcy5tYXNzID0gbWFzczsKICAgICAgdGhpcy5pbnZNYXNzID0gbWFzcyA+IDAgPyAxLjAgLyBtYXNzIDogMDsKICAgICAgdGhpcy5tYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWwgfHwgbnVsbDsKICAgICAgdGhpcy5saW5lYXJEYW1waW5nID0gdHlwZW9mIG9wdGlvbnMubGluZWFyRGFtcGluZyA9PT0gJ251bWJlcicgPyBvcHRpb25zLmxpbmVhckRhbXBpbmcgOiAwLjAxOwogICAgICB0aGlzLnR5cGUgPSBtYXNzIDw9IDAuMCA/IEJvZHkuU1RBVElDIDogQm9keS5EWU5BTUlDOwoKICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnR5cGUgPT09IHR5cGVvZiBCb2R5LlNUQVRJQykgewogICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTsKICAgICAgfQoKICAgICAgdGhpcy5hbGxvd1NsZWVwID0gdHlwZW9mIG9wdGlvbnMuYWxsb3dTbGVlcCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFsbG93U2xlZXAgOiB0cnVlOwogICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LkFXQUtFOwogICAgICB0aGlzLnNsZWVwU3BlZWRMaW1pdCA9IHR5cGVvZiBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCA6IDAuMTsKICAgICAgdGhpcy5zbGVlcFRpbWVMaW1pdCA9IHR5cGVvZiBvcHRpb25zLnNsZWVwVGltZUxpbWl0ICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuc2xlZXBUaW1lTGltaXQgOiAxOwogICAgICB0aGlzLnRpbWVMYXN0U2xlZXB5ID0gMDsKICAgICAgdGhpcy53YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7CiAgICAgIHRoaXMudG9ycXVlID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTsKICAgICAgdGhpcy5pbml0UXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgICAgIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTsKICAgICAgdGhpcy5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTsKCiAgICAgIGlmIChvcHRpb25zLnF1YXRlcm5pb24pIHsKICAgICAgICB0aGlzLnF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pOwogICAgICAgIHRoaXMuaW5pdFF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pOwogICAgICAgIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uLmNvcHkob3B0aW9ucy5xdWF0ZXJuaW9uKTsKICAgICAgICB0aGlzLmludGVycG9sYXRlZFF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pOwogICAgICB9CgogICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWMzKCk7CgogICAgICBpZiAob3B0aW9ucy5hbmd1bGFyVmVsb2NpdHkpIHsKICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5KTsKICAgICAgfQoKICAgICAgdGhpcy5pbml0QW5ndWxhclZlbG9jaXR5ID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5zaGFwZXMgPSBbXTsKICAgICAgdGhpcy5zaGFwZU9mZnNldHMgPSBbXTsKICAgICAgdGhpcy5zaGFwZU9yaWVudGF0aW9ucyA9IFtdOwogICAgICB0aGlzLmluZXJ0aWEgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmludkluZXJ0aWEgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmludkluZXJ0aWFXb3JsZCA9IG5ldyBNYXQzKCk7CiAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDsKICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlID0gbmV3IE1hdDMoKTsKICAgICAgdGhpcy5maXhlZFJvdGF0aW9uID0gdHlwZW9mIG9wdGlvbnMuZml4ZWRSb3RhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmZpeGVkUm90YXRpb24gOiBmYWxzZTsKICAgICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IHR5cGVvZiBvcHRpb25zLmFuZ3VsYXJEYW1waW5nICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYW5ndWxhckRhbXBpbmcgOiAwLjAxOwogICAgICB0aGlzLmxpbmVhckZhY3RvciA9IG5ldyBWZWMzKDEsIDEsIDEpOwoKICAgICAgaWYgKG9wdGlvbnMubGluZWFyRmFjdG9yKSB7CiAgICAgICAgdGhpcy5saW5lYXJGYWN0b3IuY29weShvcHRpb25zLmxpbmVhckZhY3Rvcik7CiAgICAgIH0KCiAgICAgIHRoaXMuYW5ndWxhckZhY3RvciA9IG5ldyBWZWMzKDEsIDEsIDEpOwoKICAgICAgaWYgKG9wdGlvbnMuYW5ndWxhckZhY3RvcikgewogICAgICAgIHRoaXMuYW5ndWxhckZhY3Rvci5jb3B5KG9wdGlvbnMuYW5ndWxhckZhY3Rvcik7CiAgICAgIH0KCiAgICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7CiAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTsKICAgICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7CiAgICAgIHRoaXMud2xhbWJkYSA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuaXNUcmlnZ2VyID0gQm9vbGVhbihvcHRpb25zLmlzVHJpZ2dlcik7CgogICAgICBpZiAob3B0aW9ucy5zaGFwZSkgewogICAgICAgIHRoaXMuYWRkU2hhcGUob3B0aW9ucy5zaGFwZSk7CiAgICAgIH0KCiAgICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTsKICAgIH0KICAgIC8qKgogICAgICogV2FrZSB0aGUgYm9keSB1cC4KICAgICAqLwoKCiAgICB3YWtlVXAoKSB7CiAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc2xlZXBTdGF0ZTsKICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTsKICAgICAgdGhpcy53YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7CgogICAgICBpZiAocHJldlN0YXRlID09PSBCb2R5LlNMRUVQSU5HKSB7CiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEJvZHkud2FrZXVwRXZlbnQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEZvcmNlIGJvZHkgc2xlZXAKICAgICAqLwoKCiAgICBzbGVlcCgpIHsKICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUElORzsKICAgICAgdGhpcy52ZWxvY2l0eS5zZXQoMCwgMCwgMCk7CiAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LnNldCgwLCAwLCAwKTsKICAgICAgdGhpcy53YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7CiAgICB9CiAgICAvKioKICAgICAqIENhbGxlZCBldmVyeSB0aW1lc3RlcCB0byB1cGRhdGUgaW50ZXJuYWwgc2xlZXAgdGltZXIgYW5kIGNoYW5nZSBzbGVlcCBzdGF0ZSBpZiBuZWVkZWQuCiAgICAgKiBAcGFyYW0gdGltZSBUaGUgd29ybGQgdGltZSBpbiBzZWNvbmRzCiAgICAgKi8KCgogICAgc2xlZXBUaWNrKHRpbWUpIHsKICAgICAgaWYgKHRoaXMuYWxsb3dTbGVlcCkgewogICAgICAgIGNvbnN0IHNsZWVwU3RhdGUgPSB0aGlzLnNsZWVwU3RhdGU7CiAgICAgICAgY29uc3Qgc3BlZWRTcXVhcmVkID0gdGhpcy52ZWxvY2l0eS5sZW5ndGhTcXVhcmVkKCkgKyB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5sZW5ndGhTcXVhcmVkKCk7CiAgICAgICAgY29uc3Qgc3BlZWRMaW1pdFNxdWFyZWQgPSB0aGlzLnNsZWVwU3BlZWRMaW1pdCAqKiAyOwoKICAgICAgICBpZiAoc2xlZXBTdGF0ZSA9PT0gQm9keS5BV0FLRSAmJiBzcGVlZFNxdWFyZWQgPCBzcGVlZExpbWl0U3F1YXJlZCkgewogICAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUFk7IC8vIFNsZWVweQoKICAgICAgICAgIHRoaXMudGltZUxhc3RTbGVlcHkgPSB0aW1lOwogICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEJvZHkuc2xlZXB5RXZlbnQpOwogICAgICAgIH0gZWxzZSBpZiAoc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUFkgJiYgc3BlZWRTcXVhcmVkID4gc3BlZWRMaW1pdFNxdWFyZWQpIHsKICAgICAgICAgIHRoaXMud2FrZVVwKCk7IC8vIFdha2UgdXAKICAgICAgICB9IGVsc2UgaWYgKHNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBZICYmIHRpbWUgLSB0aGlzLnRpbWVMYXN0U2xlZXB5ID4gdGhpcy5zbGVlcFRpbWVMaW1pdCkgewogICAgICAgICAgdGhpcy5zbGVlcCgpOyAvLyBTbGVlcGluZwoKICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChCb2R5LnNsZWVwRXZlbnQpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBJZiB0aGUgYm9keSBpcyBzbGVlcGluZywgaXQgc2hvdWxkIGJlIGltbW92YWJsZSAvIGhhdmUgaW5maW5pdGUgbWFzcyBkdXJpbmcgc29sdmUuIFdlIHNvbHZlIGl0IGJ5IGhhdmluZyBhIHNlcGFyYXRlICJzb2x2ZSBtYXNzIi4KICAgICAqLwoKCiAgICB1cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCkgewogICAgICBpZiAodGhpcy5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpIHsKICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7CiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUuc2V0WmVybygpOwogICAgICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUuc2V0WmVybygpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gdGhpcy5pbnZNYXNzOwogICAgICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhKTsKICAgICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhV29ybGQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnQgYSB3b3JsZCBwb2ludCB0byBsb2NhbCBib2R5IGZyYW1lLgogICAgICovCgoKICAgIHBvaW50VG9Mb2NhbEZyYW1lKHdvcmxkUG9pbnQsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB3b3JsZFBvaW50LnZzdWIodGhpcy5wb3NpdGlvbiwgcmVzdWx0KTsKICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgpLnZtdWx0KHJlc3VsdCwgcmVzdWx0KTsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydCBhIHdvcmxkIHZlY3RvciB0byBsb2NhbCBib2R5IGZyYW1lLgogICAgICovCgoKICAgIHZlY3RvclRvTG9jYWxGcmFtZSh3b3JsZFZlY3RvciwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHRoaXMucXVhdGVybmlvbi5jb25qdWdhdGUoKS52bXVsdCh3b3JsZFZlY3RvciwgcmVzdWx0KTsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydCBhIGxvY2FsIGJvZHkgcG9pbnQgdG8gd29ybGQgZnJhbWUuCiAgICAgKi8KCgogICAgcG9pbnRUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHRoaXMucXVhdGVybmlvbi52bXVsdChsb2NhbFBvaW50LCByZXN1bHQpOwogICAgICByZXN1bHQudmFkZCh0aGlzLnBvc2l0aW9uLCByZXN1bHQpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0IGEgbG9jYWwgYm9keSBwb2ludCB0byB3b3JsZCBmcmFtZS4KICAgICAqLwoKCiAgICB2ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxWZWN0b3IsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxWZWN0b3IsIHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIEFkZCBhIHNoYXBlIHRvIHRoZSBib2R5IHdpdGggYSBsb2NhbCBvZmZzZXQgYW5kIG9yaWVudGF0aW9uLgogICAgICogQHJldHVybiBUaGUgYm9keSBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuCiAgICAgKi8KCgogICAgYWRkU2hhcGUoc2hhcGUsIF9vZmZzZXQsIF9vcmllbnRhdGlvbikgewogICAgICBjb25zdCBvZmZzZXQgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBvcmllbnRhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7CgogICAgICBpZiAoX29mZnNldCkgewogICAgICAgIG9mZnNldC5jb3B5KF9vZmZzZXQpOwogICAgICB9CgogICAgICBpZiAoX29yaWVudGF0aW9uKSB7CiAgICAgICAgb3JpZW50YXRpb24uY29weShfb3JpZW50YXRpb24pOwogICAgICB9CgogICAgICB0aGlzLnNoYXBlcy5wdXNoKHNoYXBlKTsKICAgICAgdGhpcy5zaGFwZU9mZnNldHMucHVzaChvZmZzZXQpOwogICAgICB0aGlzLnNoYXBlT3JpZW50YXRpb25zLnB1c2gob3JpZW50YXRpb24pOwogICAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7CiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTsKICAgICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlOwogICAgICBzaGFwZS5ib2R5ID0gdGhpczsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZSBhIHNoYXBlIGZyb20gdGhlIGJvZHkuCiAgICAgKiBAcmV0dXJuIFRoZSBib2R5IG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS4KICAgICAqLwoKCiAgICByZW1vdmVTaGFwZShzaGFwZSkgewogICAgICBjb25zdCBpbmRleCA9IHRoaXMuc2hhcGVzLmluZGV4T2Yoc2hhcGUpOwoKICAgICAgaWYgKGluZGV4ID09PSAtMSkgewogICAgICAgIGNvbnNvbGUud2FybignU2hhcGUgZG9lcyBub3QgYmVsb25nIHRvIHRoZSBib2R5Jyk7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0KCiAgICAgIHRoaXMuc2hhcGVzLnNwbGljZShpbmRleCwgMSk7CiAgICAgIHRoaXMuc2hhcGVPZmZzZXRzLnNwbGljZShpbmRleCwgMSk7CiAgICAgIHRoaXMuc2hhcGVPcmllbnRhdGlvbnMuc3BsaWNlKGluZGV4LCAxKTsKICAgICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpOwogICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7CiAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTsKICAgICAgc2hhcGUuYm9keSA9IG51bGw7CiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgYm9keS4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBzaGFwZXMgYXJlIGNoYW5nZWQuCiAgICAgKi8KCgogICAgdXBkYXRlQm91bmRpbmdSYWRpdXMoKSB7CiAgICAgIGNvbnN0IHNoYXBlcyA9IHRoaXMuc2hhcGVzOwogICAgICBjb25zdCBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0czsKICAgICAgY29uc3QgTiA9IHNoYXBlcy5sZW5ndGg7CiAgICAgIGxldCByYWRpdXMgPSAwOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIGNvbnN0IHNoYXBlID0gc2hhcGVzW2ldOwogICAgICAgIHNoYXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7CiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc2hhcGVPZmZzZXRzW2ldLmxlbmd0aCgpOwogICAgICAgIGNvbnN0IHIgPSBzaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1czsKCiAgICAgICAgaWYgKG9mZnNldCArIHIgPiByYWRpdXMpIHsKICAgICAgICAgIHJhZGl1cyA9IG9mZnNldCArIHI7CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gcmFkaXVzOwogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGVzIHRoZSAuYWFiYgogICAgICovCgoKICAgIHVwZGF0ZUFBQkIoKSB7CiAgICAgIGNvbnN0IHNoYXBlcyA9IHRoaXMuc2hhcGVzOwogICAgICBjb25zdCBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0czsKICAgICAgY29uc3Qgc2hhcGVPcmllbnRhdGlvbnMgPSB0aGlzLnNoYXBlT3JpZW50YXRpb25zOwogICAgICBjb25zdCBOID0gc2hhcGVzLmxlbmd0aDsKICAgICAgY29uc3Qgb2Zmc2V0ID0gdG1wVmVjOwogICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRtcFF1YXQ7CiAgICAgIGNvbnN0IGJvZHlRdWF0ID0gdGhpcy5xdWF0ZXJuaW9uOwogICAgICBjb25zdCBhYWJiID0gdGhpcy5hYWJiOwogICAgICBjb25zdCBzaGFwZUFBQkIgPSB1cGRhdGVBQUJCX3NoYXBlQUFCQjsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOOyBpKyspIHsKICAgICAgICBjb25zdCBzaGFwZSA9IHNoYXBlc1tpXTsgLy8gR2V0IHNoYXBlIHdvcmxkIHBvc2l0aW9uCgogICAgICAgIGJvZHlRdWF0LnZtdWx0KHNoYXBlT2Zmc2V0c1tpXSwgb2Zmc2V0KTsKICAgICAgICBvZmZzZXQudmFkZCh0aGlzLnBvc2l0aW9uLCBvZmZzZXQpOyAvLyBHZXQgc2hhcGUgd29ybGQgcXVhdGVybmlvbgoKICAgICAgICBib2R5UXVhdC5tdWx0KHNoYXBlT3JpZW50YXRpb25zW2ldLCBvcmllbnRhdGlvbik7IC8vIEdldCBzaGFwZSBBQUJCCgogICAgICAgIHNoYXBlLmNhbGN1bGF0ZVdvcmxkQUFCQihvZmZzZXQsIG9yaWVudGF0aW9uLCBzaGFwZUFBQkIubG93ZXJCb3VuZCwgc2hhcGVBQUJCLnVwcGVyQm91bmQpOwoKICAgICAgICBpZiAoaSA9PT0gMCkgewogICAgICAgICAgYWFiYi5jb3B5KHNoYXBlQUFCQik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGFhYmIuZXh0ZW5kKHNoYXBlQUFCQik7CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IGZhbHNlOwogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGUgYC5pbmVydGlhV29ybGRgIGFuZCBgLmludkluZXJ0aWFXb3JsZGAKICAgICAqLwoKCiAgICB1cGRhdGVJbmVydGlhV29ybGQoZm9yY2UpIHsKICAgICAgY29uc3QgSSA9IHRoaXMuaW52SW5lcnRpYTsKCiAgICAgIGlmIChJLnggPT09IEkueSAmJiBJLnkgPT09IEkueiAmJiAhZm9yY2UpIDsgZWxzZSB7CiAgICAgICAgY29uc3QgbTEgPSB1aXdfbTE7CiAgICAgICAgY29uc3QgbTIgPSB1aXdfbTI7CiAgICAgICAgbTEuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pOwogICAgICAgIG0xLnRyYW5zcG9zZShtMik7CiAgICAgICAgbTEuc2NhbGUoSSwgbTEpOwogICAgICAgIG0xLm1tdWx0KG0yLCB0aGlzLmludkluZXJ0aWFXb3JsZCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQXBwbHkgZm9yY2UgdG8gYSBwb2ludCBvZiB0aGUgYm9keS4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBCb2R5IHN1cmZhY2UuCiAgICAgKiBBcHBseWluZyBmb3JjZSB0aGlzIHdheSB3aWxsIGFkZCB0byBCb2R5LmZvcmNlIGFuZCBCb2R5LnRvcnF1ZS4KICAgICAqIEBwYXJhbSBmb3JjZSBUaGUgYW1vdW50IG9mIGZvcmNlIHRvIGFkZC4KICAgICAqIEBwYXJhbSByZWxhdGl2ZVBvaW50IEEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiBtYXNzIHRvIGFwcGx5IHRoZSBmb3JjZSBvbi4KICAgICAqLwoKCiAgICBhcHBseUZvcmNlKGZvcmNlLCByZWxhdGl2ZVBvaW50KSB7CiAgICAgIGlmIChyZWxhdGl2ZVBvaW50ID09PSB2b2lkIDApIHsKICAgICAgICByZWxhdGl2ZVBvaW50ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgLy8gTmVlZGVkPwogICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpIHsKICAgICAgICB0aGlzLndha2VVcCgpOwogICAgICB9IC8vIENvbXB1dGUgcHJvZHVjZWQgcm90YXRpb25hbCBmb3JjZQoKCiAgICAgIGNvbnN0IHJvdEZvcmNlID0gQm9keV9hcHBseUZvcmNlX3JvdEZvcmNlOwogICAgICByZWxhdGl2ZVBvaW50LmNyb3NzKGZvcmNlLCByb3RGb3JjZSk7IC8vIEFkZCBsaW5lYXIgZm9yY2UKCiAgICAgIHRoaXMuZm9yY2UudmFkZChmb3JjZSwgdGhpcy5mb3JjZSk7IC8vIEFkZCByb3RhdGlvbmFsIGZvcmNlCgogICAgICB0aGlzLnRvcnF1ZS52YWRkKHJvdEZvcmNlLCB0aGlzLnRvcnF1ZSk7CiAgICB9CiAgICAvKioKICAgICAqIEFwcGx5IGZvcmNlIHRvIGEgbG9jYWwgcG9pbnQgaW4gdGhlIGJvZHkuCiAgICAgKiBAcGFyYW0gZm9yY2UgVGhlIGZvcmNlIHZlY3RvciB0byBhcHBseSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSBib2R5IGZyYW1lLgogICAgICogQHBhcmFtIGxvY2FsUG9pbnQgQSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keSB0byBhcHBseSB0aGUgZm9yY2Ugb24uCiAgICAgKi8KCgogICAgYXBwbHlMb2NhbEZvcmNlKGxvY2FsRm9yY2UsIGxvY2FsUG9pbnQpIHsKICAgICAgaWYgKGxvY2FsUG9pbnQgPT09IHZvaWQgMCkgewogICAgICAgIGxvY2FsUG9pbnQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IHdvcmxkRm9yY2UgPSBCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZEZvcmNlOwogICAgICBjb25zdCByZWxhdGl2ZVBvaW50V29ybGQgPSBCb2R5X2FwcGx5TG9jYWxGb3JjZV9yZWxhdGl2ZVBvaW50V29ybGQ7IC8vIFRyYW5zZm9ybSB0aGUgZm9yY2UgdmVjdG9yIHRvIHdvcmxkIHNwYWNlCgogICAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbEZvcmNlLCB3b3JsZEZvcmNlKTsKICAgICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgcmVsYXRpdmVQb2ludFdvcmxkKTsKICAgICAgdGhpcy5hcHBseUZvcmNlKHdvcmxkRm9yY2UsIHJlbGF0aXZlUG9pbnRXb3JsZCk7CiAgICB9CiAgICAvKioKICAgICAqIEFwcGx5IHRvcnF1ZSB0byB0aGUgYm9keS4KICAgICAqIEBwYXJhbSB0b3JxdWUgVGhlIGFtb3VudCBvZiB0b3JxdWUgdG8gYWRkLgogICAgICovCgoKICAgIGFwcGx5VG9ycXVlKHRvcnF1ZSkgewogICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpIHsKICAgICAgICB0aGlzLndha2VVcCgpOwogICAgICB9IC8vIEFkZCByb3RhdGlvbmFsIGZvcmNlCgoKICAgICAgdGhpcy50b3JxdWUudmFkZCh0b3JxdWUsIHRoaXMudG9ycXVlKTsKICAgIH0KICAgIC8qKgogICAgICogQXBwbHkgaW1wdWxzZSB0byBhIHBvaW50IG9mIHRoZSBib2R5LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4KICAgICAqIEFuIGltcHVsc2UgaXMgYSBmb3JjZSBhZGRlZCB0byBhIGJvZHkgZHVyaW5nIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgKGltcHVsc2UgPSBmb3JjZSAqIHRpbWUpLgogICAgICogSW1wdWxzZXMgd2lsbCBiZSBhZGRlZCB0byBCb2R5LnZlbG9jaXR5IGFuZCBCb2R5LmFuZ3VsYXJWZWxvY2l0eS4KICAgICAqIEBwYXJhbSBpbXB1bHNlIFRoZSBhbW91bnQgb2YgaW1wdWxzZSB0byBhZGQuCiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQb2ludCBBIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyB0byBhcHBseSB0aGUgZm9yY2Ugb24uCiAgICAgKi8KCgogICAgYXBwbHlJbXB1bHNlKGltcHVsc2UsIHJlbGF0aXZlUG9pbnQpIHsKICAgICAgaWYgKHJlbGF0aXZlUG9pbnQgPT09IHZvaWQgMCkgewogICAgICAgIHJlbGF0aXZlUG9pbnQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpIHsKICAgICAgICB0aGlzLndha2VVcCgpOwogICAgICB9IC8vIENvbXB1dGUgcG9pbnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJvZHkgY2VudGVyCgoKICAgICAgY29uc3QgciA9IHJlbGF0aXZlUG9pbnQ7IC8vIENvbXB1dGUgcHJvZHVjZWQgY2VudHJhbCBpbXB1bHNlIHZlbG9jaXR5CgogICAgICBjb25zdCB2ZWxvID0gQm9keV9hcHBseUltcHVsc2VfdmVsbzsKICAgICAgdmVsby5jb3B5KGltcHVsc2UpOwogICAgICB2ZWxvLnNjYWxlKHRoaXMuaW52TWFzcywgdmVsbyk7IC8vIEFkZCBsaW5lYXIgaW1wdWxzZQoKICAgICAgdGhpcy52ZWxvY2l0eS52YWRkKHZlbG8sIHRoaXMudmVsb2NpdHkpOyAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgaW1wdWxzZSB2ZWxvY2l0eQoKICAgICAgY29uc3Qgcm90VmVsbyA9IEJvZHlfYXBwbHlJbXB1bHNlX3JvdFZlbG87CiAgICAgIHIuY3Jvc3MoaW1wdWxzZSwgcm90VmVsbyk7CiAgICAgIC8qCiAgICAgICByb3RWZWxvLnggKj0gdGhpcy5pbnZJbmVydGlhLng7CiAgICAgICByb3RWZWxvLnkgKj0gdGhpcy5pbnZJbmVydGlhLnk7CiAgICAgICByb3RWZWxvLnogKj0gdGhpcy5pbnZJbmVydGlhLno7CiAgICAgICAqLwoKICAgICAgdGhpcy5pbnZJbmVydGlhV29ybGQudm11bHQocm90VmVsbywgcm90VmVsbyk7IC8vIEFkZCByb3RhdGlvbmFsIEltcHVsc2UKCiAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LnZhZGQocm90VmVsbywgdGhpcy5hbmd1bGFyVmVsb2NpdHkpOwogICAgfQogICAgLyoqCiAgICAgKiBBcHBseSBsb2NhbGx5LWRlZmluZWQgaW1wdWxzZSB0byBhIGxvY2FsIHBvaW50IGluIHRoZSBib2R5LgogICAgICogQHBhcmFtIGZvcmNlIFRoZSBmb3JjZSB2ZWN0b3IgdG8gYXBwbHksIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgYm9keSBmcmFtZS4KICAgICAqIEBwYXJhbSBsb2NhbFBvaW50IEEgbG9jYWwgcG9pbnQgaW4gdGhlIGJvZHkgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLgogICAgICovCgoKICAgIGFwcGx5TG9jYWxJbXB1bHNlKGxvY2FsSW1wdWxzZSwgbG9jYWxQb2ludCkgewogICAgICBpZiAobG9jYWxQb2ludCA9PT0gdm9pZCAwKSB7CiAgICAgICAgbG9jYWxQb2ludCA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQykgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgY29uc3Qgd29ybGRJbXB1bHNlID0gQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZEltcHVsc2U7CiAgICAgIGNvbnN0IHJlbGF0aXZlUG9pbnRXb3JsZCA9IEJvZHlfYXBwbHlMb2NhbEltcHVsc2VfcmVsYXRpdmVQb2ludDsgLy8gVHJhbnNmb3JtIHRoZSBmb3JjZSB2ZWN0b3IgdG8gd29ybGQgc3BhY2UKCiAgICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKGxvY2FsSW1wdWxzZSwgd29ybGRJbXB1bHNlKTsKICAgICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgcmVsYXRpdmVQb2ludFdvcmxkKTsKICAgICAgdGhpcy5hcHBseUltcHVsc2Uod29ybGRJbXB1bHNlLCByZWxhdGl2ZVBvaW50V29ybGQpOwogICAgfQogICAgLyoqCiAgICAgKiBTaG91bGQgYmUgY2FsbGVkIHdoZW5ldmVyIHlvdSBjaGFuZ2UgdGhlIGJvZHkgc2hhcGUgb3IgbWFzcy4KICAgICAqLwoKCiAgICB1cGRhdGVNYXNzUHJvcGVydGllcygpIHsKICAgICAgY29uc3QgaGFsZkV4dGVudHMgPSBCb2R5X3VwZGF0ZU1hc3NQcm9wZXJ0aWVzX2hhbGZFeHRlbnRzOwogICAgICB0aGlzLmludk1hc3MgPSB0aGlzLm1hc3MgPiAwID8gMS4wIC8gdGhpcy5tYXNzIDogMDsKICAgICAgY29uc3QgSSA9IHRoaXMuaW5lcnRpYTsKICAgICAgY29uc3QgZml4ZWQgPSB0aGlzLmZpeGVkUm90YXRpb247IC8vIEFwcHJveGltYXRlIHdpdGggQUFCQiBib3gKCiAgICAgIHRoaXMudXBkYXRlQUFCQigpOwogICAgICBoYWxmRXh0ZW50cy5zZXQoKHRoaXMuYWFiYi51cHBlckJvdW5kLnggLSB0aGlzLmFhYmIubG93ZXJCb3VuZC54KSAvIDIsICh0aGlzLmFhYmIudXBwZXJCb3VuZC55IC0gdGhpcy5hYWJiLmxvd2VyQm91bmQueSkgLyAyLCAodGhpcy5hYWJiLnVwcGVyQm91bmQueiAtIHRoaXMuYWFiYi5sb3dlckJvdW5kLnopIC8gMik7CiAgICAgIEJveC5jYWxjdWxhdGVJbmVydGlhKGhhbGZFeHRlbnRzLCB0aGlzLm1hc3MsIEkpOwogICAgICB0aGlzLmludkluZXJ0aWEuc2V0KEkueCA+IDAgJiYgIWZpeGVkID8gMS4wIC8gSS54IDogMCwgSS55ID4gMCAmJiAhZml4ZWQgPyAxLjAgLyBJLnkgOiAwLCBJLnogPiAwICYmICFmaXhlZCA/IDEuMCAvIEkueiA6IDApOwogICAgICB0aGlzLnVwZGF0ZUluZXJ0aWFXb3JsZCh0cnVlKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHdvcmxkIHZlbG9jaXR5IG9mIGEgcG9pbnQgaW4gdGhlIGJvZHkuCiAgICAgKiBAcGFyYW0gd29ybGRQb2ludAogICAgICogQHBhcmFtIHJlc3VsdAogICAgICogQHJldHVybiBUaGUgcmVzdWx0IHZlY3Rvci4KICAgICAqLwoKCiAgICBnZXRWZWxvY2l0eUF0V29ybGRQb2ludCh3b3JsZFBvaW50LCByZXN1bHQpIHsKICAgICAgY29uc3QgciA9IG5ldyBWZWMzKCk7CiAgICAgIHdvcmxkUG9pbnQudnN1Yih0aGlzLnBvc2l0aW9uLCByKTsKICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuY3Jvc3MociwgcmVzdWx0KTsKICAgICAgdGhpcy52ZWxvY2l0eS52YWRkKHJlc3VsdCwgcmVzdWx0KTsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogTW92ZSB0aGUgYm9keSBmb3J3YXJkIGluIHRpbWUuCiAgICAgKiBAcGFyYW0gZHQgVGltZSBzdGVwCiAgICAgKiBAcGFyYW0gcXVhdE5vcm1hbGl6ZSBTZXQgdG8gdHJ1ZSB0byBub3JtYWxpemUgdGhlIGJvZHkgcXVhdGVybmlvbgogICAgICogQHBhcmFtIHF1YXROb3JtYWxpemVGYXN0IElmIHRoZSBxdWF0ZXJuaW9uIHNob3VsZCBiZSBub3JtYWxpemVkIHVzaW5nICJmYXN0IiBxdWF0ZXJuaW9uIG5vcm1hbGl6YXRpb24KICAgICAqLwoKCiAgICBpbnRlZ3JhdGUoZHQsIHF1YXROb3JtYWxpemUsIHF1YXROb3JtYWxpemVGYXN0KSB7CiAgICAgIC8vIFNhdmUgcHJldmlvdXMgcG9zaXRpb24KICAgICAgdGhpcy5wcmV2aW91c1Bvc2l0aW9uLmNvcHkodGhpcy5wb3NpdGlvbik7CiAgICAgIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uLmNvcHkodGhpcy5xdWF0ZXJuaW9uKTsKCiAgICAgIGlmICghKHRoaXMudHlwZSA9PT0gQm9keS5EWU5BTUlDIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpIHx8IHRoaXMuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORykgewogICAgICAgIC8vIE9ubHkgZm9yIGR5bmFtaWMKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IHZlbG8gPSB0aGlzLnZlbG9jaXR5OwogICAgICBjb25zdCBhbmd1bGFyVmVsbyA9IHRoaXMuYW5ndWxhclZlbG9jaXR5OwogICAgICBjb25zdCBwb3MgPSB0aGlzLnBvc2l0aW9uOwogICAgICBjb25zdCBmb3JjZSA9IHRoaXMuZm9yY2U7CiAgICAgIGNvbnN0IHRvcnF1ZSA9IHRoaXMudG9ycXVlOwogICAgICBjb25zdCBxdWF0ID0gdGhpcy5xdWF0ZXJuaW9uOwogICAgICBjb25zdCBpbnZNYXNzID0gdGhpcy5pbnZNYXNzOwogICAgICBjb25zdCBpbnZJbmVydGlhID0gdGhpcy5pbnZJbmVydGlhV29ybGQ7CiAgICAgIGNvbnN0IGxpbmVhckZhY3RvciA9IHRoaXMubGluZWFyRmFjdG9yOwogICAgICBjb25zdCBpTWR0ID0gaW52TWFzcyAqIGR0OwogICAgICB2ZWxvLnggKz0gZm9yY2UueCAqIGlNZHQgKiBsaW5lYXJGYWN0b3IueDsKICAgICAgdmVsby55ICs9IGZvcmNlLnkgKiBpTWR0ICogbGluZWFyRmFjdG9yLnk7CiAgICAgIHZlbG8ueiArPSBmb3JjZS56ICogaU1kdCAqIGxpbmVhckZhY3Rvci56OwogICAgICBjb25zdCBlID0gaW52SW5lcnRpYS5lbGVtZW50czsKICAgICAgY29uc3QgYW5ndWxhckZhY3RvciA9IHRoaXMuYW5ndWxhckZhY3RvcjsKICAgICAgY29uc3QgdHggPSB0b3JxdWUueCAqIGFuZ3VsYXJGYWN0b3IueDsKICAgICAgY29uc3QgdHkgPSB0b3JxdWUueSAqIGFuZ3VsYXJGYWN0b3IueTsKICAgICAgY29uc3QgdHogPSB0b3JxdWUueiAqIGFuZ3VsYXJGYWN0b3IuejsKICAgICAgYW5ndWxhclZlbG8ueCArPSBkdCAqIChlWzBdICogdHggKyBlWzFdICogdHkgKyBlWzJdICogdHopOwogICAgICBhbmd1bGFyVmVsby55ICs9IGR0ICogKGVbM10gKiB0eCArIGVbNF0gKiB0eSArIGVbNV0gKiB0eik7CiAgICAgIGFuZ3VsYXJWZWxvLnogKz0gZHQgKiAoZVs2XSAqIHR4ICsgZVs3XSAqIHR5ICsgZVs4XSAqIHR6KTsgLy8gVXNlIG5ldyB2ZWxvY2l0eSAgLSBsZWFwIGZyb2cKCiAgICAgIHBvcy54ICs9IHZlbG8ueCAqIGR0OwogICAgICBwb3MueSArPSB2ZWxvLnkgKiBkdDsKICAgICAgcG9zLnogKz0gdmVsby56ICogZHQ7CiAgICAgIHF1YXQuaW50ZWdyYXRlKHRoaXMuYW5ndWxhclZlbG9jaXR5LCBkdCwgdGhpcy5hbmd1bGFyRmFjdG9yLCBxdWF0KTsKCiAgICAgIGlmIChxdWF0Tm9ybWFsaXplKSB7CiAgICAgICAgaWYgKHF1YXROb3JtYWxpemVGYXN0KSB7CiAgICAgICAgICBxdWF0Lm5vcm1hbGl6ZUZhc3QoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcXVhdC5ub3JtYWxpemUoKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTsgLy8gVXBkYXRlIHdvcmxkIGluZXJ0aWEKCiAgICAgIHRoaXMudXBkYXRlSW5lcnRpYVdvcmxkKCk7CiAgICB9CgogIH0KICBCb2R5LmlkQ291bnRlciA9IDA7CiAgQm9keS5DT0xMSURFX0VWRU5UX05BTUUgPSAnY29sbGlkZSc7CiAgQm9keS5EWU5BTUlDID0gQk9EWV9UWVBFUy5EWU5BTUlDOwogIEJvZHkuU1RBVElDID0gQk9EWV9UWVBFUy5TVEFUSUM7CiAgQm9keS5LSU5FTUFUSUMgPSBCT0RZX1RZUEVTLktJTkVNQVRJQzsKICBCb2R5LkFXQUtFID0gQk9EWV9TTEVFUF9TVEFURVMuQVdBS0U7CiAgQm9keS5TTEVFUFkgPSBCT0RZX1NMRUVQX1NUQVRFUy5TTEVFUFk7CiAgQm9keS5TTEVFUElORyA9IEJPRFlfU0xFRVBfU1RBVEVTLlNMRUVQSU5HOwogIEJvZHkud2FrZXVwRXZlbnQgPSB7CiAgICB0eXBlOiAnd2FrZXVwJwogIH07CiAgQm9keS5zbGVlcHlFdmVudCA9IHsKICAgIHR5cGU6ICdzbGVlcHknCiAgfTsKICBCb2R5LnNsZWVwRXZlbnQgPSB7CiAgICB0eXBlOiAnc2xlZXAnCiAgfTsKICBjb25zdCB0bXBWZWMgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRtcFF1YXQgPSBuZXcgUXVhdGVybmlvbigpOwogIGNvbnN0IHVwZGF0ZUFBQkJfc2hhcGVBQUJCID0gbmV3IEFBQkIoKTsKICBjb25zdCB1aXdfbTEgPSBuZXcgTWF0MygpOwogIGNvbnN0IHVpd19tMiA9IG5ldyBNYXQzKCk7CiAgbmV3IE1hdDMoKTsKICBjb25zdCBCb2R5X2FwcGx5Rm9yY2Vfcm90Rm9yY2UgPSBuZXcgVmVjMygpOwogIGNvbnN0IEJvZHlfYXBwbHlMb2NhbEZvcmNlX3dvcmxkRm9yY2UgPSBuZXcgVmVjMygpOwogIGNvbnN0IEJvZHlfYXBwbHlMb2NhbEZvcmNlX3JlbGF0aXZlUG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQm9keV9hcHBseUltcHVsc2VfdmVsbyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQm9keV9hcHBseUltcHVsc2Vfcm90VmVsbyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZEltcHVsc2UgPSBuZXcgVmVjMygpOwogIGNvbnN0IEJvZHlfYXBwbHlMb2NhbEltcHVsc2VfcmVsYXRpdmVQb2ludCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQm9keV91cGRhdGVNYXNzUHJvcGVydGllc19oYWxmRXh0ZW50cyA9IG5ldyBWZWMzKCk7CgogIC8qKgogICAqIEJhc2UgY2xhc3MgZm9yIGJyb2FkcGhhc2UgaW1wbGVtZW50YXRpb25zCiAgICogQGF1dGhvciBzY2h0ZXBwZQogICAqLwogIGNsYXNzIEJyb2FkcGhhc2UgewogICAgLyoqCiAgICAgKiBUaGUgd29ybGQgdG8gc2VhcmNoIGZvciBjb2xsaXNpb25zIGluLgogICAgICovCgogICAgLyoqCiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGJyb2FkcGhhc2UgdXNlcyBib3VuZGluZyBib3hlcyBmb3IgaW50ZXJzZWN0aW9uIHRlc3RzLCBlbHNlIGl0IHVzZXMgYm91bmRpbmcgc3BoZXJlcy4KICAgICAqLwoKICAgIC8qKgogICAgICogU2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdHMgaW4gdGhlIHdvcmxkIG1vdmVkLgogICAgICovCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgdGhpcy53b3JsZCA9IG51bGw7CiAgICAgIHRoaXMudXNlQm91bmRpbmdCb3hlcyA9IGZhbHNlOwogICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSBjb2xsaXNpb24gcGFpcnMgZnJvbSB0aGUgd29ybGQKICAgICAqIEBwYXJhbSB3b3JsZCBUaGUgd29ybGQgdG8gc2VhcmNoIGluCiAgICAgKiBAcGFyYW0gcDEgRW1wdHkgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggYm9keSBvYmplY3RzCiAgICAgKiBAcGFyYW0gcDIgRW1wdHkgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggYm9keSBvYmplY3RzCiAgICAgKi8KCgogICAgY29sbGlzaW9uUGFpcnMod29ybGQsIHAxLCBwMikgewogICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbGxpc2lvblBhaXJzIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhpcyBCcm9hZFBoYXNlIGNsYXNzIScpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVjayBpZiBhIGJvZHkgcGFpciBuZWVkcyB0byBiZSBpbnRlcnNlY3Rpb24gdGVzdGVkIGF0IGFsbC4KICAgICAqLwoKCiAgICBuZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihib2R5QSwgYm9keUIpIHsKICAgICAgLy8gQ2hlY2sgY29sbGlzaW9uIGZpbHRlciBtYXNrcwogICAgICBpZiAoKGJvZHlBLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keUIuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09IDAgfHwgKGJvZHlCLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keUEuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09IDApIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gLy8gQ2hlY2sgdHlwZXMKCgogICAgICBpZiAoKChib2R5QS50eXBlICYgQm9keS5TVEFUSUMpICE9PSAwIHx8IGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpICYmICgoYm9keUIudHlwZSAmIEJvZHkuU1RBVElDKSAhPT0gMCB8fCBib2R5Qi5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HKSkgewogICAgICAgIC8vIEJvdGggYm9kaWVzIGFyZSBzdGF0aWMgb3Igc2xlZXBpbmcuIFNraXAuCiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHZvbHVtZXMgb2YgdHdvIGJvZGllcyBpbnRlcnNlY3QuCiAgICAgKi8KCgogICAgaW50ZXJzZWN0aW9uVGVzdChib2R5QSwgYm9keUIsIHBhaXJzMSwgcGFpcnMyKSB7CiAgICAgIGlmICh0aGlzLnVzZUJvdW5kaW5nQm94ZXMpIHsKICAgICAgICB0aGlzLmRvQm91bmRpbmdCb3hCcm9hZHBoYXNlKGJvZHlBLCBib2R5QiwgcGFpcnMxLCBwYWlyczIpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuZG9Cb3VuZGluZ1NwaGVyZUJyb2FkcGhhc2UoYm9keUEsIGJvZHlCLCBwYWlyczEsIHBhaXJzMik7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHNwaGVyZXMgb2YgdHdvIGJvZGllcyBhcmUgaW50ZXJzZWN0aW5nLgogICAgICogQHBhcmFtIHBhaXJzMSBib2R5QSBpcyBhcHBlbmRlZCB0byB0aGlzIGFycmF5IGlmIGludGVyc2VjdGlvbgogICAgICogQHBhcmFtIHBhaXJzMiBib2R5QiBpcyBhcHBlbmRlZCB0byB0aGlzIGFycmF5IGlmIGludGVyc2VjdGlvbgogICAgICovCgoKICAgIGRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlKGJvZHlBLCBib2R5QiwgcGFpcnMxLCBwYWlyczIpIHsKICAgICAgY29uc3QgciA9IEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfcjsKICAgICAgYm9keUIucG9zaXRpb24udnN1Yihib2R5QS5wb3NpdGlvbiwgcik7CiAgICAgIGNvbnN0IGJvdW5kaW5nUmFkaXVzU3VtMiA9IChib2R5QS5ib3VuZGluZ1JhZGl1cyArIGJvZHlCLmJvdW5kaW5nUmFkaXVzKSAqKiAyOwogICAgICBjb25zdCBub3JtMiA9IHIubGVuZ3RoU3F1YXJlZCgpOwoKICAgICAgaWYgKG5vcm0yIDwgYm91bmRpbmdSYWRpdXNTdW0yKSB7CiAgICAgICAgcGFpcnMxLnB1c2goYm9keUEpOwogICAgICAgIHBhaXJzMi5wdXNoKGJvZHlCKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgYm94ZXMgb2YgdHdvIGJvZGllcyBhcmUgaW50ZXJzZWN0aW5nLgogICAgICovCgoKICAgIGRvQm91bmRpbmdCb3hCcm9hZHBoYXNlKGJvZHlBLCBib2R5QiwgcGFpcnMxLCBwYWlyczIpIHsKICAgICAgaWYgKGJvZHlBLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgIGJvZHlBLnVwZGF0ZUFBQkIoKTsKICAgICAgfQoKICAgICAgaWYgKGJvZHlCLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgIGJvZHlCLnVwZGF0ZUFBQkIoKTsKICAgICAgfSAvLyBDaGVjayBBQUJCIC8gQUFCQgoKCiAgICAgIGlmIChib2R5QS5hYWJiLm92ZXJsYXBzKGJvZHlCLmFhYmIpKSB7CiAgICAgICAgcGFpcnMxLnB1c2goYm9keUEpOwogICAgICAgIHBhaXJzMi5wdXNoKGJvZHlCKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGR1cGxpY2F0ZSBwYWlycyBmcm9tIHRoZSBwYWlyIGFycmF5cy4KICAgICAqLwoKCiAgICBtYWtlUGFpcnNVbmlxdWUocGFpcnMxLCBwYWlyczIpIHsKICAgICAgY29uc3QgdCA9IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3RlbXA7CiAgICAgIGNvbnN0IHAxID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDE7CiAgICAgIGNvbnN0IHAyID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDI7CiAgICAgIGNvbnN0IE4gPSBwYWlyczEubGVuZ3RoOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIHAxW2ldID0gcGFpcnMxW2ldOwogICAgICAgIHAyW2ldID0gcGFpcnMyW2ldOwogICAgICB9CgogICAgICBwYWlyczEubGVuZ3RoID0gMDsKICAgICAgcGFpcnMyLmxlbmd0aCA9IDA7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgY29uc3QgaWQxID0gcDFbaV0uaWQ7CiAgICAgICAgY29uc3QgaWQyID0gcDJbaV0uaWQ7CiAgICAgICAgY29uc3Qga2V5ID0gaWQxIDwgaWQyID8gYCR7aWQxfSwke2lkMn1gIDogYCR7aWQyfSwke2lkMX1gOwogICAgICAgIHRba2V5XSA9IGk7CiAgICAgICAgdC5rZXlzLnB1c2goa2V5KTsKICAgICAgfQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IHQua2V5cy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGtleSA9IHQua2V5cy5wb3AoKTsKICAgICAgICBjb25zdCBwYWlySW5kZXggPSB0W2tleV07CiAgICAgICAgcGFpcnMxLnB1c2gocDFbcGFpckluZGV4XSk7CiAgICAgICAgcGFpcnMyLnB1c2gocDJbcGFpckluZGV4XSk7CiAgICAgICAgZGVsZXRlIHRba2V5XTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBUbyBiZSBpbXBsZW1lbnRlZCBieSBzdWJjYXNzZXMKICAgICAqLwoKCiAgICBzZXRXb3JsZCh3b3JsZCkge30KICAgIC8qKgogICAgICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHNwaGVyZXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLgogICAgICovCgoKICAgIHN0YXRpYyBib3VuZGluZ1NwaGVyZUNoZWNrKGJvZHlBLCBib2R5QikgewogICAgICBjb25zdCBkaXN0ID0gbmV3IFZlYzMoKTsgLy8gYnNjX2Rpc3Q7CgogICAgICBib2R5QS5wb3NpdGlvbi52c3ViKGJvZHlCLnBvc2l0aW9uLCBkaXN0KTsKICAgICAgY29uc3Qgc2EgPSBib2R5QS5zaGFwZXNbMF07CiAgICAgIGNvbnN0IHNiID0gYm9keUIuc2hhcGVzWzBdOwogICAgICByZXR1cm4gTWF0aC5wb3coc2EuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzYi5ib3VuZGluZ1NwaGVyZVJhZGl1cywgMikgPiBkaXN0Lmxlbmd0aFNxdWFyZWQoKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gdGhlIEFBQkIuCiAgICAgKi8KCgogICAgYWFiYlF1ZXJ5KHdvcmxkLCBhYWJiLCByZXN1bHQpIHsKICAgICAgY29uc29sZS53YXJuKCcuYWFiYlF1ZXJ5IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIEJyb2FkcGhhc2Ugc3ViY2xhc3MuJyk7CiAgICAgIHJldHVybiBbXTsKICAgIH0KCiAgfSAvLyBUZW1wIG9iamVjdHMKCiAgY29uc3QgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yID0gbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIG5ldyBRdWF0ZXJuaW9uKCk7CiAgbmV3IFZlYzMoKTsKICBjb25zdCBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV90ZW1wID0gewogICAga2V5czogW10KICB9OwogIGNvbnN0IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AxID0gW107CiAgY29uc3QgQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDIgPSBbXTsKICBuZXcgVmVjMygpOwogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogTmFpdmUgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbiwgdXNlZCBpbiBsYWNrIG9mIGJldHRlciBvbmVzLgogICAqCiAgICogVGhlIG5haXZlIGJyb2FkcGhhc2UgbG9va3MgYXQgYWxsIHBvc3NpYmxlIHBhaXJzIHdpdGhvdXQgcmVzdHJpY3Rpb24sIHRoZXJlZm9yZSBpdCBoYXMgY29tcGxleGl0eSBOXjIgXyh3aGljaCBpcyBiYWQpXwogICAqLwogIGNsYXNzIE5haXZlQnJvYWRwaGFzZSBleHRlbmRzIEJyb2FkcGhhc2UgewogICAgLyoqCiAgICAgKiBAdG9kbyBSZW1vdmUgdXNlbGVzcyBjb25zdHJ1Y3RvcgogICAgICovCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgc3VwZXIoKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGFsbCB0aGUgY29sbGlzaW9uIHBhaXJzIGluIHRoZSBwaHlzaWNzIHdvcmxkCiAgICAgKi8KCgogICAgY29sbGlzaW9uUGFpcnMod29ybGQsIHBhaXJzMSwgcGFpcnMyKSB7CiAgICAgIGNvbnN0IGJvZGllcyA9IHdvcmxkLmJvZGllczsKICAgICAgY29uc3QgbiA9IGJvZGllcy5sZW5ndGg7CiAgICAgIGxldCBiaTsKICAgICAgbGV0IGJqOyAvLyBOYWl2ZSBOXjIgZnR3IQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IG47IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBpOyBqKyspIHsKICAgICAgICAgIGJpID0gYm9kaWVzW2ldOwogICAgICAgICAgYmogPSBib2RpZXNbal07CgogICAgICAgICAgaWYgKCF0aGlzLm5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uKGJpLCBiaikpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CgogICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25UZXN0KGJpLCBiaiwgcGFpcnMxLCBwYWlyczIpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLgogICAgICogQHBhcmFtIHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLgogICAgICovCgoKICAgIGFhYmJRdWVyeSh3b3JsZCwgYWFiYiwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IFtdOwogICAgICB9CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmxkLmJvZGllcy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGIgPSB3b3JsZC5ib2RpZXNbaV07CgogICAgICAgIGlmIChiLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgICAgYi51cGRhdGVBQUJCKCk7CiAgICAgICAgfSAvLyBVZ2x5IGhhY2sgdW50aWwgQm9keSBnZXRzIGFhYmIKCgogICAgICAgIGlmIChiLmFhYmIub3ZlcmxhcHMoYWFiYikpIHsKICAgICAgICAgIHJlc3VsdC5wdXNoKGIpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KCiAgfQoKICAvKioKICAgKiBTdG9yYWdlIGZvciBSYXkgY2FzdGluZyBkYXRhCiAgICovCiAgY2xhc3MgUmF5Y2FzdFJlc3VsdCB7CiAgICAvKioKICAgICAqIHJheUZyb21Xb3JsZAogICAgICovCgogICAgLyoqCiAgICAgKiByYXlUb1dvcmxkCiAgICAgKi8KCiAgICAvKioKICAgICAqIGhpdE5vcm1hbFdvcmxkCiAgICAgKi8KCiAgICAvKioKICAgICAqIGhpdFBvaW50V29ybGQKICAgICAqLwoKICAgIC8qKgogICAgICogaGFzSGl0CiAgICAgKi8KCiAgICAvKioKICAgICAqIHNoYXBlCiAgICAgKi8KCiAgICAvKioKICAgICAqIGJvZHkKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGluZGV4IG9mIHRoZSBoaXQgdHJpYW5nbGUsIGlmIHRoZSBoaXQgc2hhcGUgd2FzIGEgdHJpbWVzaAogICAgICovCgogICAgLyoqCiAgICAgKiBEaXN0YW5jZSB0byB0aGUgaGl0LiBXaWxsIGJlIHNldCB0byAtMSBpZiB0aGVyZSB3YXMgbm8gaGl0CiAgICAgKi8KCiAgICAvKioKICAgICAqIElmIHRoZSByYXkgc2hvdWxkIHN0b3AgdHJhdmVyc2luZyB0aGUgYm9kaWVzCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKCkgewogICAgICB0aGlzLnJheUZyb21Xb3JsZCA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMucmF5VG9Xb3JsZCA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuaGl0Tm9ybWFsV29ybGQgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmhpdFBvaW50V29ybGQgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmhhc0hpdCA9IGZhbHNlOwogICAgICB0aGlzLnNoYXBlID0gbnVsbDsKICAgICAgdGhpcy5ib2R5ID0gbnVsbDsKICAgICAgdGhpcy5oaXRGYWNlSW5kZXggPSAtMTsKICAgICAgdGhpcy5kaXN0YW5jZSA9IC0xOwogICAgICB0aGlzLnNob3VsZFN0b3AgPSBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogUmVzZXQgYWxsIHJlc3VsdCBkYXRhLgogICAgICovCgoKICAgIHJlc2V0KCkgewogICAgICB0aGlzLnJheUZyb21Xb3JsZC5zZXRaZXJvKCk7CiAgICAgIHRoaXMucmF5VG9Xb3JsZC5zZXRaZXJvKCk7CiAgICAgIHRoaXMuaGl0Tm9ybWFsV29ybGQuc2V0WmVybygpOwogICAgICB0aGlzLmhpdFBvaW50V29ybGQuc2V0WmVybygpOwogICAgICB0aGlzLmhhc0hpdCA9IGZhbHNlOwogICAgICB0aGlzLnNoYXBlID0gbnVsbDsKICAgICAgdGhpcy5ib2R5ID0gbnVsbDsKICAgICAgdGhpcy5oaXRGYWNlSW5kZXggPSAtMTsKICAgICAgdGhpcy5kaXN0YW5jZSA9IC0xOwogICAgICB0aGlzLnNob3VsZFN0b3AgPSBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogYWJvcnQKICAgICAqLwoKCiAgICBhYm9ydCgpIHsKICAgICAgdGhpcy5zaG91bGRTdG9wID0gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHJlc3VsdCBkYXRhLgogICAgICovCgoKICAgIHNldChyYXlGcm9tV29ybGQsIHJheVRvV29ybGQsIGhpdE5vcm1hbFdvcmxkLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgZGlzdGFuY2UpIHsKICAgICAgdGhpcy5yYXlGcm9tV29ybGQuY29weShyYXlGcm9tV29ybGQpOwogICAgICB0aGlzLnJheVRvV29ybGQuY29weShyYXlUb1dvcmxkKTsKICAgICAgdGhpcy5oaXROb3JtYWxXb3JsZC5jb3B5KGhpdE5vcm1hbFdvcmxkKTsKICAgICAgdGhpcy5oaXRQb2ludFdvcmxkLmNvcHkoaGl0UG9pbnRXb3JsZCk7CiAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZTsKICAgICAgdGhpcy5ib2R5ID0gYm9keTsKICAgICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlOwogICAgfQoKICB9CgogIGxldCBfU2hhcGUkdHlwZXMkU1BIRVJFLCBfU2hhcGUkdHlwZXMkUExBTkUsIF9TaGFwZSR0eXBlcyRCT1gsIF9TaGFwZSR0eXBlcyRDWUxJTkRFUiwgX1NoYXBlJHR5cGVzJENPTlZFWFBPLCBfU2hhcGUkdHlwZXMkSEVJR0hURkksIF9TaGFwZSR0eXBlcyRUUklNRVNIOwoKICAvKioKICAgKiBSQVlfTU9ERVMKICAgKi8KICBjb25zdCBSQVlfTU9ERVMgPSB7CiAgICAvKiogQ0xPU0VTVCAqLwogICAgQ0xPU0VTVDogMSwKCiAgICAvKiogQU5ZICovCiAgICBBTlk6IDIsCgogICAgLyoqIEFMTCAqLwogICAgQUxMOiA0CiAgfTsKICAvKioKICAgKiBSYXlNb2RlCiAgICovCgogIF9TaGFwZSR0eXBlcyRTUEhFUkUgPSBTaGFwZS50eXBlcy5TUEhFUkU7CiAgX1NoYXBlJHR5cGVzJFBMQU5FID0gU2hhcGUudHlwZXMuUExBTkU7CiAgX1NoYXBlJHR5cGVzJEJPWCA9IFNoYXBlLnR5cGVzLkJPWDsKICBfU2hhcGUkdHlwZXMkQ1lMSU5ERVIgPSBTaGFwZS50eXBlcy5DWUxJTkRFUjsKICBfU2hhcGUkdHlwZXMkQ09OVkVYUE8gPSBTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OOwogIF9TaGFwZSR0eXBlcyRIRUlHSFRGSSA9IFNoYXBlLnR5cGVzLkhFSUdIVEZJRUxEOwogIF9TaGFwZSR0eXBlcyRUUklNRVNIID0gU2hhcGUudHlwZXMuVFJJTUVTSDsKCiAgLyoqCiAgICogQSBsaW5lIGluIDNEIHNwYWNlIHRoYXQgaW50ZXJzZWN0cyBib2RpZXMgYW5kIHJldHVybiBwb2ludHMuCiAgICovCiAgY2xhc3MgUmF5IHsKICAgIC8qKgogICAgICogZnJvbQogICAgICovCgogICAgLyoqCiAgICAgKiB0bwogICAgICovCgogICAgLyoqCiAgICAgKiBkaXJlY3Rpb24KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIHByZWNpc2lvbiBvZiB0aGUgcmF5LiBVc2VkIHdoZW4gY2hlY2tpbmcgcGFyYWxsZWxpdHkgZXRjLgogICAgICogQGRlZmF1bHQgMC4wMDAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNldCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBSYXkgdG8gdGFrZSBgY29sbGlzaW9uUmVzcG9uc2VgIGZsYWdzIGludG8gYWNjb3VudCBvbiBib2RpZXMgYW5kIHNoYXBlcy4KICAgICAqIEBkZWZhdWx0IHRydWUKICAgICAqLwoKICAgIC8qKgogICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHJheSBza2lwcyBhbnkgaGl0cyB3aXRoIG5vcm1hbC5kb3QocmF5RGlyZWN0aW9uKSA8IDAuCiAgICAgKiBAZGVmYXVsdCBmYWxzZQogICAgICovCgogICAgLyoqCiAgICAgKiBjb2xsaXNpb25GaWx0ZXJNYXNrCiAgICAgKiBAZGVmYXVsdCAtMQogICAgICovCgogICAgLyoqCiAgICAgKiBjb2xsaXNpb25GaWx0ZXJHcm91cAogICAgICogQGRlZmF1bHQgLTEKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGludGVyc2VjdGlvbiBtb2RlLiBTaG91bGQgYmUgUmF5LkFOWSwgUmF5LkFMTCBvciBSYXkuQ0xPU0VTVC4KICAgICAqIEBkZWZhdWx0IFJBWS5BTlkKICAgICAqLwoKICAgIC8qKgogICAgICogQ3VycmVudCByZXN1bHQgb2JqZWN0LgogICAgICovCgogICAgLyoqCiAgICAgKiBXaWxsIGJlIHNldCB0byBgdHJ1ZWAgZHVyaW5nIGludGVyc2VjdFdvcmxkKCkgaWYgdGhlIHJheSBoaXQgYW55dGhpbmcuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFVzZXItcHJvdmlkZWQgcmVzdWx0IGNhbGxiYWNrLiBXaWxsIGJlIHVzZWQgaWYgbW9kZSBpcyBSYXkuQUxMLgogICAgICovCgogICAgLyoqCiAgICAgKiBDTE9TRVNUCiAgICAgKi8KCiAgICAvKioKICAgICAqIEFOWQogICAgICovCgogICAgLyoqCiAgICAgKiBBTEwKICAgICAqLwogICAgZ2V0IFtfU2hhcGUkdHlwZXMkU1BIRVJFXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdFNwaGVyZTsKICAgIH0KCiAgICBnZXQgW19TaGFwZSR0eXBlcyRQTEFORV0oKSB7CiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnNlY3RQbGFuZTsKICAgIH0KCiAgICBnZXQgW19TaGFwZSR0eXBlcyRCT1hdKCkgewogICAgICByZXR1cm4gdGhpcy5faW50ZXJzZWN0Qm94OwogICAgfQoKICAgIGdldCBbX1NoYXBlJHR5cGVzJENZTElOREVSXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdENvbnZleDsKICAgIH0KCiAgICBnZXQgW19TaGFwZSR0eXBlcyRDT05WRVhQT10oKSB7CiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnNlY3RDb252ZXg7CiAgICB9CgogICAgZ2V0IFtfU2hhcGUkdHlwZXMkSEVJR0hURkldKCkgewogICAgICByZXR1cm4gdGhpcy5faW50ZXJzZWN0SGVpZ2h0ZmllbGQ7CiAgICB9CgogICAgZ2V0IFtfU2hhcGUkdHlwZXMkVFJJTUVTSF0oKSB7CiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnNlY3RUcmltZXNoOwogICAgfQoKICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7CiAgICAgIGlmIChmcm9tID09PSB2b2lkIDApIHsKICAgICAgICBmcm9tID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsKICAgICAgICB0byA9IG5ldyBWZWMzKCk7CiAgICAgIH0KCiAgICAgIHRoaXMuZnJvbSA9IGZyb20uY2xvbmUoKTsKICAgICAgdGhpcy50byA9IHRvLmNsb25lKCk7CiAgICAgIHRoaXMuZGlyZWN0aW9uID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5wcmVjaXNpb24gPSAwLjAwMDE7CiAgICAgIHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRydWU7CiAgICAgIHRoaXMuc2tpcEJhY2tmYWNlcyA9IGZhbHNlOwogICAgICB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2sgPSAtMTsKICAgICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IC0xOwogICAgICB0aGlzLm1vZGUgPSBSYXkuQU5ZOwogICAgICB0aGlzLnJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7CiAgICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7CgogICAgICB0aGlzLmNhbGxiYWNrID0gcmVzdWx0ID0+IHt9OwogICAgfQogICAgLyoqCiAgICAgKiBEbyBpdGVyc2VjdGlvbiBhZ2FpbnN0IGFsbCBib2RpZXMgaW4gdGhlIGdpdmVuIFdvcmxkLgogICAgICogQHJldHVybiBUcnVlIGlmIHRoZSByYXkgaGl0IGFueXRoaW5nLCBvdGhlcndpc2UgZmFsc2UuCiAgICAgKi8KCgogICAgaW50ZXJzZWN0V29ybGQod29ybGQsIG9wdGlvbnMpIHsKICAgICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IFJheS5BTlk7CiAgICAgIHRoaXMucmVzdWx0ID0gb3B0aW9ucy5yZXN1bHQgfHwgbmV3IFJheWNhc3RSZXN1bHQoKTsKICAgICAgdGhpcy5za2lwQmFja2ZhY2VzID0gISFvcHRpb25zLnNraXBCYWNrZmFjZXM7CiAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IHR5cGVvZiBvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2sgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrIDogLTE7CiAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2Ygb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogLTE7CiAgICAgIHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHR5cGVvZiBvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlIDogdHJ1ZTsKCiAgICAgIGlmIChvcHRpb25zLmZyb20pIHsKICAgICAgICB0aGlzLmZyb20uY29weShvcHRpb25zLmZyb20pOwogICAgICB9CgogICAgICBpZiAob3B0aW9ucy50bykgewogICAgICAgIHRoaXMudG8uY29weShvcHRpb25zLnRvKTsKICAgICAgfQoKICAgICAgdGhpcy5jYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgKCgpID0+IHt9KTsKCiAgICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7CiAgICAgIHRoaXMucmVzdWx0LnJlc2V0KCk7CiAgICAgIHRoaXMudXBkYXRlRGlyZWN0aW9uKCk7CiAgICAgIHRoaXMuZ2V0QUFCQih0bXBBQUJCJDEpOwogICAgICB0bXBBcnJheS5sZW5ndGggPSAwOwogICAgICB3b3JsZC5icm9hZHBoYXNlLmFhYmJRdWVyeSh3b3JsZCwgdG1wQUFCQiQxLCB0bXBBcnJheSk7CiAgICAgIHRoaXMuaW50ZXJzZWN0Qm9kaWVzKHRtcEFycmF5KTsKICAgICAgcmV0dXJuIHRoaXMuaGFzSGl0OwogICAgfQogICAgLyoqCiAgICAgKiBTaG9vdCBhIHJheSBhdCBhIGJvZHksIGdldCBiYWNrIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXQuCiAgICAgKiBAZGVwcmVjYXRlZCBAcGFyYW0gcmVzdWx0IHNldCB0aGUgcmVzdWx0IHByb3BlcnR5IG9mIHRoZSBSYXkgaW5zdGVhZC4KICAgICAqLwoKCiAgICBpbnRlcnNlY3RCb2R5KGJvZHksIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0KSB7CiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7CiAgICAgICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTsKICAgICAgfQoKICAgICAgY29uc3QgY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZTsKCiAgICAgIGlmIChjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFib2R5LmNvbGxpc2lvblJlc3BvbnNlKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBpZiAoKHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiBib2R5LmNvbGxpc2lvbkZpbHRlck1hc2spID09PSAwIHx8IChib2R5LmNvbGxpc2lvbkZpbHRlckdyb3VwICYgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrKSA9PT0gMCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgY29uc3QgeGkgPSBpbnRlcnNlY3RCb2R5X3hpOwogICAgICBjb25zdCBxaSA9IGludGVyc2VjdEJvZHlfcWk7CgogICAgICBmb3IgKGxldCBpID0gMCwgTiA9IGJvZHkuc2hhcGVzLmxlbmd0aDsgaSA8IE47IGkrKykgewogICAgICAgIGNvbnN0IHNoYXBlID0gYm9keS5zaGFwZXNbaV07CgogICAgICAgIGlmIChjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFzaGFwZS5jb2xsaXNpb25SZXNwb25zZSkgewogICAgICAgICAgY29udGludWU7IC8vIFNraXAKICAgICAgICB9CgogICAgICAgIGJvZHkucXVhdGVybmlvbi5tdWx0KGJvZHkuc2hhcGVPcmllbnRhdGlvbnNbaV0sIHFpKTsKICAgICAgICBib2R5LnF1YXRlcm5pb24udm11bHQoYm9keS5zaGFwZU9mZnNldHNbaV0sIHhpKTsKICAgICAgICB4aS52YWRkKGJvZHkucG9zaXRpb24sIHhpKTsKICAgICAgICB0aGlzLmludGVyc2VjdFNoYXBlKHNoYXBlLCBxaSwgeGksIGJvZHkpOwoKICAgICAgICBpZiAodGhpcy5yZXN1bHQuc2hvdWxkU3RvcCkgewogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFNob290IGEgcmF5IGF0IGFuIGFycmF5IGJvZGllcywgZ2V0IGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdC4KICAgICAqIEBwYXJhbSBib2RpZXMgQW4gYXJyYXkgb2YgQm9keSBvYmplY3RzLgogICAgICogQGRlcHJlY2F0ZWQgQHBhcmFtIHJlc3VsdCBzZXQgdGhlIHJlc3VsdCBwcm9wZXJ0eSBvZiB0aGUgUmF5IGluc3RlYWQuCiAgICAgKgogICAgICovCgoKICAgIGludGVyc2VjdEJvZGllcyhib2RpZXMsIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0KSB7CiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7CiAgICAgICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTsKICAgICAgfQoKICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBib2RpZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuc2hvdWxkU3RvcCAmJiBpIDwgbDsgaSsrKSB7CiAgICAgICAgdGhpcy5pbnRlcnNlY3RCb2R5KGJvZGllc1tpXSk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlcyB0aGUgZGlyZWN0aW9uIHZlY3Rvci4KICAgICAqLwoKCiAgICB1cGRhdGVEaXJlY3Rpb24oKSB7CiAgICAgIHRoaXMudG8udnN1Yih0aGlzLmZyb20sIHRoaXMuZGlyZWN0aW9uKTsKICAgICAgdGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7CiAgICB9CgogICAgaW50ZXJzZWN0U2hhcGUoc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5KSB7CiAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb207IC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlCgogICAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbihmcm9tLCB0aGlzLmRpcmVjdGlvbiwgcG9zaXRpb24pOwoKICAgICAgaWYgKGRpc3RhbmNlID4gc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IGludGVyc2VjdE1ldGhvZCA9IHRoaXNbc2hhcGUudHlwZV07CgogICAgICBpZiAoaW50ZXJzZWN0TWV0aG9kKSB7CiAgICAgICAgaW50ZXJzZWN0TWV0aG9kLmNhbGwodGhpcywgc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCBzaGFwZSk7CiAgICAgIH0KICAgIH0KCiAgICBfaW50ZXJzZWN0Qm94KGJveCwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpIHsKICAgICAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdENvbnZleChib3guY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSk7CiAgICB9CgogICAgX2ludGVyc2VjdFBsYW5lKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSkgewogICAgICBjb25zdCBmcm9tID0gdGhpcy5mcm9tOwogICAgICBjb25zdCB0byA9IHRoaXMudG87CiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uOyAvLyBHZXQgcGxhbmUgbm9ybWFsCgogICAgICBjb25zdCB3b3JsZE5vcm1hbCA9IG5ldyBWZWMzKDAsIDAsIDEpOwogICAgICBxdWF0LnZtdWx0KHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCk7CiAgICAgIGNvbnN0IGxlbiA9IG5ldyBWZWMzKCk7CiAgICAgIGZyb20udnN1Yihwb3NpdGlvbiwgbGVuKTsKICAgICAgY29uc3QgcGxhbmVUb0Zyb20gPSBsZW4uZG90KHdvcmxkTm9ybWFsKTsKICAgICAgdG8udnN1Yihwb3NpdGlvbiwgbGVuKTsKICAgICAgY29uc3QgcGxhbmVUb1RvID0gbGVuLmRvdCh3b3JsZE5vcm1hbCk7CgogICAgICBpZiAocGxhbmVUb0Zyb20gKiBwbGFuZVRvVG8gPiAwKSB7CiAgICAgICAgLy8gImZyb20iIGFuZCAidG8iIGFyZSBvbiB0aGUgc2FtZSBzaWRlIG9mIHRoZSBwbGFuZS4uLiBiYWlsIG91dAogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgaWYgKGZyb20uZGlzdGFuY2VUbyh0bykgPCBwbGFuZVRvRnJvbSkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgY29uc3Qgbl9kb3RfZGlyID0gd29ybGROb3JtYWwuZG90KGRpcmVjdGlvbik7CgogICAgICBpZiAoTWF0aC5hYnMobl9kb3RfZGlyKSA8IHRoaXMucHJlY2lzaW9uKSB7CiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uCiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBjb25zdCBwbGFuZVBvaW50VG9Gcm9tID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgZGlyX3NjYWxlZF93aXRoX3QgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBoaXRQb2ludFdvcmxkID0gbmV3IFZlYzMoKTsKICAgICAgZnJvbS52c3ViKHBvc2l0aW9uLCBwbGFuZVBvaW50VG9Gcm9tKTsKICAgICAgY29uc3QgdCA9IC13b3JsZE5vcm1hbC5kb3QocGxhbmVQb2ludFRvRnJvbSkgLyBuX2RvdF9kaXI7CiAgICAgIGRpcmVjdGlvbi5zY2FsZSh0LCBkaXJfc2NhbGVkX3dpdGhfdCk7CiAgICAgIGZyb20udmFkZChkaXJfc2NhbGVkX3dpdGhfdCwgaGl0UG9pbnRXb3JsZCk7CiAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsLCBoaXRQb2ludFdvcmxkLCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgd29ybGQgQUFCQiBvZiB0aGUgcmF5LgogICAgICovCgoKICAgIGdldEFBQkIoYWFiYikgewogICAgICBjb25zdCB7CiAgICAgICAgbG93ZXJCb3VuZCwKICAgICAgICB1cHBlckJvdW5kCiAgICAgIH0gPSBhYWJiOwogICAgICBjb25zdCB0byA9IHRoaXMudG87CiAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb207CiAgICAgIGxvd2VyQm91bmQueCA9IE1hdGgubWluKHRvLngsIGZyb20ueCk7CiAgICAgIGxvd2VyQm91bmQueSA9IE1hdGgubWluKHRvLnksIGZyb20ueSk7CiAgICAgIGxvd2VyQm91bmQueiA9IE1hdGgubWluKHRvLnosIGZyb20ueik7CiAgICAgIHVwcGVyQm91bmQueCA9IE1hdGgubWF4KHRvLngsIGZyb20ueCk7CiAgICAgIHVwcGVyQm91bmQueSA9IE1hdGgubWF4KHRvLnksIGZyb20ueSk7CiAgICAgIHVwcGVyQm91bmQueiA9IE1hdGgubWF4KHRvLnosIGZyb20ueik7CiAgICB9CgogICAgX2ludGVyc2VjdEhlaWdodGZpZWxkKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSkgewogICAgICBzaGFwZS5kYXRhOwogICAgICBzaGFwZS5lbGVtZW50U2l6ZTsgLy8gQ29udmVydCB0aGUgcmF5IHRvIGxvY2FsIGhlaWdodGZpZWxkIGNvb3JkaW5hdGVzCgogICAgICBjb25zdCBsb2NhbFJheSA9IGludGVyc2VjdEhlaWdodGZpZWxkX2xvY2FsUmF5OyAvL25ldyBSYXkodGhpcy5mcm9tLCB0aGlzLnRvKTsKCiAgICAgIGxvY2FsUmF5LmZyb20uY29weSh0aGlzLmZyb20pOwogICAgICBsb2NhbFJheS50by5jb3B5KHRoaXMudG8pOwogICAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIGxvY2FsUmF5LmZyb20sIGxvY2FsUmF5LmZyb20pOwogICAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIGxvY2FsUmF5LnRvLCBsb2NhbFJheS50byk7CiAgICAgIGxvY2FsUmF5LnVwZGF0ZURpcmVjdGlvbigpOyAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3QKCiAgICAgIGNvbnN0IGluZGV4ID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfaW5kZXg7CiAgICAgIGxldCBpTWluWDsKICAgICAgbGV0IGlNaW5ZOwogICAgICBsZXQgaU1heFg7CiAgICAgIGxldCBpTWF4WTsgLy8gU2V0IHRvIG1heAoKICAgICAgaU1pblggPSBpTWluWSA9IDA7CiAgICAgIGlNYXhYID0gaU1heFkgPSBzaGFwZS5kYXRhLmxlbmd0aCAtIDE7CiAgICAgIGNvbnN0IGFhYmIgPSBuZXcgQUFCQigpOwogICAgICBsb2NhbFJheS5nZXRBQUJCKGFhYmIpOwogICAgICBzaGFwZS5nZXRJbmRleE9mUG9zaXRpb24oYWFiYi5sb3dlckJvdW5kLngsIGFhYmIubG93ZXJCb3VuZC55LCBpbmRleCwgdHJ1ZSk7CiAgICAgIGlNaW5YID0gTWF0aC5tYXgoaU1pblgsIGluZGV4WzBdKTsKICAgICAgaU1pblkgPSBNYXRoLm1heChpTWluWSwgaW5kZXhbMV0pOwogICAgICBzaGFwZS5nZXRJbmRleE9mUG9zaXRpb24oYWFiYi51cHBlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC55LCBpbmRleCwgdHJ1ZSk7CiAgICAgIGlNYXhYID0gTWF0aC5taW4oaU1heFgsIGluZGV4WzBdICsgMSk7CiAgICAgIGlNYXhZID0gTWF0aC5taW4oaU1heFksIGluZGV4WzFdICsgMSk7CgogICAgICBmb3IgKGxldCBpID0gaU1pblg7IGkgPCBpTWF4WDsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IGlNaW5ZOyBqIDwgaU1heFk7IGorKykgewogICAgICAgICAgaWYgKHRoaXMucmVzdWx0LnNob3VsZFN0b3ApIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQoKICAgICAgICAgIHNoYXBlLmdldEFhYmJBdEluZGV4KGksIGosIGFhYmIpOwoKICAgICAgICAgIGlmICghYWFiYi5vdmVybGFwc1JheShsb2NhbFJheSkpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9IC8vIExvd2VyIHRyaWFuZ2xlCgoKICAgICAgICAgIHNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTsKICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdCwgc2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7CgogICAgICAgICAgdGhpcy5faW50ZXJzZWN0Q29udmV4KHNoYXBlLnBpbGxhckNvbnZleCwgcXVhdCwgd29ybGRQaWxsYXJPZmZzZXQsIGJvZHksIHJlcG9ydGVkU2hhcGUsIGludGVyc2VjdENvbnZleE9wdGlvbnMpOwoKICAgICAgICAgIGlmICh0aGlzLnJlc3VsdC5zaG91bGRTdG9wKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0gLy8gVXBwZXIgdHJpYW5nbGUKCgogICAgICAgICAgc2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgdHJ1ZSk7CiAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHF1YXQsIHNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpOwoKICAgICAgICAgIHRoaXMuX2ludGVyc2VjdENvbnZleChzaGFwZS5waWxsYXJDb252ZXgsIHF1YXQsIHdvcmxkUGlsbGFyT2Zmc2V0LCBib2R5LCByZXBvcnRlZFNoYXBlLCBpbnRlcnNlY3RDb252ZXhPcHRpb25zKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBfaW50ZXJzZWN0U3BoZXJlKHNwaGVyZSwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpIHsKICAgICAgY29uc3QgZnJvbSA9IHRoaXMuZnJvbTsKICAgICAgY29uc3QgdG8gPSB0aGlzLnRvOwogICAgICBjb25zdCByID0gc3BoZXJlLnJhZGl1czsKICAgICAgY29uc3QgYSA9ICh0by54IC0gZnJvbS54KSAqKiAyICsgKHRvLnkgLSBmcm9tLnkpICoqIDIgKyAodG8ueiAtIGZyb20ueikgKiogMjsKICAgICAgY29uc3QgYiA9IDIgKiAoKHRvLnggLSBmcm9tLngpICogKGZyb20ueCAtIHBvc2l0aW9uLngpICsgKHRvLnkgLSBmcm9tLnkpICogKGZyb20ueSAtIHBvc2l0aW9uLnkpICsgKHRvLnogLSBmcm9tLnopICogKGZyb20ueiAtIHBvc2l0aW9uLnopKTsKICAgICAgY29uc3QgYyA9IChmcm9tLnggLSBwb3NpdGlvbi54KSAqKiAyICsgKGZyb20ueSAtIHBvc2l0aW9uLnkpICoqIDIgKyAoZnJvbS56IC0gcG9zaXRpb24ueikgKiogMiAtIHIgKiogMjsKICAgICAgY29uc3QgZGVsdGEgPSBiICoqIDIgLSA0ICogYSAqIGM7CiAgICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50ID0gUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludDsKICAgICAgY29uc3Qgbm9ybWFsID0gUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWw7CgogICAgICBpZiAoZGVsdGEgPCAwKSB7CiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uCiAgICAgICAgcmV0dXJuOwogICAgICB9IGVsc2UgaWYgKGRlbHRhID09PSAwKSB7CiAgICAgICAgLy8gc2luZ2xlIGludGVyc2VjdGlvbiBwb2ludAogICAgICAgIGZyb20ubGVycCh0bywgZGVsdGEsIGludGVyc2VjdGlvblBvaW50KTsKICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpOwogICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTsKICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgZDEgPSAoLWIgLSBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7CiAgICAgICAgY29uc3QgZDIgPSAoLWIgKyBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7CgogICAgICAgIGlmIChkMSA+PSAwICYmIGQxIDw9IDEpIHsKICAgICAgICAgIGZyb20ubGVycCh0bywgZDEsIGludGVyc2VjdGlvblBvaW50KTsKICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7CiAgICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7CiAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7CiAgICAgICAgfQoKICAgICAgICBpZiAodGhpcy5yZXN1bHQuc2hvdWxkU3RvcCkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgaWYgKGQyID49IDAgJiYgZDIgPD0gMSkgewogICAgICAgICAgZnJvbS5sZXJwKHRvLCBkMiwgaW50ZXJzZWN0aW9uUG9pbnQpOwogICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQudnN1Yihwb3NpdGlvbiwgbm9ybWFsKTsKICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTsKICAgICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHJlcG9ydGVkU2hhcGUsIGJvZHksIC0xKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBfaW50ZXJzZWN0Q29udmV4KHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSwgb3B0aW9ucykgewogICAgICBjb25zdCBub3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbm9ybWFsOwogICAgICBjb25zdCB2ZWN0b3IgPSBpbnRlcnNlY3RDb252ZXhfdmVjdG9yOwogICAgICBjb25zdCBmYWNlTGlzdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5mYWNlTGlzdCB8fCBudWxsOyAvLyBDaGVja2luZyBmYWNlcwoKICAgICAgY29uc3QgZmFjZXMgPSBzaGFwZS5mYWNlczsKICAgICAgY29uc3QgdmVydGljZXMgPSBzaGFwZS52ZXJ0aWNlczsKICAgICAgY29uc3Qgbm9ybWFscyA9IHNoYXBlLmZhY2VOb3JtYWxzOwogICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjsKICAgICAgY29uc3QgZnJvbSA9IHRoaXMuZnJvbTsKICAgICAgY29uc3QgdG8gPSB0aGlzLnRvOwogICAgICBjb25zdCBmcm9tVG9EaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyh0byk7CiAgICAgIGNvbnN0IE5mYWNlcyA9IGZhY2VMaXN0ID8gZmFjZUxpc3QubGVuZ3RoIDogZmFjZXMubGVuZ3RoOwogICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdDsKCiAgICAgIGZvciAobGV0IGogPSAwOyAhcmVzdWx0LnNob3VsZFN0b3AgJiYgaiA8IE5mYWNlczsgaisrKSB7CiAgICAgICAgY29uc3QgZmkgPSBmYWNlTGlzdCA/IGZhY2VMaXN0W2pdIDogajsKICAgICAgICBjb25zdCBmYWNlID0gZmFjZXNbZmldOwogICAgICAgIGNvbnN0IGZhY2VOb3JtYWwgPSBub3JtYWxzW2ZpXTsKICAgICAgICBjb25zdCBxID0gcXVhdDsKICAgICAgICBjb25zdCB4ID0gcG9zaXRpb247IC8vIGRldGVybWluZSBpZiByYXkgaW50ZXJzZWN0cyB0aGUgcGxhbmUgb2YgdGhlIGZhY2UKICAgICAgICAvLyBub3RlOiB0aGlzIHdvcmtzIHJlZ2FyZGxlc3Mgb2YgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZmFjZSBub3JtYWwKICAgICAgICAvLyBHZXQgcGxhbmUgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuLi4KCiAgICAgICAgdmVjdG9yLmNvcHkodmVydGljZXNbZmFjZVswXV0pOwogICAgICAgIHEudm11bHQodmVjdG9yLCB2ZWN0b3IpOwogICAgICAgIHZlY3Rvci52YWRkKHgsIHZlY3Rvcik7IC8vIC4uLmJ1dCBtYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSByYXkgZnJvbS4gV2UnbGwgZml4IHRoaXMgbGF0ZXIuCgogICAgICAgIHZlY3Rvci52c3ViKGZyb20sIHZlY3Rvcik7IC8vIEdldCBwbGFuZSBub3JtYWwKCiAgICAgICAgcS52bXVsdChmYWNlTm9ybWFsLCBub3JtYWwpOyAvLyBJZiB0aGlzIGRvdCBwcm9kdWN0IGlzIG5lZ2F0aXZlLCB3ZSBoYXZlIHNvbWV0aGluZyBpbnRlcmVzdGluZwoKICAgICAgICBjb25zdCBkb3QgPSBkaXJlY3Rpb24uZG90KG5vcm1hbCk7IC8vIEJhaWwgb3V0IGlmIHJheSBhbmQgcGxhbmUgYXJlIHBhcmFsbGVsCgogICAgICAgIGlmIChNYXRoLmFicyhkb3QpIDwgdGhpcy5wcmVjaXNpb24pIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0gLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZQoKCiAgICAgICAgY29uc3Qgc2NhbGFyID0gbm9ybWFsLmRvdCh2ZWN0b3IpIC8gZG90OyAvLyBpZiBuZWdhdGl2ZSBkaXN0YW5jZSwgdGhlbiBwbGFuZSBpcyBiZWhpbmQgcmF5CgogICAgICAgIGlmIChzY2FsYXIgPCAwKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9IC8vIGlmIChkb3QgPCAwKSB7CiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXIKCgogICAgICAgIGRpcmVjdGlvbi5zY2FsZShzY2FsYXIsIGludGVyc2VjdFBvaW50KTsKICAgICAgICBpbnRlcnNlY3RQb2ludC52YWRkKGZyb20sIGludGVyc2VjdFBvaW50KTsgLy8gYSBpcyB0aGUgcG9pbnQgd2UgY29tcGFyZSBwb2ludHMgYiBhbmQgYyB3aXRoLgoKICAgICAgICBhLmNvcHkodmVydGljZXNbZmFjZVswXV0pOwogICAgICAgIHEudm11bHQoYSwgYSk7CiAgICAgICAgeC52YWRkKGEsIGEpOwoKICAgICAgICBmb3IgKGxldCBpID0gMTsgIXJlc3VsdC5zaG91bGRTdG9wICYmIGkgPCBmYWNlLmxlbmd0aCAtIDE7IGkrKykgewogICAgICAgICAgLy8gVHJhbnNmb3JtIDMgdmVydGljZXMgdG8gd29ybGQgY29vcmRzCiAgICAgICAgICBiLmNvcHkodmVydGljZXNbZmFjZVtpXV0pOwogICAgICAgICAgYy5jb3B5KHZlcnRpY2VzW2ZhY2VbaSArIDFdXSk7CiAgICAgICAgICBxLnZtdWx0KGIsIGIpOwogICAgICAgICAgcS52bXVsdChjLCBjKTsKICAgICAgICAgIHgudmFkZChiLCBiKTsKICAgICAgICAgIHgudmFkZChjLCBjKTsKICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhmcm9tKTsKCiAgICAgICAgICBpZiAoIShSYXkucG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBhLCBiLCBjKSB8fCBSYXkucG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBiLCBhLCBjKSkgfHwgZGlzdGFuY2UgPiBmcm9tVG9EaXN0YW5jZSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KCiAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdFBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCBmaSk7CiAgICAgICAgfSAvLyB9CgogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEB0b2RvIE9wdGltaXplIGJ5IHRyYW5zZm9ybWluZyB0aGUgd29ybGQgdG8gbG9jYWwgc3BhY2UgZmlyc3QuCiAgICAgKiBAdG9kbyBVc2UgT2N0cmVlIGxvb2t1cAogICAgICovCgoKICAgIF9pbnRlcnNlY3RUcmltZXNoKG1lc2gsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCByZXBvcnRlZFNoYXBlLCBvcHRpb25zKSB7CiAgICAgIGNvbnN0IG5vcm1hbCA9IGludGVyc2VjdFRyaW1lc2hfbm9ybWFsOwogICAgICBjb25zdCB0cmlhbmdsZXMgPSBpbnRlcnNlY3RUcmltZXNoX3RyaWFuZ2xlczsKICAgICAgY29uc3QgdHJlZVRyYW5zZm9ybSA9IGludGVyc2VjdFRyaW1lc2hfdHJlZVRyYW5zZm9ybTsKICAgICAgY29uc3QgdmVjdG9yID0gaW50ZXJzZWN0Q29udmV4X3ZlY3RvcjsKICAgICAgY29uc3QgbG9jYWxEaXJlY3Rpb24gPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uOwogICAgICBjb25zdCBsb2NhbEZyb20gPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRnJvbTsKICAgICAgY29uc3QgbG9jYWxUbyA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxUbzsKICAgICAgY29uc3Qgd29ybGRJbnRlcnNlY3RQb2ludCA9IGludGVyc2VjdFRyaW1lc2hfd29ybGRJbnRlcnNlY3RQb2ludDsKICAgICAgY29uc3Qgd29ybGROb3JtYWwgPSBpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsOyAvLyBDaGVja2luZyBmYWNlcwoKICAgICAgY29uc3QgaW5kaWNlcyA9IG1lc2guaW5kaWNlczsKICAgICAgbWVzaC52ZXJ0aWNlczsgLy8gY29uc3Qgbm9ybWFscyA9IG1lc2guZmFjZU5vcm1hbHMKCiAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb207CiAgICAgIGNvbnN0IHRvID0gdGhpcy50bzsKICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247CiAgICAgIHRyZWVUcmFuc2Zvcm0ucG9zaXRpb24uY29weShwb3NpdGlvbik7CiAgICAgIHRyZWVUcmFuc2Zvcm0ucXVhdGVybmlvbi5jb3B5KHF1YXQpOyAvLyBUcmFuc2Zvcm0gcmF5IHRvIGxvY2FsIHNwYWNlIQoKICAgICAgVHJhbnNmb3JtLnZlY3RvclRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgZGlyZWN0aW9uLCBsb2NhbERpcmVjdGlvbik7CiAgICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgZnJvbSwgbG9jYWxGcm9tKTsKICAgICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCB0bywgbG9jYWxUbyk7CiAgICAgIGxvY2FsVG8ueCAqPSBtZXNoLnNjYWxlLng7CiAgICAgIGxvY2FsVG8ueSAqPSBtZXNoLnNjYWxlLnk7CiAgICAgIGxvY2FsVG8ueiAqPSBtZXNoLnNjYWxlLno7CiAgICAgIGxvY2FsRnJvbS54ICo9IG1lc2guc2NhbGUueDsKICAgICAgbG9jYWxGcm9tLnkgKj0gbWVzaC5zY2FsZS55OwogICAgICBsb2NhbEZyb20ueiAqPSBtZXNoLnNjYWxlLno7CiAgICAgIGxvY2FsVG8udnN1Yihsb2NhbEZyb20sIGxvY2FsRGlyZWN0aW9uKTsKICAgICAgbG9jYWxEaXJlY3Rpb24ubm9ybWFsaXplKCk7CiAgICAgIGNvbnN0IGZyb21Ub0Rpc3RhbmNlU3F1YXJlZCA9IGxvY2FsRnJvbS5kaXN0YW5jZVNxdWFyZWQobG9jYWxUbyk7CiAgICAgIG1lc2gudHJlZS5yYXlRdWVyeSh0aGlzLCB0cmVlVHJhbnNmb3JtLCB0cmlhbmdsZXMpOwoKICAgICAgZm9yIChsZXQgaSA9IDAsIE4gPSB0cmlhbmdsZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuc2hvdWxkU3RvcCAmJiBpICE9PSBOOyBpKyspIHsKICAgICAgICBjb25zdCB0cmlhbmdsZXNJbmRleCA9IHRyaWFuZ2xlc1tpXTsKICAgICAgICBtZXNoLmdldE5vcm1hbCh0cmlhbmdsZXNJbmRleCwgbm9ybWFsKTsgLy8gZGV0ZXJtaW5lIGlmIHJheSBpbnRlcnNlY3RzIHRoZSBwbGFuZSBvZiB0aGUgZmFjZQogICAgICAgIC8vIG5vdGU6IHRoaXMgd29ya3MgcmVnYXJkbGVzcyBvZiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBmYWNlIG5vcm1hbAogICAgICAgIC8vIEdldCBwbGFuZSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy4uLgoKICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogM10sIGEpOyAvLyAuLi5idXQgbWFrZSBpdCByZWxhdGl2ZSB0byB0aGUgcmF5IGZyb20uIFdlJ2xsIGZpeCB0aGlzIGxhdGVyLgoKICAgICAgICBhLnZzdWIobG9jYWxGcm9tLCB2ZWN0b3IpOyAvLyBJZiB0aGlzIGRvdCBwcm9kdWN0IGlzIG5lZ2F0aXZlLCB3ZSBoYXZlIHNvbWV0aGluZyBpbnRlcmVzdGluZwoKICAgICAgICBjb25zdCBkb3QgPSBsb2NhbERpcmVjdGlvbi5kb3Qobm9ybWFsKTsgLy8gQmFpbCBvdXQgaWYgcmF5IGFuZCBwbGFuZSBhcmUgcGFyYWxsZWwKICAgICAgICAvLyBpZiAoTWF0aC5hYnMoIGRvdCApIDwgdGhpcy5wcmVjaXNpb24pewogICAgICAgIC8vICAgICBjb250aW51ZTsKICAgICAgICAvLyB9CiAgICAgICAgLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZQoKICAgICAgICBjb25zdCBzY2FsYXIgPSBub3JtYWwuZG90KHZlY3RvcikgLyBkb3Q7IC8vIGlmIG5lZ2F0aXZlIGRpc3RhbmNlLCB0aGVuIHBsYW5lIGlzIGJlaGluZCByYXkKCiAgICAgICAgaWYgKHNjYWxhciA8IDApIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0gLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXIKCgogICAgICAgIGxvY2FsRGlyZWN0aW9uLnNjYWxlKHNjYWxhciwgaW50ZXJzZWN0UG9pbnQpOwogICAgICAgIGludGVyc2VjdFBvaW50LnZhZGQobG9jYWxGcm9tLCBpbnRlcnNlY3RQb2ludCk7IC8vIEdldCB0cmlhbmdsZSB2ZXJ0aWNlcwoKICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogMyArIDFdLCBiKTsKICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogMyArIDJdLCBjKTsKICAgICAgICBjb25zdCBzcXVhcmVkRGlzdGFuY2UgPSBpbnRlcnNlY3RQb2ludC5kaXN0YW5jZVNxdWFyZWQobG9jYWxGcm9tKTsKCiAgICAgICAgaWYgKCEoUmF5LnBvaW50SW5UcmlhbmdsZShpbnRlcnNlY3RQb2ludCwgYiwgYSwgYykgfHwgUmF5LnBvaW50SW5UcmlhbmdsZShpbnRlcnNlY3RQb2ludCwgYSwgYiwgYykpIHx8IHNxdWFyZWREaXN0YW5jZSA+IGZyb21Ub0Rpc3RhbmNlU3F1YXJlZCkgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfSAvLyB0cmFuc2Zvcm0gaW50ZXJzZWN0cG9pbnQgYW5kIG5vcm1hbCB0byB3b3JsZAoKCiAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZShxdWF0LCBub3JtYWwsIHdvcmxkTm9ybWFsKTsKICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHF1YXQsIGludGVyc2VjdFBvaW50LCB3b3JsZEludGVyc2VjdFBvaW50KTsKICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbih3b3JsZE5vcm1hbCwgd29ybGRJbnRlcnNlY3RQb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgdHJpYW5nbGVzSW5kZXgpOwogICAgICB9CgogICAgICB0cmlhbmdsZXMubGVuZ3RoID0gMDsKICAgIH0KICAgIC8qKgogICAgICogQHJldHVybiBUcnVlIGlmIHRoZSBpbnRlcnNlY3Rpb25zIHNob3VsZCBjb250aW51ZQogICAgICovCgoKICAgIHJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCBoaXRGYWNlSW5kZXgpIHsKICAgICAgY29uc3QgZnJvbSA9IHRoaXMuZnJvbTsKICAgICAgY29uc3QgdG8gPSB0aGlzLnRvOwogICAgICBjb25zdCBkaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyhoaXRQb2ludFdvcmxkKTsKICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7IC8vIFNraXAgYmFjayBmYWNlcz8KCiAgICAgIGlmICh0aGlzLnNraXBCYWNrZmFjZXMgJiYgbm9ybWFsLmRvdCh0aGlzLmRpcmVjdGlvbikgPiAwKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICByZXN1bHQuaGl0RmFjZUluZGV4ID0gdHlwZW9mIGhpdEZhY2VJbmRleCAhPT0gJ3VuZGVmaW5lZCcgPyBoaXRGYWNlSW5kZXggOiAtMTsKCiAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7CiAgICAgICAgY2FzZSBSYXkuQUxMOgogICAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlOwogICAgICAgICAgcmVzdWx0LnNldChmcm9tLCB0bywgbm9ybWFsLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgZGlzdGFuY2UpOwogICAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7CiAgICAgICAgICB0aGlzLmNhbGxiYWNrKHJlc3VsdCk7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSBSYXkuQ0xPU0VTVDoKICAgICAgICAgIC8vIFN0b3JlIGlmIGNsb3NlciB0aGFuIGN1cnJlbnQgY2xvc2VzdAogICAgICAgICAgaWYgKGRpc3RhbmNlIDwgcmVzdWx0LmRpc3RhbmNlIHx8ICFyZXN1bHQuaGFzSGl0KSB7CiAgICAgICAgICAgIHRoaXMuaGFzSGl0ID0gdHJ1ZTsKICAgICAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7CiAgICAgICAgICAgIHJlc3VsdC5zZXQoZnJvbSwgdG8sIG5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIGRpc3RhbmNlKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSBSYXkuQU5ZOgogICAgICAgICAgLy8gUmVwb3J0IGFuZCBzdG9wLgogICAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlOwogICAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7CiAgICAgICAgICByZXN1bHQuc2V0KGZyb20sIHRvLCBub3JtYWwsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCBkaXN0YW5jZSk7CiAgICAgICAgICByZXN1bHQuc2hvdWxkU3RvcCA9IHRydWU7CiAgICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBBcyBwZXIgIkJhcnljZW50cmljIFRlY2huaXF1ZSIgYXMgbmFtZWQKICAgICAqIHtAbGluayBodHRwczovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbCBoZXJlfSBidXQgd2l0aG91dCB0aGUgZGl2aXNpb24KICAgICAqLwoKCiAgICBzdGF0aWMgcG9pbnRJblRyaWFuZ2xlKHAsIGEsIGIsIGMpIHsKICAgICAgYy52c3ViKGEsIHYwKTsKICAgICAgYi52c3ViKGEsIHYxKTsKICAgICAgcC52c3ViKGEsIHYyKTsKICAgICAgY29uc3QgZG90MDAgPSB2MC5kb3QodjApOwogICAgICBjb25zdCBkb3QwMSA9IHYwLmRvdCh2MSk7CiAgICAgIGNvbnN0IGRvdDAyID0gdjAuZG90KHYyKTsKICAgICAgY29uc3QgZG90MTEgPSB2MS5kb3QodjEpOwogICAgICBjb25zdCBkb3QxMiA9IHYxLmRvdCh2Mik7CiAgICAgIGxldCB1OwogICAgICBsZXQgdjsKICAgICAgcmV0dXJuICh1ID0gZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpID49IDAgJiYgKHYgPSBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMikgPj0gMCAmJiB1ICsgdiA8IGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxOwogICAgfQoKICB9CiAgUmF5LkNMT1NFU1QgPSBSQVlfTU9ERVMuQ0xPU0VTVDsKICBSYXkuQU5ZID0gUkFZX01PREVTLkFOWTsKICBSYXkuQUxMID0gUkFZX01PREVTLkFMTDsKICBjb25zdCB0bXBBQUJCJDEgPSBuZXcgQUFCQigpOwogIGNvbnN0IHRtcEFycmF5ID0gW107CiAgY29uc3QgdjEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHYyID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RCb2R5X3hpID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RCb2R5X3FpID0gbmV3IFF1YXRlcm5pb24oKTsKICBjb25zdCBpbnRlcnNlY3RQb2ludCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYyA9IG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgUmF5Y2FzdFJlc3VsdCgpOwogIGNvbnN0IGludGVyc2VjdENvbnZleE9wdGlvbnMgPSB7CiAgICBmYWNlTGlzdDogWzBdCiAgfTsKICBjb25zdCB3b3JsZFBpbGxhck9mZnNldCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxSYXkgPSBuZXcgUmF5KCk7CiAgY29uc3QgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfaW5kZXggPSBbXTsKICBjb25zdCBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50ID0gbmV3IFZlYzMoKTsKICBjb25zdCBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW50ZXJzZWN0Q29udmV4X25vcm1hbCA9IG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IGludGVyc2VjdENvbnZleF92ZWN0b3IgPSBuZXcgVmVjMygpOwogIGNvbnN0IGludGVyc2VjdFRyaW1lc2hfbm9ybWFsID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRnJvbSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbFRvID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX3dvcmxkSW50ZXJzZWN0UG9pbnQgPSBuZXcgVmVjMygpOwogIG5ldyBBQUJCKCk7CiAgY29uc3QgaW50ZXJzZWN0VHJpbWVzaF90cmlhbmdsZXMgPSBbXTsKICBjb25zdCBpbnRlcnNlY3RUcmltZXNoX3RyZWVUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7CiAgY29uc3QgdjAgPSBuZXcgVmVjMygpOwogIGNvbnN0IGludGVyc2VjdCA9IG5ldyBWZWMzKCk7CgogIGZ1bmN0aW9uIGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbihmcm9tLCBkaXJlY3Rpb24sIHBvc2l0aW9uKSB7CiAgICAvLyB2MCBpcyB2ZWN0b3IgZnJvbSBmcm9tIHRvIHBvc2l0aW9uCiAgICBwb3NpdGlvbi52c3ViKGZyb20sIHYwKTsKICAgIGNvbnN0IGRvdCA9IHYwLmRvdChkaXJlY3Rpb24pOyAvLyBpbnRlcnNlY3QgPSBkaXJlY3Rpb24qZG90ICsgZnJvbQoKICAgIGRpcmVjdGlvbi5zY2FsZShkb3QsIGludGVyc2VjdCk7CiAgICBpbnRlcnNlY3QudmFkZChmcm9tLCBpbnRlcnNlY3QpOwogICAgY29uc3QgZGlzdGFuY2UgPSBwb3NpdGlvbi5kaXN0YW5jZVRvKGludGVyc2VjdCk7CiAgICByZXR1cm4gZGlzdGFuY2U7CiAgfQoKICAvKioKICAgKiBTd2VlcCBhbmQgcHJ1bmUgYnJvYWRwaGFzZSBhbG9uZyBvbmUgYXhpcy4KICAgKi8KICBjbGFzcyBTQVBCcm9hZHBoYXNlIGV4dGVuZHMgQnJvYWRwaGFzZSB7CiAgICAvKioKICAgICAqIExpc3Qgb2YgYm9kaWVzIGN1cnJlbnRseSBpbiB0aGUgYnJvYWRwaGFzZS4KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIHdvcmxkIHRvIHNlYXJjaCBpbi4KICAgICAqLwoKICAgIC8qKgogICAgICogQXhpcyB0byBzb3J0IHRoZSBib2RpZXMgYWxvbmcuCiAgICAgKiBTZXQgdG8gMCBmb3IgeCBheGlzLCBhbmQgMSBmb3IgeSBheGlzLgogICAgICogRm9yIGJlc3QgcGVyZm9ybWFuY2UsIHBpY2sgdGhlIGF4aXMgd2hlcmUgYm9kaWVzIGFyZSBtb3N0IGRpc3RyaWJ1dGVkLgogICAgICovCgogICAgLyoqCiAgICAgKiBDaGVjayBpZiB0aGUgYm91bmRzIG9mIHR3byBib2RpZXMgb3ZlcmxhcCwgYWxvbmcgdGhlIGdpdmVuIFNBUCBheGlzLgogICAgICovCiAgICBzdGF0aWMgY2hlY2tCb3VuZHMoYmksIGJqLCBheGlzSW5kZXgpIHsKICAgICAgbGV0IGJpUG9zOwogICAgICBsZXQgYmpQb3M7CgogICAgICBpZiAoYXhpc0luZGV4ID09PSAwKSB7CiAgICAgICAgYmlQb3MgPSBiaS5wb3NpdGlvbi54OwogICAgICAgIGJqUG9zID0gYmoucG9zaXRpb24ueDsKICAgICAgfSBlbHNlIGlmIChheGlzSW5kZXggPT09IDEpIHsKICAgICAgICBiaVBvcyA9IGJpLnBvc2l0aW9uLnk7CiAgICAgICAgYmpQb3MgPSBiai5wb3NpdGlvbi55OwogICAgICB9IGVsc2UgaWYgKGF4aXNJbmRleCA9PT0gMikgewogICAgICAgIGJpUG9zID0gYmkucG9zaXRpb24uejsKICAgICAgICBialBvcyA9IGJqLnBvc2l0aW9uLno7CiAgICAgIH0KCiAgICAgIGNvbnN0IHJpID0gYmkuYm91bmRpbmdSYWRpdXMsCiAgICAgICAgICAgIHJqID0gYmouYm91bmRpbmdSYWRpdXMsCiAgICAgICAgICAgIGJvdW5kQTIgPSBiaVBvcyArIHJpLAogICAgICAgICAgICBib3VuZEIxID0gYmpQb3MgLSByajsKICAgICAgcmV0dXJuIGJvdW5kQjEgPCBib3VuZEEyOwogICAgfSAvLyBOb3RlOiB0aGVzZSBhcmUgaWRlbnRpY2FsLCBzYXZlIGZvciB4L3kveiBsb3dlcmJvdW5kCgogICAgLyoqCiAgICAgKiBpbnNlcnRpb25Tb3J0WAogICAgICovCgoKICAgIHN0YXRpYyBpbnNlcnRpb25Tb3J0WChhKSB7CiAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICBjb25zdCB2ID0gYVtpXTsKICAgICAgICBsZXQgajsKCiAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7CiAgICAgICAgICBpZiAoYVtqXS5hYWJiLmxvd2VyQm91bmQueCA8PSB2LmFhYmIubG93ZXJCb3VuZC54KSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGFbaiArIDFdID0gYVtqXTsKICAgICAgICB9CgogICAgICAgIGFbaiArIDFdID0gdjsKICAgICAgfQoKICAgICAgcmV0dXJuIGE7CiAgICB9CiAgICAvKioKICAgICAqIGluc2VydGlvblNvcnRZCiAgICAgKi8KCgogICAgc3RhdGljIGluc2VydGlvblNvcnRZKGEpIHsKICAgICAgZm9yIChsZXQgaSA9IDEsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgIGNvbnN0IHYgPSBhW2ldOwogICAgICAgIGxldCBqOwoKICAgICAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHsKICAgICAgICAgIGlmIChhW2pdLmFhYmIubG93ZXJCb3VuZC55IDw9IHYuYWFiYi5sb3dlckJvdW5kLnkpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgYVtqICsgMV0gPSBhW2pdOwogICAgICAgIH0KCiAgICAgICAgYVtqICsgMV0gPSB2OwogICAgICB9CgogICAgICByZXR1cm4gYTsKICAgIH0KICAgIC8qKgogICAgICogaW5zZXJ0aW9uU29ydFoKICAgICAqLwoKCiAgICBzdGF0aWMgaW5zZXJ0aW9uU29ydFooYSkgewogICAgICBmb3IgKGxldCBpID0gMSwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgY29uc3QgdiA9IGFbaV07CiAgICAgICAgbGV0IGo7CgogICAgICAgIGZvciAoaiA9IGkgLSAxOyBqID49IDA7IGotLSkgewogICAgICAgICAgaWYgKGFbal0uYWFiYi5sb3dlckJvdW5kLnogPD0gdi5hYWJiLmxvd2VyQm91bmQueikgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBhW2ogKyAxXSA9IGFbal07CiAgICAgICAgfQoKICAgICAgICBhW2ogKyAxXSA9IHY7CiAgICAgIH0KCiAgICAgIHJldHVybiBhOwogICAgfQoKICAgIGNvbnN0cnVjdG9yKHdvcmxkKSB7CiAgICAgIHN1cGVyKCk7CiAgICAgIHRoaXMuYXhpc0xpc3QgPSBbXTsKICAgICAgdGhpcy53b3JsZCA9IG51bGw7CiAgICAgIHRoaXMuYXhpc0luZGV4ID0gMDsKICAgICAgY29uc3QgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0OwoKICAgICAgdGhpcy5fYWRkQm9keUhhbmRsZXIgPSBldmVudCA9PiB7CiAgICAgICAgYXhpc0xpc3QucHVzaChldmVudC5ib2R5KTsKICAgICAgfTsKCiAgICAgIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyID0gZXZlbnQgPT4gewogICAgICAgIGNvbnN0IGlkeCA9IGF4aXNMaXN0LmluZGV4T2YoZXZlbnQuYm9keSk7CgogICAgICAgIGlmIChpZHggIT09IC0xKSB7CiAgICAgICAgICBheGlzTGlzdC5zcGxpY2UoaWR4LCAxKTsKICAgICAgICB9CiAgICAgIH07CgogICAgICBpZiAod29ybGQpIHsKICAgICAgICB0aGlzLnNldFdvcmxkKHdvcmxkKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDaGFuZ2UgdGhlIHdvcmxkCiAgICAgKi8KCgogICAgc2V0V29ybGQod29ybGQpIHsKICAgICAgLy8gQ2xlYXIgdGhlIG9sZCBheGlzIGFycmF5CiAgICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDsgLy8gQWRkIGFsbCBib2RpZXMgZnJvbSB0aGUgbmV3IHdvcmxkCgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmxkLmJvZGllcy5sZW5ndGg7IGkrKykgewogICAgICAgIHRoaXMuYXhpc0xpc3QucHVzaCh3b3JsZC5ib2RpZXNbaV0pOwogICAgICB9IC8vIFJlbW92ZSBvbGQgaGFuZGxlcnMsIGlmIGFueQoKCiAgICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZEJvZHknLCB0aGlzLl9hZGRCb2R5SGFuZGxlcik7CiAgICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZUJvZHknLCB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7IC8vIEFkZCBoYW5kbGVycyB0byB1cGRhdGUgdGhlIGxpc3Qgb2YgYm9kaWVzLgoKICAgICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcignYWRkQm9keScsIHRoaXMuX2FkZEJvZHlIYW5kbGVyKTsKICAgICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZlQm9keScsIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTsKICAgICAgdGhpcy53b3JsZCA9IHdvcmxkOwogICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogQ29sbGVjdCBhbGwgY29sbGlzaW9uIHBhaXJzCiAgICAgKi8KCgogICAgY29sbGlzaW9uUGFpcnMod29ybGQsIHAxLCBwMikgewogICAgICBjb25zdCBib2RpZXMgPSB0aGlzLmF4aXNMaXN0OwogICAgICBjb25zdCBOID0gYm9kaWVzLmxlbmd0aDsKICAgICAgY29uc3QgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7CiAgICAgIGxldCBpOwogICAgICBsZXQgajsKCiAgICAgIGlmICh0aGlzLmRpcnR5KSB7CiAgICAgICAgdGhpcy5zb3J0TGlzdCgpOwogICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTsKICAgICAgfSAvLyBMb29rIHRocm91Z2ggdGhlIGxpc3QKCgogICAgICBmb3IgKGkgPSAwOyBpICE9PSBOOyBpKyspIHsKICAgICAgICBjb25zdCBiaSA9IGJvZGllc1tpXTsKCiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBOOyBqKyspIHsKICAgICAgICAgIGNvbnN0IGJqID0gYm9kaWVzW2pdOwoKICAgICAgICAgIGlmICghdGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSwgYmopKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICghU0FQQnJvYWRwaGFzZS5jaGVja0JvdW5kcyhiaSwgYmosIGF4aXNJbmRleCkpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25UZXN0KGJpLCBiaiwgcDEsIHAyKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBzb3J0TGlzdCgpIHsKICAgICAgY29uc3QgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0OwogICAgICBjb25zdCBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDsKICAgICAgY29uc3QgTiA9IGF4aXNMaXN0Lmxlbmd0aDsgLy8gVXBkYXRlIEFBQkJzCgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgY29uc3QgYmkgPSBheGlzTGlzdFtpXTsKCiAgICAgICAgaWYgKGJpLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgICAgYmkudXBkYXRlQUFCQigpOwogICAgICAgIH0KICAgICAgfSAvLyBTb3J0IHRoZSBsaXN0CgoKICAgICAgaWYgKGF4aXNJbmRleCA9PT0gMCkgewogICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFgoYXhpc0xpc3QpOwogICAgICB9IGVsc2UgaWYgKGF4aXNJbmRleCA9PT0gMSkgewogICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFkoYXhpc0xpc3QpOwogICAgICB9IGVsc2UgaWYgKGF4aXNJbmRleCA9PT0gMikgewogICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFooYXhpc0xpc3QpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGVzIHRoZSB2YXJpYW5jZSBvZiB0aGUgYm9keSBwb3NpdGlvbnMgYW5kIGVzdGltYXRlcyB0aGUgYmVzdCBheGlzIHRvIHVzZS4KICAgICAqIFdpbGwgYXV0b21hdGljYWxseSBzZXQgcHJvcGVydHkgYGF4aXNJbmRleGAuCiAgICAgKi8KCgogICAgYXV0b0RldGVjdEF4aXMoKSB7CiAgICAgIGxldCBzdW1YID0gMDsKICAgICAgbGV0IHN1bVgyID0gMDsKICAgICAgbGV0IHN1bVkgPSAwOwogICAgICBsZXQgc3VtWTIgPSAwOwogICAgICBsZXQgc3VtWiA9IDA7CiAgICAgIGxldCBzdW1aMiA9IDA7CiAgICAgIGNvbnN0IGJvZGllcyA9IHRoaXMuYXhpc0xpc3Q7CiAgICAgIGNvbnN0IE4gPSBib2RpZXMubGVuZ3RoOwogICAgICBjb25zdCBpbnZOID0gMSAvIE47CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgY29uc3QgYiA9IGJvZGllc1tpXTsKICAgICAgICBjb25zdCBjZW50ZXJYID0gYi5wb3NpdGlvbi54OwogICAgICAgIHN1bVggKz0gY2VudGVyWDsKICAgICAgICBzdW1YMiArPSBjZW50ZXJYICogY2VudGVyWDsKICAgICAgICBjb25zdCBjZW50ZXJZID0gYi5wb3NpdGlvbi55OwogICAgICAgIHN1bVkgKz0gY2VudGVyWTsKICAgICAgICBzdW1ZMiArPSBjZW50ZXJZICogY2VudGVyWTsKICAgICAgICBjb25zdCBjZW50ZXJaID0gYi5wb3NpdGlvbi56OwogICAgICAgIHN1bVogKz0gY2VudGVyWjsKICAgICAgICBzdW1aMiArPSBjZW50ZXJaICogY2VudGVyWjsKICAgICAgfQoKICAgICAgY29uc3QgdmFyaWFuY2VYID0gc3VtWDIgLSBzdW1YICogc3VtWCAqIGludk47CiAgICAgIGNvbnN0IHZhcmlhbmNlWSA9IHN1bVkyIC0gc3VtWSAqIHN1bVkgKiBpbnZOOwogICAgICBjb25zdCB2YXJpYW5jZVogPSBzdW1aMiAtIHN1bVogKiBzdW1aICogaW52TjsKCiAgICAgIGlmICh2YXJpYW5jZVggPiB2YXJpYW5jZVkpIHsKICAgICAgICBpZiAodmFyaWFuY2VYID4gdmFyaWFuY2VaKSB7CiAgICAgICAgICB0aGlzLmF4aXNJbmRleCA9IDA7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMjsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAodmFyaWFuY2VZID4gdmFyaWFuY2VaKSB7CiAgICAgICAgdGhpcy5heGlzSW5kZXggPSAxOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMjsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLgogICAgICogQHBhcmFtIHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLgogICAgICovCgoKICAgIGFhYmJRdWVyeSh3b3JsZCwgYWFiYiwgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgewogICAgICAgIHJlc3VsdCA9IFtdOwogICAgICB9CgogICAgICBpZiAodGhpcy5kaXJ0eSkgewogICAgICAgIHRoaXMuc29ydExpc3QoKTsKICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7CiAgICAgIH0KCiAgICAgIGNvbnN0IGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4OwogICAgICBsZXQgYXhpcyA9ICd4JzsKCiAgICAgIGlmIChheGlzSW5kZXggPT09IDEpIHsKICAgICAgICBheGlzID0gJ3knOwogICAgICB9CgogICAgICBpZiAoYXhpc0luZGV4ID09PSAyKSB7CiAgICAgICAgYXhpcyA9ICd6JzsKICAgICAgfQoKICAgICAgY29uc3QgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0OwogICAgICBhYWJiLmxvd2VyQm91bmRbYXhpc107CiAgICAgIGFhYmIudXBwZXJCb3VuZFtheGlzXTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhpc0xpc3QubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBiID0gYXhpc0xpc3RbaV07CgogICAgICAgIGlmIChiLmFhYmJOZWVkc1VwZGF0ZSkgewogICAgICAgICAgYi51cGRhdGVBQUJCKCk7CiAgICAgICAgfQoKICAgICAgICBpZiAoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKSB7CiAgICAgICAgICByZXN1bHQucHVzaChiKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CgogIH0KCiAgY2xhc3MgVXRpbHMgewogICAgLyoqCiAgICAgKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy4KICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIG9iamVjdC4gTWF5IGJlIGZhbHN5OiBpbiB0aGlzIGNhc2UsIGEgbmV3IG9iamVjdCBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC4KICAgICAqIEBwYXJhbSBkZWZhdWx0cyBBbiBvYmplY3QgY29udGFpbmluZyBkZWZhdWx0IHZhbHVlcy4KICAgICAqIEByZXR1cm4gVGhlIG1vZGlmaWVkIG9wdGlvbnMgb2JqZWN0LgogICAgICovCiAgICBzdGF0aWMgZGVmYXVsdHMob3B0aW9ucywgZGVmYXVsdHMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgZm9yIChsZXQga2V5IGluIGRlZmF1bHRzKSB7CiAgICAgICAgaWYgKCEoa2V5IGluIG9wdGlvbnMpKSB7CiAgICAgICAgICBvcHRpb25zW2tleV0gPSBkZWZhdWx0c1trZXldOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG9wdGlvbnM7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQ29uc3RyYWludCBiYXNlIGNsYXNzCiAgICovCiAgY2xhc3MgQ29uc3RyYWludCB7CiAgICAvKioKICAgICAqIEVxdWF0aW9ucyB0byBiZSBzb2x2ZWQgaW4gdGhpcyBjb25zdHJhaW50LgogICAgICovCgogICAgLyoqCiAgICAgKiBCb2R5IEEuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEJvZHkgQi4KICAgICAqLwoKICAgIC8qKgogICAgICogU2V0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBib2RpZXMgdG8gY29sbGlkZSB3aGVuIHRoZXkgYXJlIGNvbm5lY3RlZC4KICAgICAqLwogICAgY29uc3RydWN0b3IoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7CiAgICAgICAgY29sbGlkZUNvbm5lY3RlZDogdHJ1ZSwKICAgICAgICB3YWtlVXBCb2RpZXM6IHRydWUKICAgICAgfSk7CiAgICAgIHRoaXMuZXF1YXRpb25zID0gW107CiAgICAgIHRoaXMuYm9keUEgPSBib2R5QTsKICAgICAgdGhpcy5ib2R5QiA9IGJvZHlCOwogICAgICB0aGlzLmlkID0gQ29uc3RyYWludC5pZENvdW50ZXIrKzsKICAgICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkOwoKICAgICAgaWYgKG9wdGlvbnMud2FrZVVwQm9kaWVzKSB7CiAgICAgICAgaWYgKGJvZHlBKSB7CiAgICAgICAgICBib2R5QS53YWtlVXAoKTsKICAgICAgICB9CgogICAgICAgIGlmIChib2R5QikgewogICAgICAgICAgYm9keUIud2FrZVVwKCk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFVwZGF0ZSBhbGwgdGhlIGVxdWF0aW9ucyB3aXRoIGRhdGEuCiAgICAgKi8KCgogICAgdXBkYXRlKCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCB1cGRhdGUoKSBub3QgaW1wbG1lbWVudGVkIGluIHRoaXMgQ29uc3RyYWludCBzdWJjbGFzcyEnKTsKICAgIH0KICAgIC8qKgogICAgICogRW5hYmxlcyBhbGwgZXF1YXRpb25zIGluIHRoZSBjb25zdHJhaW50LgogICAgICovCgoKICAgIGVuYWJsZSgpIHsKICAgICAgY29uc3QgZXFzID0gdGhpcy5lcXVhdGlvbnM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVxcy5sZW5ndGg7IGkrKykgewogICAgICAgIGVxc1tpXS5lbmFibGVkID0gdHJ1ZTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBEaXNhYmxlcyBhbGwgZXF1YXRpb25zIGluIHRoZSBjb25zdHJhaW50LgogICAgICovCgoKICAgIGRpc2FibGUoKSB7CiAgICAgIGNvbnN0IGVxcyA9IHRoaXMuZXF1YXRpb25zOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBlcXNbaV0uZW5hYmxlZCA9IGZhbHNlOwogICAgICB9CiAgICB9CgogIH0KICBDb25zdHJhaW50LmlkQ291bnRlciA9IDA7CgogIC8qKgogICAqIEFuIGVsZW1lbnQgY29udGFpbmluZyA2IGVudHJpZXMsIDMgc3BhdGlhbCBhbmQgMyByb3RhdGlvbmFsIGRlZ3JlZXMgb2YgZnJlZWRvbS4KICAgKi8KCiAgY2xhc3MgSmFjb2JpYW5FbGVtZW50IHsKICAgIC8qKgogICAgICogc3BhdGlhbAogICAgICovCgogICAgLyoqCiAgICAgKiByb3RhdGlvbmFsCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKCkgewogICAgICB0aGlzLnNwYXRpYWwgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnJvdGF0aW9uYWwgPSBuZXcgVmVjMygpOwogICAgfQogICAgLyoqCiAgICAgKiBNdWx0aXBseSB3aXRoIG90aGVyIEphY29iaWFuRWxlbWVudAogICAgICovCgoKICAgIG11bHRpcGx5RWxlbWVudChlbGVtZW50KSB7CiAgICAgIHJldHVybiBlbGVtZW50LnNwYXRpYWwuZG90KHRoaXMuc3BhdGlhbCkgKyBlbGVtZW50LnJvdGF0aW9uYWwuZG90KHRoaXMucm90YXRpb25hbCk7CiAgICB9CiAgICAvKioKICAgICAqIE11bHRpcGx5IHdpdGggdHdvIHZlY3RvcnMKICAgICAqLwoKCiAgICBtdWx0aXBseVZlY3RvcnMoc3BhdGlhbCwgcm90YXRpb25hbCkgewogICAgICByZXR1cm4gc3BhdGlhbC5kb3QodGhpcy5zcGF0aWFsKSArIHJvdGF0aW9uYWwuZG90KHRoaXMucm90YXRpb25hbCk7CiAgICB9CgogIH0KCiAgLyoqCiAgICogRXF1YXRpb24gYmFzZSBjbGFzcy4KICAgKgogICAqIGBhYCwgYGJgIGFuZCBgZXBzYCBhcmUge0BsaW5rIGh0dHBzOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyLzVEVjA1OC9WVDE1L2xlY3R1cmVzL1NQT09LbGFibm90ZXMucGRmIFNQT09LfSBwYXJhbWV0ZXJzIHRoYXQgZGVmYXVsdCB0byBgMC4wYC4gU2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvY2Fubm9uLmpzL2lzc3Vlcy8yMzgjaXNzdWVjb21tZW50LTE0NzE3MjMyNyB0aGlzIGV4Y2hhbmdlfSBmb3IgbW9yZSBkZXRhaWxzIG9uIENhbm5vbidzIHBoeXNpY3MgaW1wbGVtZW50YXRpb24uCiAgICovCiAgY2xhc3MgRXF1YXRpb24gewogICAgLyoqCiAgICAgKiBNaW5pbXVtIChyZWFkOiBuZWdhdGl2ZSBtYXgpIGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnQuCiAgICAgKi8KCiAgICAvKioKICAgICAqIE1heGltdW0gKHJlYWQ6IHBvc2l0aXZlIG1heCkgZm9yY2UgdG8gYmUgYXBwbGllZCBieSB0aGUgY29uc3RyYWludC4KICAgICAqLwoKICAgIC8qKgogICAgICogU1BPT0sgcGFyYW1ldGVyCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNQT09LIHBhcmFtZXRlcgogICAgICovCgogICAgLyoqCiAgICAgKiBTUE9PSyBwYXJhbWV0ZXIKICAgICAqLwoKICAgIC8qKgogICAgICogQSBudW1iZXIsIHByb3BvcnRpb25hbCB0byB0aGUgZm9yY2UgYWRkZWQgdG8gdGhlIGJvZGllcy4KICAgICAqLwogICAgY29uc3RydWN0b3IoYmksIGJqLCBtaW5Gb3JjZSwgbWF4Rm9yY2UpIHsKICAgICAgaWYgKG1pbkZvcmNlID09PSB2b2lkIDApIHsKICAgICAgICBtaW5Gb3JjZSA9IC0xZTY7CiAgICAgIH0KCiAgICAgIGlmIChtYXhGb3JjZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgbWF4Rm9yY2UgPSAxZTY7CiAgICAgIH0KCiAgICAgIHRoaXMuaWQgPSBFcXVhdGlvbi5pZENvdW50ZXIrKzsKICAgICAgdGhpcy5taW5Gb3JjZSA9IG1pbkZvcmNlOwogICAgICB0aGlzLm1heEZvcmNlID0gbWF4Rm9yY2U7CiAgICAgIHRoaXMuYmkgPSBiaTsKICAgICAgdGhpcy5iaiA9IGJqOwogICAgICB0aGlzLmEgPSAwLjA7IC8vIFNQT09LIHBhcmFtZXRlcgoKICAgICAgdGhpcy5iID0gMC4wOyAvLyBTUE9PSyBwYXJhbWV0ZXIKCiAgICAgIHRoaXMuZXBzID0gMC4wOyAvLyBTUE9PSyBwYXJhbWV0ZXIKCiAgICAgIHRoaXMuamFjb2JpYW5FbGVtZW50QSA9IG5ldyBKYWNvYmlhbkVsZW1lbnQoKTsKICAgICAgdGhpcy5qYWNvYmlhbkVsZW1lbnRCID0gbmV3IEphY29iaWFuRWxlbWVudCgpOwogICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlOwogICAgICB0aGlzLm11bHRpcGxpZXIgPSAwOwogICAgICB0aGlzLnNldFNwb29rUGFyYW1zKDFlNywgNCwgMSAvIDYwKTsgLy8gU2V0IHR5cGljYWwgc3Bvb2sgcGFyYW1zCiAgICB9CiAgICAvKioKICAgICAqIFJlY2FsY3VsYXRlcyBhLCBiLCBhbmQgZXBzLgogICAgICoKICAgICAqIFRoZSBFcXVhdGlvbiBjb25zdHJ1Y3RvciBzZXRzIHR5cGljYWwgU1BPT0sgcGFyYW1ldGVycyBhcyBzdWNoOgogICAgICogKiBgc3RpZmZuZXNzYCA9IDFlNwogICAgICogKiBgcmVsYXhhdGlvbmAgPSA0CiAgICAgKiAqIGB0aW1lU3RlcGA9IDEgLyA2MCwgX25vdGUgdGhlIGhhcmRjb2RlZCByZWZyZXNoIHJhdGUuXwogICAgICovCgoKICAgIHNldFNwb29rUGFyYW1zKHN0aWZmbmVzcywgcmVsYXhhdGlvbiwgdGltZVN0ZXApIHsKICAgICAgY29uc3QgZCA9IHJlbGF4YXRpb247CiAgICAgIGNvbnN0IGsgPSBzdGlmZm5lc3M7CiAgICAgIGNvbnN0IGggPSB0aW1lU3RlcDsKICAgICAgdGhpcy5hID0gNC4wIC8gKGggKiAoMSArIDQgKiBkKSk7CiAgICAgIHRoaXMuYiA9IDQuMCAqIGQgLyAoMSArIDQgKiBkKTsKICAgICAgdGhpcy5lcHMgPSA0LjAgLyAoaCAqIGggKiBrICogKDEgKyA0ICogZCkpOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyB0aGUgcmlnaHQgaGFuZCBzaWRlIG9mIHRoZSBTUE9PSyBlcXVhdGlvbgogICAgICovCgoKICAgIGNvbXB1dGVCKGEsIGIsIGgpIHsKICAgICAgY29uc3QgR1cgPSB0aGlzLmNvbXB1dGVHVygpOwogICAgICBjb25zdCBHcSA9IHRoaXMuY29tcHV0ZUdxKCk7CiAgICAgIGNvbnN0IEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7CiAgICAgIHJldHVybiAtR3EgKiBhIC0gR1cgKiBiIC0gR2lNZiAqIGg7CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGVzIEcqcSwgd2hlcmUgcSBhcmUgdGhlIGdlbmVyYWxpemVkIGJvZHkgY29vcmRpbmF0ZXMKICAgICAqLwoKCiAgICBjb21wdXRlR3EoKSB7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsKICAgICAgY29uc3QgYmkgPSB0aGlzLmJpOwogICAgICBjb25zdCBiaiA9IHRoaXMuYmo7CiAgICAgIGNvbnN0IHhpID0gYmkucG9zaXRpb247CiAgICAgIGNvbnN0IHhqID0gYmoucG9zaXRpb247CiAgICAgIHJldHVybiBHQS5zcGF0aWFsLmRvdCh4aSkgKyBHQi5zcGF0aWFsLmRvdCh4aik7CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGVzIEcqVywgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllcwogICAgICovCgoKICAgIGNvbXB1dGVHVygpIHsKICAgICAgY29uc3QgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEE7CiAgICAgIGNvbnN0IEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCOwogICAgICBjb25zdCBiaSA9IHRoaXMuYmk7CiAgICAgIGNvbnN0IGJqID0gdGhpcy5iajsKICAgICAgY29uc3QgdmkgPSBiaS52ZWxvY2l0eTsKICAgICAgY29uc3QgdmogPSBiai52ZWxvY2l0eTsKICAgICAgY29uc3Qgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHk7CiAgICAgIGNvbnN0IHdqID0gYmouYW5ndWxhclZlbG9jaXR5OwogICAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKHZpLCB3aSkgKyBHQi5tdWx0aXBseVZlY3RvcnModmosIHdqKTsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZXMgRypXbGFtYmRhLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzCiAgICAgKi8KCgogICAgY29tcHV0ZUdXbGFtYmRhKCkgewogICAgICBjb25zdCBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QTsKICAgICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7CiAgICAgIGNvbnN0IGJpID0gdGhpcy5iaTsKICAgICAgY29uc3QgYmogPSB0aGlzLmJqOwogICAgICBjb25zdCB2aSA9IGJpLnZsYW1iZGE7CiAgICAgIGNvbnN0IHZqID0gYmoudmxhbWJkYTsKICAgICAgY29uc3Qgd2kgPSBiaS53bGFtYmRhOwogICAgICBjb25zdCB3aiA9IGJqLndsYW1iZGE7CiAgICAgIHJldHVybiBHQS5tdWx0aXBseVZlY3RvcnModmksIHdpKSArIEdCLm11bHRpcGx5VmVjdG9ycyh2aiwgd2opOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyBHKmludihNKSpmLCB3aGVyZSBNIGlzIHRoZSBtYXNzIG1hdHJpeCB3aXRoIGRpYWdvbmFsIGJsb2NrcyBmb3IgZWFjaCBib2R5LCBhbmQgZiBhcmUgdGhlIGZvcmNlcyBvbiB0aGUgYm9kaWVzLgogICAgICovCgoKICAgIGNvbXB1dGVHaU1mKCkgewogICAgICBjb25zdCBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QTsKICAgICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7CiAgICAgIGNvbnN0IGJpID0gdGhpcy5iaTsKICAgICAgY29uc3QgYmogPSB0aGlzLmJqOwogICAgICBjb25zdCBmaSA9IGJpLmZvcmNlOwogICAgICBjb25zdCB0aSA9IGJpLnRvcnF1ZTsKICAgICAgY29uc3QgZmogPSBiai5mb3JjZTsKICAgICAgY29uc3QgdGogPSBiai50b3JxdWU7CiAgICAgIGNvbnN0IGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlOwogICAgICBjb25zdCBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZTsKICAgICAgZmkuc2NhbGUoaW52TWFzc2ksIGlNZmkpOwogICAgICBmai5zY2FsZShpbnZNYXNzaiwgaU1maik7CiAgICAgIGJpLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KHRpLCBpbnZJaV92bXVsdF90YXVpKTsKICAgICAgYmouaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQodGosIGludklqX3ZtdWx0X3RhdWopOwogICAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKGlNZmksIGludklpX3ZtdWx0X3RhdWkpICsgR0IubXVsdGlwbHlWZWN0b3JzKGlNZmosIGludklqX3ZtdWx0X3RhdWopOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyBHKmludihNKSpHJwogICAgICovCgoKICAgIGNvbXB1dGVHaU1HdCgpIHsKICAgICAgY29uc3QgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEE7CiAgICAgIGNvbnN0IEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCOwogICAgICBjb25zdCBiaSA9IHRoaXMuYmk7CiAgICAgIGNvbnN0IGJqID0gdGhpcy5iajsKICAgICAgY29uc3QgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmU7CiAgICAgIGNvbnN0IGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlOwogICAgICBjb25zdCBpbnZJaSA9IGJpLmludkluZXJ0aWFXb3JsZFNvbHZlOwogICAgICBjb25zdCBpbnZJaiA9IGJqLmludkluZXJ0aWFXb3JsZFNvbHZlOwogICAgICBsZXQgcmVzdWx0ID0gaW52TWFzc2kgKyBpbnZNYXNzajsKICAgICAgaW52SWkudm11bHQoR0Eucm90YXRpb25hbCwgdG1wKTsKICAgICAgcmVzdWx0ICs9IHRtcC5kb3QoR0Eucm90YXRpb25hbCk7CiAgICAgIGludklqLnZtdWx0KEdCLnJvdGF0aW9uYWwsIHRtcCk7CiAgICAgIHJlc3VsdCArPSB0bXAuZG90KEdCLnJvdGF0aW9uYWwpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBBZGQgY29uc3RyYWludCB2ZWxvY2l0eSB0byB0aGUgYm9kaWVzLgogICAgICovCgoKICAgIGFkZFRvV2xhbWJkYShkZWx0YWxhbWJkYSkgewogICAgICBjb25zdCBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QTsKICAgICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7CiAgICAgIGNvbnN0IGJpID0gdGhpcy5iaTsKICAgICAgY29uc3QgYmogPSB0aGlzLmJqOwogICAgICBjb25zdCB0ZW1wID0gYWRkVG9XbGFtYmRhX3RlbXA7IC8vIEFkZCB0byBsaW5lYXIgdmVsb2NpdHkKICAgICAgLy8gdl9sYW1iZGEgKz0gaW52KE0pICogZGVsdGFfbGFtYmEgKiBHCgogICAgICBiaS52bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihiaS5pbnZNYXNzU29sdmUgKiBkZWx0YWxhbWJkYSwgR0Euc3BhdGlhbCwgYmkudmxhbWJkYSk7CiAgICAgIGJqLnZsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGJqLmludk1hc3NTb2x2ZSAqIGRlbHRhbGFtYmRhLCBHQi5zcGF0aWFsLCBiai52bGFtYmRhKTsgLy8gQWRkIHRvIGFuZ3VsYXIgdmVsb2NpdHkKCiAgICAgIGJpLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KEdBLnJvdGF0aW9uYWwsIHRlbXApOwogICAgICBiaS53bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihkZWx0YWxhbWJkYSwgdGVtcCwgYmkud2xhbWJkYSk7CiAgICAgIGJqLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KEdCLnJvdGF0aW9uYWwsIHRlbXApOwogICAgICBiai53bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihkZWx0YWxhbWJkYSwgdGVtcCwgYmoud2xhbWJkYSk7CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGUgdGhlIGRlbm9taW5hdG9yIHBhcnQgb2YgdGhlIFNQT09LIGVxdWF0aW9uOiBDID0gRyppbnYoTSkqRycgKyBlcHMKICAgICAqLwoKCiAgICBjb21wdXRlQygpIHsKICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUdpTUd0KCkgKyB0aGlzLmVwczsKICAgIH0KCiAgfQogIEVxdWF0aW9uLmlkQ291bnRlciA9IDA7CiAgY29uc3QgaU1maSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaU1maiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW52SWlfdm11bHRfdGF1aSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgaW52SWpfdm11bHRfdGF1aiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wID0gbmV3IFZlYzMoKTsKICBjb25zdCBhZGRUb1dsYW1iZGFfdGVtcCA9IG5ldyBWZWMzKCk7CgogIC8qKgogICAqIENvbnRhY3Qvbm9uLXBlbmV0cmF0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb24KICAgKi8KICBjbGFzcyBDb250YWN0RXF1YXRpb24gZXh0ZW5kcyBFcXVhdGlvbiB7CiAgICAvKioKICAgICAqICJib3VuY2luZXNzIjogdTEgPSAtZSp1MAogICAgICovCgogICAgLyoqCiAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgdGhhdCBnb2VzIGZyb20gdGhlIGNlbnRlciBvZiBiaSB0byB0aGUgY29udGFjdCBwb2ludC4KICAgICAqLwoKICAgIC8qKgogICAgICogV29ybGQtb3JpZW50ZWQgdmVjdG9yIHRoYXQgc3RhcnRzIGluIGJvZHkgaiBwb3NpdGlvbiBhbmQgZ29lcyB0byB0aGUgY29udGFjdCBwb2ludC4KICAgICAqLwoKICAgIC8qKgogICAgICogQ29udGFjdCBub3JtYWwsIHBvaW50aW5nIG91dCBvZiBib2R5IGkuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5QiwgbWF4Rm9yY2UpIHsKICAgICAgaWYgKG1heEZvcmNlID09PSB2b2lkIDApIHsKICAgICAgICBtYXhGb3JjZSA9IDFlNjsKICAgICAgfQoKICAgICAgc3VwZXIoYm9keUEsIGJvZHlCLCAwLCBtYXhGb3JjZSk7CiAgICAgIHRoaXMucmVzdGl0dXRpb24gPSAwLjA7CiAgICAgIHRoaXMucmkgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnJqID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5uaSA9IG5ldyBWZWMzKCk7CiAgICB9CgogICAgY29tcHV0ZUIoaCkgewogICAgICBjb25zdCBhID0gdGhpcy5hOwogICAgICBjb25zdCBiID0gdGhpcy5iOwogICAgICBjb25zdCBiaSA9IHRoaXMuYmk7CiAgICAgIGNvbnN0IGJqID0gdGhpcy5iajsKICAgICAgY29uc3QgcmkgPSB0aGlzLnJpOwogICAgICBjb25zdCByaiA9IHRoaXMucmo7CiAgICAgIGNvbnN0IHJpeG4gPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDE7CiAgICAgIGNvbnN0IHJqeG4gPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDI7CiAgICAgIGNvbnN0IHZpID0gYmkudmVsb2NpdHk7CiAgICAgIGNvbnN0IHdpID0gYmkuYW5ndWxhclZlbG9jaXR5OwogICAgICBiaS5mb3JjZTsKICAgICAgYmkudG9ycXVlOwogICAgICBjb25zdCB2aiA9IGJqLnZlbG9jaXR5OwogICAgICBjb25zdCB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTsKICAgICAgYmouZm9yY2U7CiAgICAgIGJqLnRvcnF1ZTsKICAgICAgY29uc3QgcGVuZXRyYXRpb25WZWMgPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDM7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsKICAgICAgY29uc3QgbiA9IHRoaXMubmk7IC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0cwoKICAgICAgcmkuY3Jvc3Mobiwgcml4bik7CiAgICAgIHJqLmNyb3NzKG4sIHJqeG4pOyAvLyBnID0geGorcmogLSh4aStyaSkKICAgICAgLy8gRyA9IFsgLW5pICAtcml4biAgbmkgIHJqeG4gXQoKICAgICAgbi5uZWdhdGUoR0Euc3BhdGlhbCk7CiAgICAgIHJpeG4ubmVnYXRlKEdBLnJvdGF0aW9uYWwpOwogICAgICBHQi5zcGF0aWFsLmNvcHkobik7CiAgICAgIEdCLnJvdGF0aW9uYWwuY29weShyanhuKTsgLy8gQ2FsY3VsYXRlIHRoZSBwZW5ldHJhdGlvbiB2ZWN0b3IKCiAgICAgIHBlbmV0cmF0aW9uVmVjLmNvcHkoYmoucG9zaXRpb24pOwogICAgICBwZW5ldHJhdGlvblZlYy52YWRkKHJqLCBwZW5ldHJhdGlvblZlYyk7CiAgICAgIHBlbmV0cmF0aW9uVmVjLnZzdWIoYmkucG9zaXRpb24sIHBlbmV0cmF0aW9uVmVjKTsKICAgICAgcGVuZXRyYXRpb25WZWMudnN1YihyaSwgcGVuZXRyYXRpb25WZWMpOwogICAgICBjb25zdCBnID0gbi5kb3QocGVuZXRyYXRpb25WZWMpOyAvLyBDb21wdXRlIGl0ZXJhdGlvbgoKICAgICAgY29uc3QgZVBsdXNPbmUgPSB0aGlzLnJlc3RpdHV0aW9uICsgMTsKICAgICAgY29uc3QgR1cgPSBlUGx1c09uZSAqIHZqLmRvdChuKSAtIGVQbHVzT25lICogdmkuZG90KG4pICsgd2ouZG90KHJqeG4pIC0gd2kuZG90KHJpeG4pOwogICAgICBjb25zdCBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpOwogICAgICBjb25zdCBCID0gLWcgKiBhIC0gR1cgKiBiIC0gaCAqIEdpTWY7CiAgICAgIHJldHVybiBCOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcmVsYXRpdmUgdmVsb2NpdHkgaW4gdGhlIGNvbnRhY3QgcG9pbnQuCiAgICAgKi8KCgogICAgZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbCgpIHsKICAgICAgY29uc3QgdmkgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aTsKICAgICAgY29uc3QgdmogPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92ajsKICAgICAgY29uc3QgeGkgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aTsKICAgICAgY29uc3QgeGogPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94ajsKICAgICAgY29uc3QgcmVsVmVsID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfcmVsVmVsOwogICAgICB0aGlzLmJpLnBvc2l0aW9uLnZhZGQodGhpcy5yaSwgeGkpOwogICAgICB0aGlzLmJqLnBvc2l0aW9uLnZhZGQodGhpcy5yaiwgeGopOwogICAgICB0aGlzLmJpLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHhpLCB2aSk7CiAgICAgIHRoaXMuYmouZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoeGosIHZqKTsKICAgICAgdmkudnN1Yih2aiwgcmVsVmVsKTsKICAgICAgcmV0dXJuIHRoaXMubmkuZG90KHJlbFZlbCk7CiAgICB9CgogIH0KICBjb25zdCBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDEgPSBuZXcgVmVjMygpOyAvLyBUZW1wIHZlY3RvcnMKCiAgY29uc3QgQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyID0gbmV3IFZlYzMoKTsKICBjb25zdCBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDMgPSBuZXcgVmVjMygpOwogIGNvbnN0IENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3ZpID0gbmV3IFZlYzMoKTsKICBjb25zdCBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGkgPSBuZXcgVmVjMygpOwogIGNvbnN0IENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3hqID0gbmV3IFZlYzMoKTsKICBjb25zdCBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF9yZWxWZWwgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBDb25uZWN0cyB0d28gYm9kaWVzIGF0IGdpdmVuIG9mZnNldCBwb2ludHMuCiAgICogQGV4YW1wbGUKICAgKiAgICAgY29uc3QgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSkKICAgKiAgICAgY29uc3QgYm9keUIgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSkKICAgKiAgICAgYm9keUEucG9zaXRpb24uc2V0KC0xLCAwLCAwKQogICAqICAgICBib2R5Qi5wb3NpdGlvbi5zZXQoMSwgMCwgMCkKICAgKiAgICAgYm9keUEuYWRkU2hhcGUoc2hhcGVBKQogICAqICAgICBib2R5Qi5hZGRTaGFwZShzaGFwZUIpCiAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keUEpCiAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keUIpCiAgICogICAgIGNvbnN0IGxvY2FsUGl2b3RBID0gbmV3IFZlYzMoMSwgMCwgMCkKICAgKiAgICAgY29uc3QgbG9jYWxQaXZvdEIgPSBuZXcgVmVjMygtMSwgMCwgMCkKICAgKiAgICAgY29uc3QgY29uc3RyYWludCA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KGJvZHlBLCBsb2NhbFBpdm90QSwgYm9keUIsIGxvY2FsUGl2b3RCKQogICAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpCiAgICovCiAgY2xhc3MgUG9pbnRUb1BvaW50Q29uc3RyYWludCBleHRlbmRzIENvbnN0cmFpbnQgewogICAgLyoqCiAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLgogICAgICovCgogICAgLyoqCiAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCLgogICAgICovCgogICAgLyoqCiAgICAgKiBAcGFyYW0gcGl2b3RBIFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgd2hpY2ggYm9keUEgaXMgY29uc3RyYWluZWQgdG8uCiAgICAgKiBAcGFyYW0gYm9keUIgQm9keSB0aGF0IHdpbGwgYmUgY29uc3RyYWluZWQgaW4gYSBzaW1pbGFyIHdheSB0byB0aGUgc2FtZSBwb2ludCBhcyBib2R5QS4gV2Ugd2lsbCB0aGVyZWZvcmUgZ2V0IGEgbGluayBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5Qi4gSWYgbm90IHNwZWNpZmllZCwgYm9keUEgd2lsbCBiZSBjb25zdHJhaW5lZCB0byBhIHN0YXRpYyBwb2ludC4KICAgICAqIEBwYXJhbSBwaXZvdEIgVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyBvZiBib2R5QiB3aGljaCBib2R5QiBpcyBjb25zdHJhaW5lZCB0by4KICAgICAqIEBwYXJhbSBtYXhGb3JjZSBUaGUgbWF4aW11bSBmb3JjZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGNvbnN0cmFpbiB0aGUgYm9kaWVzLgogICAgICovCiAgICBjb25zdHJ1Y3Rvcihib2R5QSwgcGl2b3RBLCBib2R5QiwgcGl2b3RCLCBtYXhGb3JjZSkgewogICAgICBpZiAocGl2b3RBID09PSB2b2lkIDApIHsKICAgICAgICBwaXZvdEEgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBpZiAocGl2b3RCID09PSB2b2lkIDApIHsKICAgICAgICBwaXZvdEIgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICBpZiAobWF4Rm9yY2UgPT09IHZvaWQgMCkgewogICAgICAgIG1heEZvcmNlID0gMWU2OwogICAgICB9CgogICAgICBzdXBlcihib2R5QSwgYm9keUIpOwogICAgICB0aGlzLnBpdm90QSA9IHBpdm90QS5jbG9uZSgpOwogICAgICB0aGlzLnBpdm90QiA9IHBpdm90Qi5jbG9uZSgpOwogICAgICBjb25zdCB4ID0gdGhpcy5lcXVhdGlvblggPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qik7CiAgICAgIGNvbnN0IHkgPSB0aGlzLmVxdWF0aW9uWSA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCKTsKICAgICAgY29uc3QgeiA9IHRoaXMuZXF1YXRpb25aID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSwgYm9keUIpOyAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXIKCiAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goeCwgeSwgeik7IC8vIE1ha2UgdGhlIGVxdWF0aW9ucyBiaWRpcmVjdGlvbmFsCgogICAgICB4Lm1pbkZvcmNlID0geS5taW5Gb3JjZSA9IHoubWluRm9yY2UgPSAtbWF4Rm9yY2U7CiAgICAgIHgubWF4Rm9yY2UgPSB5Lm1heEZvcmNlID0gei5tYXhGb3JjZSA9IG1heEZvcmNlOwogICAgICB4Lm5pLnNldCgxLCAwLCAwKTsKICAgICAgeS5uaS5zZXQoMCwgMSwgMCk7CiAgICAgIHoubmkuc2V0KDAsIDAsIDEpOwogICAgfQoKICAgIHVwZGF0ZSgpIHsKICAgICAgY29uc3QgYm9keUEgPSB0aGlzLmJvZHlBOwogICAgICBjb25zdCBib2R5QiA9IHRoaXMuYm9keUI7CiAgICAgIGNvbnN0IHggPSB0aGlzLmVxdWF0aW9uWDsKICAgICAgY29uc3QgeSA9IHRoaXMuZXF1YXRpb25ZOwogICAgICBjb25zdCB6ID0gdGhpcy5lcXVhdGlvblo7IC8vIFJvdGF0ZSB0aGUgcGl2b3RzIHRvIHdvcmxkIHNwYWNlCgogICAgICBib2R5QS5xdWF0ZXJuaW9uLnZtdWx0KHRoaXMucGl2b3RBLCB4LnJpKTsKICAgICAgYm9keUIucXVhdGVybmlvbi52bXVsdCh0aGlzLnBpdm90QiwgeC5yaik7CiAgICAgIHkucmkuY29weSh4LnJpKTsKICAgICAgeS5yai5jb3B5KHgucmopOwogICAgICB6LnJpLmNvcHkoeC5yaSk7CiAgICAgIHoucmouY29weSh4LnJqKTsKICAgIH0KCiAgfQoKICAvKioKICAgKiBDb25lIGVxdWF0aW9uLiBXb3JrcyB0byBrZWVwIHRoZSBnaXZlbiBib2R5IHdvcmxkIHZlY3RvcnMgYWxpZ25lZCwgb3IgdGlsdGVkIHdpdGhpbiBhIGdpdmVuIGFuZ2xlIGZyb20gZWFjaCBvdGhlci4KICAgKi8KICBjbGFzcyBDb25lRXF1YXRpb24gZXh0ZW5kcyBFcXVhdGlvbiB7CiAgICAvKioKICAgICAqIExvY2FsIGF4aXMgaW4gQQogICAgICovCgogICAgLyoqCiAgICAgKiBMb2NhbCBheGlzIGluIEIKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlICJjb25lIGFuZ2xlIiB0byBrZWVwCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBjb25zdCBtYXhGb3JjZSA9IHR5cGVvZiBvcHRpb25zLm1heEZvcmNlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7CiAgICAgIHN1cGVyKGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSk7CiAgICAgIHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7CiAgICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7CiAgICAgIHRoaXMuYW5nbGUgPSB0eXBlb2Ygb3B0aW9ucy5hbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ2xlIDogMDsKICAgIH0KCiAgICBjb21wdXRlQihoKSB7CiAgICAgIGNvbnN0IGEgPSB0aGlzLmE7CiAgICAgIGNvbnN0IGIgPSB0aGlzLmI7CiAgICAgIGNvbnN0IG5pID0gdGhpcy5heGlzQTsKICAgICAgY29uc3QgbmogPSB0aGlzLmF4aXNCOwogICAgICBjb25zdCBuaXhuaiA9IHRtcFZlYzEkMjsKICAgICAgY29uc3Qgbmp4bmkgPSB0bXBWZWMyJDI7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzCgogICAgICBuaS5jcm9zcyhuaiwgbml4bmopOwogICAgICBuai5jcm9zcyhuaSwgbmp4bmkpOyAvLyBUaGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9yIGlzOgogICAgICAvLyBjb3ModGhldGEpID0gYSAqIGIgLyAobGVuZ3RoKGEpICogbGVuZ3RoKGIpID0geyBsZW4oYSkgPSBsZW4oYikgPSAxIH0gPSBhICogYgogICAgICAvLyBnID0gYSAqIGIKICAgICAgLy8gZ2RvdCA9IChiIHggYSkgKiB3aSArIChhIHggYikgKiB3agogICAgICAvLyBHID0gWzAgYnhhIDAgYXhiXQogICAgICAvLyBXID0gW3ZpIHdpIHZqIHdqXQoKICAgICAgR0Eucm90YXRpb25hbC5jb3B5KG5qeG5pKTsKICAgICAgR0Iucm90YXRpb25hbC5jb3B5KG5peG5qKTsKICAgICAgY29uc3QgZyA9IE1hdGguY29zKHRoaXMuYW5nbGUpIC0gbmkuZG90KG5qKTsKICAgICAgY29uc3QgR1cgPSB0aGlzLmNvbXB1dGVHVygpOwogICAgICBjb25zdCBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpOwogICAgICBjb25zdCBCID0gLWcgKiBhIC0gR1cgKiBiIC0gaCAqIEdpTWY7CiAgICAgIHJldHVybiBCOwogICAgfQoKICB9CiAgY29uc3QgdG1wVmVjMSQyID0gbmV3IFZlYzMoKTsKICBjb25zdCB0bXBWZWMyJDIgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBSb3RhdGlvbmFsIGNvbnN0cmFpbnQuIFdvcmtzIHRvIGtlZXAgdGhlIGxvY2FsIHZlY3RvcnMgb3J0aG9nb25hbCB0byBlYWNoIG90aGVyIGluIHdvcmxkIHNwYWNlLgogICAqLwogIGNsYXNzIFJvdGF0aW9uYWxFcXVhdGlvbiBleHRlbmRzIEVxdWF0aW9uIHsKICAgIC8qKgogICAgICogV29ybGQgb3JpZW50ZWQgcm90YXRpb25hbCBheGlzLgogICAgICovCgogICAgLyoqCiAgICAgKiBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIG1heEFuZ2xlCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBjb25zdCBtYXhGb3JjZSA9IHR5cGVvZiBvcHRpb25zLm1heEZvcmNlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7CiAgICAgIHN1cGVyKGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSk7CiAgICAgIHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7CiAgICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7CiAgICAgIHRoaXMubWF4QW5nbGUgPSBNYXRoLlBJIC8gMjsKICAgIH0KCiAgICBjb21wdXRlQihoKSB7CiAgICAgIGNvbnN0IGEgPSB0aGlzLmE7CiAgICAgIGNvbnN0IGIgPSB0aGlzLmI7CiAgICAgIGNvbnN0IG5pID0gdGhpcy5heGlzQTsKICAgICAgY29uc3QgbmogPSB0aGlzLmF4aXNCOwogICAgICBjb25zdCBuaXhuaiA9IHRtcFZlYzEkMTsKICAgICAgY29uc3Qgbmp4bmkgPSB0bXBWZWMyJDE7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzCgogICAgICBuaS5jcm9zcyhuaiwgbml4bmopOwogICAgICBuai5jcm9zcyhuaSwgbmp4bmkpOyAvLyBnID0gbmkgKiBuagogICAgICAvLyBnZG90ID0gKG5qIHggbmkpICogd2kgKyAobmkgeCBuaikgKiB3agogICAgICAvLyBHID0gWzAgbmp4bmkgMCBuaXhual0KICAgICAgLy8gVyA9IFt2aSB3aSB2aiB3al0KCiAgICAgIEdBLnJvdGF0aW9uYWwuY29weShuanhuaSk7CiAgICAgIEdCLnJvdGF0aW9uYWwuY29weShuaXhuaik7CiAgICAgIGNvbnN0IGcgPSBNYXRoLmNvcyh0aGlzLm1heEFuZ2xlKSAtIG5pLmRvdChuaik7CiAgICAgIGNvbnN0IEdXID0gdGhpcy5jb21wdXRlR1coKTsKICAgICAgY29uc3QgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTsKICAgICAgY29uc3QgQiA9IC1nICogYSAtIEdXICogYiAtIGggKiBHaU1mOwogICAgICByZXR1cm4gQjsKICAgIH0KCiAgfQogIGNvbnN0IHRtcFZlYzEkMSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wVmVjMiQxID0gbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQSBDb25lIFR3aXN0IGNvbnN0cmFpbnQsIHVzZWZ1bCBmb3IgcmFnZG9sbHMuCiAgICovCiAgY2xhc3MgQ29uZVR3aXN0Q29uc3RyYWludCBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnQgewogICAgLyoqCiAgICAgKiBUaGUgYXhpcyBkaXJlY3Rpb24gZm9yIHRoZSBjb25zdHJhaW50IG9mIHRoZSBib2R5IEEuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBheGlzIGRpcmVjdGlvbiBmb3IgdGhlIGNvbnN0cmFpbnQgb2YgdGhlIGJvZHkgQi4KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGFwZXJ0dXJlIGFuZ2xlIG9mIHRoZSBjb25lLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGUgdHdpc3QgYW5nbGUgb2YgdGhlIGpvaW50LgogICAgICovCiAgICBjb25zdHJ1Y3Rvcihib2R5QSwgYm9keUIsIG9wdGlvbnMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgY29uc3QgbWF4Rm9yY2UgPSB0eXBlb2Ygb3B0aW9ucy5tYXhGb3JjZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heEZvcmNlIDogMWU2OyAvLyBTZXQgcGl2b3QgcG9pbnQgaW4gYmV0d2VlbgoKICAgICAgY29uc3QgcGl2b3RBID0gb3B0aW9ucy5waXZvdEEgPyBvcHRpb25zLnBpdm90QS5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgY29uc3QgcGl2b3RCID0gb3B0aW9ucy5waXZvdEIgPyBvcHRpb25zLnBpdm90Qi5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgc3VwZXIoYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpOwogICAgICB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gISFvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ7CiAgICAgIHRoaXMuYW5nbGUgPSB0eXBlb2Ygb3B0aW9ucy5hbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ2xlIDogMDsKICAgICAgY29uc3QgYyA9IHRoaXMuY29uZUVxdWF0aW9uID0gbmV3IENvbmVFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpOwogICAgICBjb25zdCB0ID0gdGhpcy50d2lzdEVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpOwogICAgICB0aGlzLnR3aXN0QW5nbGUgPSB0eXBlb2Ygb3B0aW9ucy50d2lzdEFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMudHdpc3RBbmdsZSA6IDA7IC8vIE1ha2UgdGhlIGNvbmUgZXF1YXRpb24gcHVzaCB0aGUgYm9kaWVzIHRvd2FyZCB0aGUgY29uZSBheGlzLCBub3Qgb3V0d2FyZAoKICAgICAgYy5tYXhGb3JjZSA9IDA7CiAgICAgIGMubWluRm9yY2UgPSAtbWF4Rm9yY2U7IC8vIE1ha2UgdGhlIHR3aXN0IGVxdWF0aW9uIGFkZCB0b3JxdWUgdG93YXJkIHRoZSBpbml0aWFsIHBvc2l0aW9uCgogICAgICB0Lm1heEZvcmNlID0gMDsKICAgICAgdC5taW5Gb3JjZSA9IC1tYXhGb3JjZTsKICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaChjLCB0KTsKICAgIH0KCiAgICB1cGRhdGUoKSB7CiAgICAgIGNvbnN0IGJvZHlBID0gdGhpcy5ib2R5QTsKICAgICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCOwogICAgICBjb25zdCBjb25lID0gdGhpcy5jb25lRXF1YXRpb247CiAgICAgIGNvbnN0IHR3aXN0ID0gdGhpcy50d2lzdEVxdWF0aW9uOwogICAgICBzdXBlci51cGRhdGUoKTsgLy8gVXBkYXRlIHRoZSBheGVzIHRvIHRoZSBjb25lIGNvbnN0cmFpbnQKCiAgICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLmF4aXNBLCBjb25lLmF4aXNBKTsKICAgICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuYXhpc0IsIGNvbmUuYXhpc0IpOyAvLyBVcGRhdGUgdGhlIHdvcmxkIGF4ZXMgaW4gdGhlIHR3aXN0IGNvbnN0cmFpbnQKCiAgICAgIHRoaXMuYXhpc0EudGFuZ2VudHModHdpc3QuYXhpc0EsIHR3aXN0LmF4aXNBKTsKICAgICAgYm9keUEudmVjdG9yVG9Xb3JsZEZyYW1lKHR3aXN0LmF4aXNBLCB0d2lzdC5heGlzQSk7CiAgICAgIHRoaXMuYXhpc0IudGFuZ2VudHModHdpc3QuYXhpc0IsIHR3aXN0LmF4aXNCKTsKICAgICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKHR3aXN0LmF4aXNCLCB0d2lzdC5heGlzQik7CiAgICAgIGNvbmUuYW5nbGUgPSB0aGlzLmFuZ2xlOwogICAgICB0d2lzdC5tYXhBbmdsZSA9IHRoaXMudHdpc3RBbmdsZTsKICAgIH0KCiAgfQogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQ29uc3RyYWlucyB0d28gYm9kaWVzIHRvIGJlIGF0IGEgY29uc3RhbnQgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVycyBjZW50ZXIgb2YgbWFzcy4KICAgKi8KICBjbGFzcyBEaXN0YW5jZUNvbnN0cmFpbnQgZXh0ZW5kcyBDb25zdHJhaW50IHsKICAgIC8qKgogICAgICogVGhlIGRpc3RhbmNlIHRvIGtlZXAuIElmIHVuZGVmaW5lZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiBib2R5QSBhbmQgYm9keUIKICAgICAqLwoKICAgIC8qKgogICAgICogQHBhcmFtIGRpc3RhbmNlIFRoZSBkaXN0YW5jZSB0byBrZWVwLiBJZiB1bmRlZmluZWQsIGl0IHdpbGwgYmUgc2V0IHRvIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gYm9keUEgYW5kIGJvZHlCLgogICAgICogQHBhcmFtIG1heEZvcmNlIFRoZSBtYXhpbXVtIGZvcmNlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gY29uc3RyYWluIHRoZSBib2RpZXMuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5QiwgZGlzdGFuY2UsIG1heEZvcmNlKSB7CiAgICAgIGlmIChtYXhGb3JjZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgbWF4Rm9yY2UgPSAxZTY7CiAgICAgIH0KCiAgICAgIHN1cGVyKGJvZHlBLCBib2R5Qik7CgogICAgICBpZiAodHlwZW9mIGRpc3RhbmNlID09PSAndW5kZWZpbmVkJykgewogICAgICAgIGRpc3RhbmNlID0gYm9keUEucG9zaXRpb24uZGlzdGFuY2VUbyhib2R5Qi5wb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTsKICAgICAgY29uc3QgZXEgPSB0aGlzLmRpc3RhbmNlRXF1YXRpb24gPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qik7CiAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpOyAvLyBNYWtlIGl0IGJpZGlyZWN0aW9uYWwKCiAgICAgIGVxLm1pbkZvcmNlID0gLW1heEZvcmNlOwogICAgICBlcS5tYXhGb3JjZSA9IG1heEZvcmNlOwogICAgfQogICAgLyoqCiAgICAgKiB1cGRhdGUKICAgICAqLwoKCiAgICB1cGRhdGUoKSB7CiAgICAgIGNvbnN0IGJvZHlBID0gdGhpcy5ib2R5QTsKICAgICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCOwogICAgICBjb25zdCBlcSA9IHRoaXMuZGlzdGFuY2VFcXVhdGlvbjsKICAgICAgY29uc3QgaGFsZkRpc3QgPSB0aGlzLmRpc3RhbmNlICogMC41OwogICAgICBjb25zdCBub3JtYWwgPSBlcS5uaTsKICAgICAgYm9keUIucG9zaXRpb24udnN1Yihib2R5QS5wb3NpdGlvbiwgbm9ybWFsKTsKICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpOwogICAgICBub3JtYWwuc2NhbGUoaGFsZkRpc3QsIGVxLnJpKTsKICAgICAgbm9ybWFsLnNjYWxlKC1oYWxmRGlzdCwgZXEucmopOwogICAgfQoKICB9CgogIC8qKgogICAqIExvY2sgY29uc3RyYWludC4gV2lsbCByZW1vdmUgYWxsIGRlZ3JlZXMgb2YgZnJlZWRvbSBiZXR3ZWVuIHRoZSBib2RpZXMuCiAgICovCiAgY2xhc3MgTG9ja0NvbnN0cmFpbnQgZXh0ZW5kcyBQb2ludFRvUG9pbnRDb25zdHJhaW50IHsKICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBjb25zdCBtYXhGb3JjZSA9IHR5cGVvZiBvcHRpb25zLm1heEZvcmNlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7IC8vIFNldCBwaXZvdCBwb2ludCBpbiBiZXR3ZWVuCgogICAgICBjb25zdCBwaXZvdEEgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBwaXZvdEIgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBoYWxmV2F5ID0gbmV3IFZlYzMoKTsKICAgICAgYm9keUEucG9zaXRpb24udmFkZChib2R5Qi5wb3NpdGlvbiwgaGFsZldheSk7CiAgICAgIGhhbGZXYXkuc2NhbGUoMC41LCBoYWxmV2F5KTsKICAgICAgYm9keUIucG9pbnRUb0xvY2FsRnJhbWUoaGFsZldheSwgcGl2b3RCKTsKICAgICAgYm9keUEucG9pbnRUb0xvY2FsRnJhbWUoaGFsZldheSwgcGl2b3RBKTsgLy8gVGhlIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnQgd2lsbCBrZWVwIGEgcG9pbnQgc2hhcmVkIGJldHdlZW4gdGhlIGJvZGllcwoKICAgICAgc3VwZXIoYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpOyAvLyBTdG9yZSBpbml0aWFsIHJvdGF0aW9uIG9mIHRoZSBib2RpZXMgYXMgdW5pdCB2ZWN0b3JzIGluIHRoZSBsb2NhbCBib2R5IHNwYWNlcwoKICAgICAgdGhpcy54QSA9IGJvZHlBLnZlY3RvclRvTG9jYWxGcmFtZShWZWMzLlVOSVRfWCk7CiAgICAgIHRoaXMueEIgPSBib2R5Qi52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1gpOwogICAgICB0aGlzLnlBID0gYm9keUEudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9ZKTsKICAgICAgdGhpcy55QiA9IGJvZHlCLnZlY3RvclRvTG9jYWxGcmFtZShWZWMzLlVOSVRfWSk7CiAgICAgIHRoaXMuekEgPSBib2R5QS52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1opOwogICAgICB0aGlzLnpCID0gYm9keUIudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9aKTsgLy8gLi4uYW5kIHRoZSBmb2xsb3dpbmcgcm90YXRpb25hbCBlcXVhdGlvbnMgd2lsbCBrZWVwIGFsbCByb3RhdGlvbmFsIERPRidzIGluIHBsYWNlCgogICAgICBjb25zdCByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKTsKICAgICAgY29uc3QgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7CiAgICAgIGNvbnN0IHIzID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24zID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpOwogICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHIxLCByMiwgcjMpOwogICAgfQogICAgLyoqCiAgICAgKiB1cGRhdGUKICAgICAqLwoKCiAgICB1cGRhdGUoKSB7CiAgICAgIGNvbnN0IGJvZHlBID0gdGhpcy5ib2R5QTsKICAgICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCOwogICAgICB0aGlzLm1vdG9yRXF1YXRpb247CiAgICAgIGNvbnN0IHIxID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24xOwogICAgICBjb25zdCByMiA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMjsKICAgICAgY29uc3QgcjMgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjM7CiAgICAgIHN1cGVyLnVwZGF0ZSgpOyAvLyBUaGVzZSB2ZWN0b3IgcGFpcnMgbXVzdCBiZSBvcnRob2dvbmFsCgogICAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy54QSwgcjEuYXhpc0EpOwogICAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy55QiwgcjEuYXhpc0IpOwogICAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy55QSwgcjIuYXhpc0EpOwogICAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy56QiwgcjIuYXhpc0IpOwogICAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy56QSwgcjMuYXhpc0EpOwogICAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy54QiwgcjMuYXhpc0IpOwogICAgfQoKICB9CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwoKICAvKioKICAgKiBSb3RhdGlvbmFsIG1vdG9yIGNvbnN0cmFpbnQuIFRyaWVzIHRvIGtlZXAgdGhlIHJlbGF0aXZlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZGllcyB0byBhIGdpdmVuIHZhbHVlLgogICAqLwogIGNsYXNzIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uIGV4dGVuZHMgRXF1YXRpb24gewogICAgLyoqCiAgICAgKiBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFdvcmxkIG9yaWVudGVkIHJvdGF0aW9uYWwgYXhpcy4KICAgICAqLwoKICAgIC8qKgogICAgICogTW90b3IgdmVsb2NpdHkuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5QiwgbWF4Rm9yY2UpIHsKICAgICAgaWYgKG1heEZvcmNlID09PSB2b2lkIDApIHsKICAgICAgICBtYXhGb3JjZSA9IDFlNjsKICAgICAgfQoKICAgICAgc3VwZXIoYm9keUEsIGJvZHlCLCAtbWF4Rm9yY2UsIG1heEZvcmNlKTsKICAgICAgdGhpcy5heGlzQSA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMuYXhpc0IgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnRhcmdldFZlbG9jaXR5ID0gMDsKICAgIH0KCiAgICBjb21wdXRlQihoKSB7CiAgICAgIHRoaXMuYTsKICAgICAgY29uc3QgYiA9IHRoaXMuYjsKICAgICAgdGhpcy5iaTsKICAgICAgdGhpcy5iajsKICAgICAgY29uc3QgYXhpc0EgPSB0aGlzLmF4aXNBOwogICAgICBjb25zdCBheGlzQiA9IHRoaXMuYXhpc0I7CiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsgLy8gZyA9IDAKICAgICAgLy8gZ2RvdCA9IGF4aXNBICogd2kgLSBheGlzQiAqIHdqCiAgICAgIC8vIGdkb3QgPSBHICogVyA9IEcgKiBbdmkgd2kgdmogd2pdCiAgICAgIC8vID0+CiAgICAgIC8vIEcgPSBbMCBheGlzQSAwIC1heGlzQl0KCiAgICAgIEdBLnJvdGF0aW9uYWwuY29weShheGlzQSk7CiAgICAgIGF4aXNCLm5lZ2F0ZShHQi5yb3RhdGlvbmFsKTsKICAgICAgY29uc3QgR1cgPSB0aGlzLmNvbXB1dGVHVygpIC0gdGhpcy50YXJnZXRWZWxvY2l0eTsKICAgICAgY29uc3QgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTsKICAgICAgY29uc3QgQiA9IC1HVyAqIGIgLSBoICogR2lNZjsKICAgICAgcmV0dXJuIEI7CiAgICB9CgogIH0KCiAgLyoqCiAgICogSGluZ2UgY29uc3RyYWludC4gVGhpbmsgb2YgaXQgYXMgYSBkb29yIGhpbmdlLiBJdCB0cmllcyB0byBrZWVwIHRoZSBkb29yIGluIHRoZSBjb3JyZWN0IHBsYWNlIGFuZCB3aXRoIHRoZSBjb3JyZWN0IG9yaWVudGF0aW9uLgogICAqLwogIGNsYXNzIEhpbmdlQ29uc3RyYWludCBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnQgewogICAgLyoqCiAgICAgKiBSb3RhdGlvbiBheGlzLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFJvdGF0aW9uIGF4aXMsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5Qi4KICAgICAqLwogICAgY29uc3RydWN0b3IoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIGNvbnN0IG1heEZvcmNlID0gdHlwZW9mIG9wdGlvbnMubWF4Rm9yY2UgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjsKICAgICAgY29uc3QgcGl2b3RBID0gb3B0aW9ucy5waXZvdEEgPyBvcHRpb25zLnBpdm90QS5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgY29uc3QgcGl2b3RCID0gb3B0aW9ucy5waXZvdEIgPyBvcHRpb25zLnBpdm90Qi5jbG9uZSgpIDogbmV3IFZlYzMoKTsKICAgICAgc3VwZXIoYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpOwogICAgICBjb25zdCBheGlzQSA9IHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7CiAgICAgIGF4aXNBLm5vcm1hbGl6ZSgpOwogICAgICBjb25zdCBheGlzQiA9IHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7CiAgICAgIGF4aXNCLm5vcm1hbGl6ZSgpOwogICAgICB0aGlzLmNvbGxpZGVDb25uZWN0ZWQgPSAhIW9wdGlvbnMuY29sbGlkZUNvbm5lY3RlZDsKICAgICAgY29uc3Qgcm90YXRpb25hbDEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7CiAgICAgIGNvbnN0IHJvdGF0aW9uYWwyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpOwogICAgICBjb25zdCBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbihib2R5QSwgYm9keUIsIG1heEZvcmNlKTsKICAgICAgbW90b3IuZW5hYmxlZCA9IGZhbHNlOyAvLyBOb3QgZW5hYmxlZCBieSBkZWZhdWx0CiAgICAgIC8vIEVxdWF0aW9ucyB0byBiZSBmZWQgdG8gdGhlIHNvbHZlcgoKICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaChyb3RhdGlvbmFsMSwgcm90YXRpb25hbDIsIG1vdG9yKTsKICAgIH0KICAgIC8qKgogICAgICogZW5hYmxlTW90b3IKICAgICAqLwoKCiAgICBlbmFibGVNb3RvcigpIHsKICAgICAgdGhpcy5tb3RvckVxdWF0aW9uLmVuYWJsZWQgPSB0cnVlOwogICAgfQogICAgLyoqCiAgICAgKiBkaXNhYmxlTW90b3IKICAgICAqLwoKCiAgICBkaXNhYmxlTW90b3IoKSB7CiAgICAgIHRoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7CiAgICB9CiAgICAvKioKICAgICAqIHNldE1vdG9yU3BlZWQKICAgICAqLwoKCiAgICBzZXRNb3RvclNwZWVkKHNwZWVkKSB7CiAgICAgIHRoaXMubW90b3JFcXVhdGlvbi50YXJnZXRWZWxvY2l0eSA9IHNwZWVkOwogICAgfQogICAgLyoqCiAgICAgKiBzZXRNb3Rvck1heEZvcmNlCiAgICAgKi8KCgogICAgc2V0TW90b3JNYXhGb3JjZShtYXhGb3JjZSkgewogICAgICB0aGlzLm1vdG9yRXF1YXRpb24ubWF4Rm9yY2UgPSBtYXhGb3JjZTsKICAgICAgdGhpcy5tb3RvckVxdWF0aW9uLm1pbkZvcmNlID0gLW1heEZvcmNlOwogICAgfQogICAgLyoqCiAgICAgKiB1cGRhdGUKICAgICAqLwoKCiAgICB1cGRhdGUoKSB7CiAgICAgIGNvbnN0IGJvZHlBID0gdGhpcy5ib2R5QTsKICAgICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCOwogICAgICBjb25zdCBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbjsKICAgICAgY29uc3QgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjE7CiAgICAgIGNvbnN0IHIyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yOwogICAgICBjb25zdCB3b3JsZEF4aXNBID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxOwogICAgICBjb25zdCB3b3JsZEF4aXNCID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyOwogICAgICBjb25zdCBheGlzQSA9IHRoaXMuYXhpc0E7CiAgICAgIGNvbnN0IGF4aXNCID0gdGhpcy5heGlzQjsKICAgICAgc3VwZXIudXBkYXRlKCk7IC8vIEdldCB3b3JsZCBheGVzCgogICAgICBib2R5QS5xdWF0ZXJuaW9uLnZtdWx0KGF4aXNBLCB3b3JsZEF4aXNBKTsKICAgICAgYm9keUIucXVhdGVybmlvbi52bXVsdChheGlzQiwgd29ybGRBeGlzQik7CiAgICAgIHdvcmxkQXhpc0EudGFuZ2VudHMocjEuYXhpc0EsIHIyLmF4aXNBKTsKICAgICAgcjEuYXhpc0IuY29weSh3b3JsZEF4aXNCKTsKICAgICAgcjIuYXhpc0IuY29weSh3b3JsZEF4aXNCKTsKCiAgICAgIGlmICh0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCkgewogICAgICAgIGJvZHlBLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQSwgbW90b3IuYXhpc0EpOwogICAgICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQiwgbW90b3IuYXhpc0IpOwogICAgICB9CiAgICB9CgogIH0KICBjb25zdCBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEgPSBuZXcgVmVjMygpOwogIGNvbnN0IEhpbmdlQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMiA9IG5ldyBWZWMzKCk7CgogIC8qKgogICAqIENvbnN0cmFpbnMgdGhlIHNsaXBwaW5nIGluIGEgY29udGFjdCBhbG9uZyBhIHRhbmdlbnQKICAgKi8KICBjbGFzcyBGcmljdGlvbkVxdWF0aW9uIGV4dGVuZHMgRXF1YXRpb24gewogICAgLy8gVGFuZ2VudAoKICAgIC8qKgogICAgICogQHBhcmFtIHNsaXBGb3JjZSBzaG91bGQgYmUgKy1GX2ZyaWN0aW9uID0gKy1tdSAqIEZfbm9ybWFsID0gKy1tdSAqIG0gKiBnCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKSB7CiAgICAgIHN1cGVyKGJvZHlBLCBib2R5QiwgLXNsaXBGb3JjZSwgc2xpcEZvcmNlKTsKICAgICAgdGhpcy5yaSA9IG5ldyBWZWMzKCk7CiAgICAgIHRoaXMucmogPSBuZXcgVmVjMygpOwogICAgICB0aGlzLnQgPSBuZXcgVmVjMygpOwogICAgfQoKICAgIGNvbXB1dGVCKGgpIHsKICAgICAgdGhpcy5hOwogICAgICBjb25zdCBiID0gdGhpcy5iOwogICAgICB0aGlzLmJpOwogICAgICB0aGlzLmJqOwogICAgICBjb25zdCByaSA9IHRoaXMucmk7CiAgICAgIGNvbnN0IHJqID0gdGhpcy5yajsKICAgICAgY29uc3Qgcml4dCA9IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDE7CiAgICAgIGNvbnN0IHJqeHQgPSBGcmljdGlvbkVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyOwogICAgICBjb25zdCB0ID0gdGhpcy50OyAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHMKCiAgICAgIHJpLmNyb3NzKHQsIHJpeHQpOwogICAgICByai5jcm9zcyh0LCByanh0KTsgLy8gRyA9IFstdCAtcml4dCB0IHJqeHRdCiAgICAgIC8vIEFuZCByZW1lbWJlciwgdGhpcyBpcyBhIHB1cmUgdmVsb2NpdHkgY29uc3RyYWludCwgZyBpcyBhbHdheXMgemVybyEKCiAgICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBOwogICAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsKICAgICAgdC5uZWdhdGUoR0Euc3BhdGlhbCk7CiAgICAgIHJpeHQubmVnYXRlKEdBLnJvdGF0aW9uYWwpOwogICAgICBHQi5zcGF0aWFsLmNvcHkodCk7CiAgICAgIEdCLnJvdGF0aW9uYWwuY29weShyanh0KTsKICAgICAgY29uc3QgR1cgPSB0aGlzLmNvbXB1dGVHVygpOwogICAgICBjb25zdCBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpOwogICAgICBjb25zdCBCID0gLUdXICogYiAtIGggKiBHaU1mOwogICAgICByZXR1cm4gQjsKICAgIH0KCiAgfQogIGNvbnN0IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDIgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHR3byBtYXRlcmlhbHMgbWVldC4KICAgKiBAdG9kbyBSZWZhY3RvciBtYXRlcmlhbHMgdG8gbWF0ZXJpYWxBIGFuZCBtYXRlcmlhbEIKICAgKi8KICBjbGFzcyBDb250YWN0TWF0ZXJpYWwgewogICAgLyoqCiAgICAgKiBJZGVudGlmaWVyIG9mIHRoaXMgbWF0ZXJpYWwuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFBhcnRpY2lwYXRpbmcgbWF0ZXJpYWxzLgogICAgICovCgogICAgLyoqCiAgICAgKiBGcmljdGlvbiBjb2VmZmljaWVudC4KICAgICAqIEBkZWZhdWx0IDAuMwogICAgICovCgogICAgLyoqCiAgICAgKiBSZXN0aXR1dGlvbiBjb2VmZmljaWVudC4KICAgICAqIEBkZWZhdWx0IDAuMwogICAgICovCgogICAgLyoqCiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHByb2R1Y2VkIGNvbnRhY3QgZXF1YXRpb25zLgogICAgICogQGRlZmF1bHQgMWU3CiAgICAgKi8KCiAgICAvKioKICAgICAqIFJlbGF4YXRpb24gdGltZSBvZiB0aGUgcHJvZHVjZWQgY29udGFjdCBlcXVhdGlvbnMuCiAgICAgKiBAZGVmYXVsdCAzCiAgICAgKi8KCiAgICAvKioKICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgcHJvZHVjZWQgZnJpY3Rpb24gZXF1YXRpb25zLgogICAgICogQGRlZmF1bHQgMWU3CiAgICAgKi8KCiAgICAvKioKICAgICAqIFJlbGF4YXRpb24gdGltZSBvZiB0aGUgcHJvZHVjZWQgZnJpY3Rpb24gZXF1YXRpb25zCiAgICAgKiBAZGVmYXVsdCAzCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKG0xLCBtMiwgb3B0aW9ucykgewogICAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywgewogICAgICAgIGZyaWN0aW9uOiAwLjMsCiAgICAgICAgcmVzdGl0dXRpb246IDAuMywKICAgICAgICBjb250YWN0RXF1YXRpb25TdGlmZm5lc3M6IDFlNywKICAgICAgICBjb250YWN0RXF1YXRpb25SZWxheGF0aW9uOiAzLAogICAgICAgIGZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3M6IDFlNywKICAgICAgICBmcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbjogMwogICAgICB9KTsKICAgICAgdGhpcy5pZCA9IENvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIrKzsKICAgICAgdGhpcy5tYXRlcmlhbHMgPSBbbTEsIG0yXTsKICAgICAgdGhpcy5mcmljdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb247CiAgICAgIHRoaXMucmVzdGl0dXRpb24gPSBvcHRpb25zLnJlc3RpdHV0aW9uOwogICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzOwogICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24gPSBvcHRpb25zLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb247CiAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzczsKICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb247CiAgICB9CgogIH0KICBDb250YWN0TWF0ZXJpYWwuaWRDb3VudGVyID0gMDsKCiAgLyoqCiAgICogRGVmaW5lcyBhIHBoeXNpY3MgbWF0ZXJpYWwuCiAgICovCiAgY2xhc3MgTWF0ZXJpYWwgewogICAgLyoqCiAgICAgKiBNYXRlcmlhbCBuYW1lLgogICAgICogSWYgb3B0aW9ucyBpcyBhIHN0cmluZywgbmFtZSB3aWxsIGJlIHNldCB0byB0aGF0IHN0cmluZy4KICAgICAqIEB0b2RvIERlcHJlY2F0ZSB0aGlzCiAgICAgKi8KCiAgICAvKiogTWF0ZXJpYWwgaWQuICovCgogICAgLyoqCiAgICAgKiBGcmljdGlvbiBmb3IgdGhpcyBtYXRlcmlhbC4KICAgICAqIElmIG5vbi1uZWdhdGl2ZSwgaXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGZyaWN0aW9uIGdpdmVuIGJ5IENvbnRhY3RNYXRlcmlhbHMuIElmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgQ29udGFjdE1hdGVyaWFsLCB0aGUgdmFsdWUgZnJvbSBgZGVmYXVsdENvbnRhY3RNYXRlcmlhbGAgaW4gdGhlIFdvcmxkIHdpbGwgYmUgdXNlZC4KICAgICAqLwoKICAgIC8qKgogICAgICogUmVzdGl0dXRpb24gZm9yIHRoaXMgbWF0ZXJpYWwuCiAgICAgKiBJZiBub24tbmVnYXRpdmUsIGl0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSByZXN0aXR1dGlvbiBnaXZlbiBieSBDb250YWN0TWF0ZXJpYWxzLiBJZiB0aGVyZSdzIG5vIG1hdGNoaW5nIENvbnRhY3RNYXRlcmlhbCwgdGhlIHZhbHVlIGZyb20gYGRlZmF1bHRDb250YWN0TWF0ZXJpYWxgIGluIHRoZSBXb3JsZCB3aWxsIGJlIHVzZWQuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHsKICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgewogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgICAgfQoKICAgICAgbGV0IG5hbWUgPSAnJzsgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZml4CgogICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgLy9jb25zb2xlLndhcm4oYFBhc3NpbmcgYSBzdHJpbmcgdG8gTWF0ZXJpYWxPcHRpb25zIGlzIGRlcHJlY2F0ZWQsIGFuZCBoYXMgbm8gZWZmZWN0YCkKICAgICAgICBuYW1lID0gb3B0aW9uczsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIHRoaXMubmFtZSA9IG5hbWU7CiAgICAgIHRoaXMuaWQgPSBNYXRlcmlhbC5pZENvdW50ZXIrKzsKICAgICAgdGhpcy5mcmljdGlvbiA9IHR5cGVvZiBvcHRpb25zLmZyaWN0aW9uICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuZnJpY3Rpb24gOiAtMTsKICAgICAgdGhpcy5yZXN0aXR1dGlvbiA9IHR5cGVvZiBvcHRpb25zLnJlc3RpdHV0aW9uICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMucmVzdGl0dXRpb24gOiAtMTsKICAgIH0KCiAgfQogIE1hdGVyaWFsLmlkQ291bnRlciA9IDA7CgogIC8qKgogICAqIEEgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMuCiAgICogQGV4YW1wbGUKICAgKiAgICAgY29uc3Qgc3ByaW5nID0gbmV3IFNwcmluZyhib3hCb2R5LCBzcGhlcmVCb2R5LCB7CiAgICogICAgICAgcmVzdExlbmd0aDogMCwKICAgKiAgICAgICBzdGlmZm5lc3M6IDUwLAogICAqICAgICAgIGRhbXBpbmc6IDEsCiAgICogICAgIH0pCiAgICoKICAgKiAgICAgLy8gQ29tcHV0ZSB0aGUgZm9yY2UgYWZ0ZXIgZWFjaCBzdGVwCiAgICogICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3Bvc3RTdGVwJywgKGV2ZW50KSA9PiB7CiAgICogICAgICAgc3ByaW5nLmFwcGx5Rm9yY2UoKQogICAqICAgICB9KQogICAqLwogIGNsYXNzIFNwcmluZyB7CiAgICAvKioKICAgICAqIFJlc3QgbGVuZ3RoIG9mIHRoZSBzcHJpbmcuIEEgbnVtYmVyID4gMC4KICAgICAqIEBkZWZhdWx0IDEKICAgICAqLwoKICAgIC8qKgogICAgICogU3RpZmZuZXNzIG9mIHRoZSBzcHJpbmcuIEEgbnVtYmVyID49IDAuCiAgICAgKiBAZGVmYXVsdCAxMDAKICAgICAqLwoKICAgIC8qKgogICAgICogRGFtcGluZyBvZiB0aGUgc3ByaW5nLiBBIG51bWJlciA+PSAwLgogICAgICogQGRlZmF1bHQgMQogICAgICovCgogICAgLyoqCiAgICAgKiBGaXJzdCBjb25uZWN0ZWQgYm9keS4KICAgICAqLwoKICAgIC8qKgogICAgICogU2Vjb25kIGNvbm5lY3RlZCBib2R5LgogICAgICovCgogICAgLyoqCiAgICAgKiBBbmNob3IgZm9yIGJvZHlBIGluIGxvY2FsIGJvZHlBIGNvb3JkaW5hdGVzLgogICAgICogV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gbG9jYWwgYm9keSBjb29yZGluYXRlcy4KICAgICAqIEBkZWZhdWx0IG5ldyBWZWMzKCkKICAgICAqLwoKICAgIC8qKgogICAgICogQW5jaG9yIGZvciBib2R5QiBpbiBsb2NhbCBib2R5QiBjb29yZGluYXRlcy4KICAgICAqIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEIsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuCiAgICAgKiBAZGVmYXVsdCBuZXcgVmVjMygpCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICB0aGlzLnJlc3RMZW5ndGggPSB0eXBlb2Ygb3B0aW9ucy5yZXN0TGVuZ3RoID09PSAnbnVtYmVyJyA/IG9wdGlvbnMucmVzdExlbmd0aCA6IDE7CiAgICAgIHRoaXMuc3RpZmZuZXNzID0gb3B0aW9ucy5zdGlmZm5lc3MgfHwgMTAwOwogICAgICB0aGlzLmRhbXBpbmcgPSBvcHRpb25zLmRhbXBpbmcgfHwgMTsKICAgICAgdGhpcy5ib2R5QSA9IGJvZHlBOwogICAgICB0aGlzLmJvZHlCID0gYm9keUI7CiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgVmVjMygpOwoKICAgICAgaWYgKG9wdGlvbnMubG9jYWxBbmNob3JBKSB7CiAgICAgICAgdGhpcy5sb2NhbEFuY2hvckEuY29weShvcHRpb25zLmxvY2FsQW5jaG9yQSk7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLmxvY2FsQW5jaG9yQikgewogICAgICAgIHRoaXMubG9jYWxBbmNob3JCLmNvcHkob3B0aW9ucy5sb2NhbEFuY2hvckIpOwogICAgICB9CgogICAgICBpZiAob3B0aW9ucy53b3JsZEFuY2hvckEpIHsKICAgICAgICB0aGlzLnNldFdvcmxkQW5jaG9yQShvcHRpb25zLndvcmxkQW5jaG9yQSk7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLndvcmxkQW5jaG9yQikgewogICAgICAgIHRoaXMuc2V0V29ybGRBbmNob3JCKG9wdGlvbnMud29ybGRBbmNob3JCKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLgogICAgICovCgoKICAgIHNldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpIHsKICAgICAgdGhpcy5ib2R5QS5wb2ludFRvTG9jYWxGcmFtZSh3b3JsZEFuY2hvckEsIHRoaXMubG9jYWxBbmNob3JBKTsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBCLCB1c2luZyB3b3JsZCBjb29yZGluYXRlcy4KICAgICAqLwoKCiAgICBzZXRXb3JsZEFuY2hvckIod29ybGRBbmNob3JCKSB7CiAgICAgIHRoaXMuYm9keUIucG9pbnRUb0xvY2FsRnJhbWUod29ybGRBbmNob3JCLCB0aGlzLmxvY2FsQW5jaG9yQik7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuCiAgICAgKiBAcGFyYW0gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi4KICAgICAqLwoKCiAgICBnZXRXb3JsZEFuY2hvckEocmVzdWx0KSB7CiAgICAgIHRoaXMuYm9keUEucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5sb2NhbEFuY2hvckEsIHJlc3VsdCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgaW4gd29ybGQgY29vcmRpbmF0ZXMuCiAgICAgKiBAcGFyYW0gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi4KICAgICAqLwoKCiAgICBnZXRXb3JsZEFuY2hvckIocmVzdWx0KSB7CiAgICAgIHRoaXMuYm9keUIucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5sb2NhbEFuY2hvckIsIHJlc3VsdCk7CiAgICB9CiAgICAvKioKICAgICAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuCiAgICAgKi8KCgogICAgYXBwbHlGb3JjZSgpIHsKICAgICAgY29uc3QgayA9IHRoaXMuc3RpZmZuZXNzOwogICAgICBjb25zdCBkID0gdGhpcy5kYW1waW5nOwogICAgICBjb25zdCBsID0gdGhpcy5yZXN0TGVuZ3RoOwogICAgICBjb25zdCBib2R5QSA9IHRoaXMuYm9keUE7CiAgICAgIGNvbnN0IGJvZHlCID0gdGhpcy5ib2R5QjsKICAgICAgY29uc3QgciA9IGFwcGx5Rm9yY2VfcjsKICAgICAgY29uc3Qgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQ7CiAgICAgIGNvbnN0IHUgPSBhcHBseUZvcmNlX3U7CiAgICAgIGNvbnN0IGYgPSBhcHBseUZvcmNlX2Y7CiAgICAgIGNvbnN0IHRtcCA9IGFwcGx5Rm9yY2VfdG1wOwogICAgICBjb25zdCB3b3JsZEFuY2hvckEgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQTsKICAgICAgY29uc3Qgd29ybGRBbmNob3JCID0gYXBwbHlGb3JjZV93b3JsZEFuY2hvckI7CiAgICAgIGNvbnN0IHJpID0gYXBwbHlGb3JjZV9yaTsKICAgICAgY29uc3QgcmogPSBhcHBseUZvcmNlX3JqOwogICAgICBjb25zdCByaV94X2YgPSBhcHBseUZvcmNlX3JpX3hfZjsKICAgICAgY29uc3QgcmpfeF9mID0gYXBwbHlGb3JjZV9yal94X2Y7IC8vIEdldCB3b3JsZCBhbmNob3JzCgogICAgICB0aGlzLmdldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpOwogICAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpOyAvLyBHZXQgb2Zmc2V0IHBvaW50cwoKICAgICAgd29ybGRBbmNob3JBLnZzdWIoYm9keUEucG9zaXRpb24sIHJpKTsKICAgICAgd29ybGRBbmNob3JCLnZzdWIoYm9keUIucG9zaXRpb24sIHJqKTsgLy8gQ29tcHV0ZSBkaXN0YW5jZSB2ZWN0b3IgYmV0d2VlbiB3b3JsZCBhbmNob3IgcG9pbnRzCgogICAgICB3b3JsZEFuY2hvckIudnN1Yih3b3JsZEFuY2hvckEsIHIpOwogICAgICBjb25zdCBybGVuID0gci5sZW5ndGgoKTsKICAgICAgcl91bml0LmNvcHkocik7CiAgICAgIHJfdW5pdC5ub3JtYWxpemUoKTsgLy8gQ29tcHV0ZSByZWxhdGl2ZSB2ZWxvY2l0eSBvZiB0aGUgYW5jaG9yIHBvaW50cywgdQoKICAgICAgYm9keUIudmVsb2NpdHkudnN1Yihib2R5QS52ZWxvY2l0eSwgdSk7IC8vIEFkZCByb3RhdGlvbmFsIHZlbG9jaXR5CgogICAgICBib2R5Qi5hbmd1bGFyVmVsb2NpdHkuY3Jvc3MocmosIHRtcCk7CiAgICAgIHUudmFkZCh0bXAsIHUpOwogICAgICBib2R5QS5hbmd1bGFyVmVsb2NpdHkuY3Jvc3MocmksIHRtcCk7CiAgICAgIHUudnN1Yih0bXAsIHUpOyAvLyBGID0gLSBrICogKCB4IC0gTCApIC0gRCAqICggdSApCgogICAgICByX3VuaXQuc2NhbGUoLWsgKiAocmxlbiAtIGwpIC0gZCAqIHUuZG90KHJfdW5pdCksIGYpOyAvLyBBZGQgZm9yY2VzIHRvIGJvZGllcwoKICAgICAgYm9keUEuZm9yY2UudnN1YihmLCBib2R5QS5mb3JjZSk7CiAgICAgIGJvZHlCLmZvcmNlLnZhZGQoZiwgYm9keUIuZm9yY2UpOyAvLyBBbmd1bGFyIGZvcmNlCgogICAgICByaS5jcm9zcyhmLCByaV94X2YpOwogICAgICByai5jcm9zcyhmLCByal94X2YpOwogICAgICBib2R5QS50b3JxdWUudnN1YihyaV94X2YsIGJvZHlBLnRvcnF1ZSk7CiAgICAgIGJvZHlCLnRvcnF1ZS52YWRkKHJqX3hfZiwgYm9keUIudG9ycXVlKTsKICAgIH0KCiAgfQogIGNvbnN0IGFwcGx5Rm9yY2VfciA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYXBwbHlGb3JjZV9yX3VuaXQgPSBuZXcgVmVjMygpOwogIGNvbnN0IGFwcGx5Rm9yY2VfdSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYXBwbHlGb3JjZV9mID0gbmV3IFZlYzMoKTsKICBjb25zdCBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYXBwbHlGb3JjZV93b3JsZEFuY2hvckIgPSBuZXcgVmVjMygpOwogIGNvbnN0IGFwcGx5Rm9yY2VfcmkgPSBuZXcgVmVjMygpOwogIGNvbnN0IGFwcGx5Rm9yY2VfcmogPSBuZXcgVmVjMygpOwogIGNvbnN0IGFwcGx5Rm9yY2VfcmlfeF9mID0gbmV3IFZlYzMoKTsKICBjb25zdCBhcHBseUZvcmNlX3JqX3hfZiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgYXBwbHlGb3JjZV90bXAgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBXaGVlbEluZm8KICAgKi8KICBjbGFzcyBXaGVlbEluZm8gewogICAgLyoqCiAgICAgKiBNYXggdHJhdmVsIGRpc3RhbmNlIG9mIHRoZSBzdXNwZW5zaW9uLCBpbiBtZXRlcnMuCiAgICAgKiBAZGVmYXVsdCAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNwZWVkIHRvIGFwcGx5IHRvIHRoZSB3aGVlbCByb3RhdGlvbiB3aGVuIHRoZSB3aGVlbCBpcyBzbGlkaW5nLgogICAgICogQGRlZmF1bHQgLTAuMQogICAgICovCgogICAgLyoqCiAgICAgKiBJZiB0aGUgY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCBzaG91bGQgYmUgdXNlZC4KICAgICAqIEBkZWZhdWx0IGZhbHNlCiAgICAgKi8KCiAgICAvKioKICAgICAqIHNsaWRpbmcKICAgICAqLwoKICAgIC8qKgogICAgICogQ29ubmVjdGlvbiBwb2ludCwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSBjaGFzc2lzIGJvZHkgZnJhbWUuCiAgICAgKi8KCiAgICAvKioKICAgICAqIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZAogICAgICovCgogICAgLyoqCiAgICAgKiBkaXJlY3Rpb25Mb2NhbAogICAgICovCgogICAgLyoqCiAgICAgKiBkaXJlY3Rpb25Xb3JsZAogICAgICovCgogICAgLyoqCiAgICAgKiBheGxlTG9jYWwKICAgICAqLwoKICAgIC8qKgogICAgICogYXhsZVdvcmxkCiAgICAgKi8KCiAgICAvKioKICAgICAqIHN1c3BlbnNpb25SZXN0TGVuZ3RoCiAgICAgKiBAZGVmYXVsdCAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIHN1c3BlbnNpb25NYXhMZW5ndGgKICAgICAqIEBkZWZhdWx0IDIKICAgICAqLwoKICAgIC8qKgogICAgICogcmFkaXVzCiAgICAgKiBAZGVmYXVsdCAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIHN1c3BlbnNpb25TdGlmZm5lc3MKICAgICAqIEBkZWZhdWx0IDEwMAogICAgICovCgogICAgLyoqCiAgICAgKiBkYW1waW5nQ29tcHJlc3Npb24KICAgICAqIEBkZWZhdWx0IDEwCiAgICAgKi8KCiAgICAvKioKICAgICAqIGRhbXBpbmdSZWxheGF0aW9uCiAgICAgKiBAZGVmYXVsdCAxMAogICAgICovCgogICAgLyoqCiAgICAgKiBmcmljdGlvblNsaXAKICAgICAqIEBkZWZhdWx0IDEwLjUKICAgICAqLwoKICAgIC8qKiBmb3J3YXJkQWNjZWxlcmF0aW9uICovCgogICAgLyoqIHNpZGVBY2NlbGVyYXRpb24gKi8KCiAgICAvKioKICAgICAqIHN0ZWVyaW5nCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIFJvdGF0aW9uIHZhbHVlLCBpbiByYWRpYW5zLgogICAgICogQGRlZmF1bHQgMAogICAgICovCgogICAgLyoqCiAgICAgKiBkZWx0YVJvdGF0aW9uCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIHJvbGxJbmZsdWVuY2UKICAgICAqIEBkZWZhdWx0IDAuMDEKICAgICAqLwoKICAgIC8qKgogICAgICogbWF4U3VzcGVuc2lvbkZvcmNlCiAgICAgKi8KCiAgICAvKioKICAgICAqIGVuZ2luZUZvcmNlCiAgICAgKi8KCiAgICAvKioKICAgICAqIGJyYWtlCiAgICAgKi8KCiAgICAvKioKICAgICAqIGlzRnJvbnRXaGVlbAogICAgICogQGRlZmF1bHQgdHJ1ZQogICAgICovCgogICAgLyoqCiAgICAgKiBjbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24KICAgICAqIEBkZWZhdWx0IDEKICAgICAqLwoKICAgIC8qKgogICAgICogc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkKICAgICAqIEBkZWZhdWx0IDAKICAgICAqLwoKICAgIC8qKgogICAgICogc3VzcGVuc2lvbkZvcmNlCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIHNsaXBJbmZvCiAgICAgKi8KCiAgICAvKioKICAgICAqIHNraWRJbmZvCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIHN1c3BlbnNpb25MZW5ndGgKICAgICAqIEBkZWZhdWx0IDAKICAgICAqLwoKICAgIC8qKgogICAgICogc2lkZUltcHVsc2UKICAgICAqLwoKICAgIC8qKgogICAgICogZm9yd2FyZEltcHVsc2UKICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIHJlc3VsdCBmcm9tIHJheWNhc3RpbmcuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFdoZWVsIHdvcmxkIHRyYW5zZm9ybS4KICAgICAqLwoKICAgIC8qKgogICAgICogaXNJbkNvbnRhY3QKICAgICAqLwogICAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywgewogICAgICAgIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbDogbmV3IFZlYzMoKSwKICAgICAgICBjaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQ6IG5ldyBWZWMzKCksCiAgICAgICAgZGlyZWN0aW9uTG9jYWw6IG5ldyBWZWMzKCksCiAgICAgICAgZGlyZWN0aW9uV29ybGQ6IG5ldyBWZWMzKCksCiAgICAgICAgYXhsZUxvY2FsOiBuZXcgVmVjMygpLAogICAgICAgIGF4bGVXb3JsZDogbmV3IFZlYzMoKSwKICAgICAgICBzdXNwZW5zaW9uUmVzdExlbmd0aDogMSwKICAgICAgICBzdXNwZW5zaW9uTWF4TGVuZ3RoOiAyLAogICAgICAgIHJhZGl1czogMSwKICAgICAgICBzdXNwZW5zaW9uU3RpZmZuZXNzOiAxMDAsCiAgICAgICAgZGFtcGluZ0NvbXByZXNzaW9uOiAxMCwKICAgICAgICBkYW1waW5nUmVsYXhhdGlvbjogMTAsCiAgICAgICAgZnJpY3Rpb25TbGlwOiAxMC41LAogICAgICAgIGZvcndhcmRBY2NlbGVyYXRpb246IDEsCiAgICAgICAgc2lkZUFjY2VsZXJhdGlvbjogMSwKICAgICAgICBzdGVlcmluZzogMCwKICAgICAgICByb3RhdGlvbjogMCwKICAgICAgICBkZWx0YVJvdGF0aW9uOiAwLAogICAgICAgIHJvbGxJbmZsdWVuY2U6IDAuMDEsCiAgICAgICAgbWF4U3VzcGVuc2lvbkZvcmNlOiBOdW1iZXIuTUFYX1ZBTFVFLAogICAgICAgIGlzRnJvbnRXaGVlbDogdHJ1ZSwKICAgICAgICBjbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb246IDEsCiAgICAgICAgc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHk6IDAsCiAgICAgICAgc3VzcGVuc2lvbkZvcmNlOiAwLAogICAgICAgIHNsaXBJbmZvOiAwLAogICAgICAgIHNraWRJbmZvOiAwLAogICAgICAgIHN1c3BlbnNpb25MZW5ndGg6IDAsCiAgICAgICAgbWF4U3VzcGVuc2lvblRyYXZlbDogMSwKICAgICAgICB1c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkOiBmYWxzZSwKICAgICAgICBjdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkOiAtMC4xCiAgICAgIH0pOwogICAgICB0aGlzLm1heFN1c3BlbnNpb25UcmF2ZWwgPSBvcHRpb25zLm1heFN1c3BlbnNpb25UcmF2ZWw7CiAgICAgIHRoaXMuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCA9IG9wdGlvbnMuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDsKICAgICAgdGhpcy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkOwogICAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZTsKICAgICAgdGhpcy5jaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWwgPSBvcHRpb25zLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbC5jbG9uZSgpOwogICAgICB0aGlzLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCA9IG9wdGlvbnMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLmNsb25lKCk7CiAgICAgIHRoaXMuZGlyZWN0aW9uTG9jYWwgPSBvcHRpb25zLmRpcmVjdGlvbkxvY2FsLmNsb25lKCk7CiAgICAgIHRoaXMuZGlyZWN0aW9uV29ybGQgPSBvcHRpb25zLmRpcmVjdGlvbldvcmxkLmNsb25lKCk7CiAgICAgIHRoaXMuYXhsZUxvY2FsID0gb3B0aW9ucy5heGxlTG9jYWwuY2xvbmUoKTsKICAgICAgdGhpcy5heGxlV29ybGQgPSBvcHRpb25zLmF4bGVXb3JsZC5jbG9uZSgpOwogICAgICB0aGlzLnN1c3BlbnNpb25SZXN0TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uUmVzdExlbmd0aDsKICAgICAgdGhpcy5zdXNwZW5zaW9uTWF4TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoOwogICAgICB0aGlzLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzOwogICAgICB0aGlzLnN1c3BlbnNpb25TdGlmZm5lc3MgPSBvcHRpb25zLnN1c3BlbnNpb25TdGlmZm5lc3M7CiAgICAgIHRoaXMuZGFtcGluZ0NvbXByZXNzaW9uID0gb3B0aW9ucy5kYW1waW5nQ29tcHJlc3Npb247CiAgICAgIHRoaXMuZGFtcGluZ1JlbGF4YXRpb24gPSBvcHRpb25zLmRhbXBpbmdSZWxheGF0aW9uOwogICAgICB0aGlzLmZyaWN0aW9uU2xpcCA9IG9wdGlvbnMuZnJpY3Rpb25TbGlwOwogICAgICB0aGlzLmZvcndhcmRBY2NlbGVyYXRpb24gPSBvcHRpb25zLmZvcndhcmRBY2NlbGVyYXRpb247CiAgICAgIHRoaXMuc2lkZUFjY2VsZXJhdGlvbiA9IG9wdGlvbnMuc2lkZUFjY2VsZXJhdGlvbjsKICAgICAgdGhpcy5zdGVlcmluZyA9IDA7CiAgICAgIHRoaXMucm90YXRpb24gPSAwOwogICAgICB0aGlzLmRlbHRhUm90YXRpb24gPSAwOwogICAgICB0aGlzLnJvbGxJbmZsdWVuY2UgPSBvcHRpb25zLnJvbGxJbmZsdWVuY2U7CiAgICAgIHRoaXMubWF4U3VzcGVuc2lvbkZvcmNlID0gb3B0aW9ucy5tYXhTdXNwZW5zaW9uRm9yY2U7CiAgICAgIHRoaXMuZW5naW5lRm9yY2UgPSAwOwogICAgICB0aGlzLmJyYWtlID0gMDsKICAgICAgdGhpcy5pc0Zyb250V2hlZWwgPSBvcHRpb25zLmlzRnJvbnRXaGVlbDsKICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxOwogICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMDsKICAgICAgdGhpcy5zdXNwZW5zaW9uRm9yY2UgPSAwOwogICAgICB0aGlzLnNsaXBJbmZvID0gMDsKICAgICAgdGhpcy5za2lkSW5mbyA9IDA7CiAgICAgIHRoaXMuc3VzcGVuc2lvbkxlbmd0aCA9IDA7CiAgICAgIHRoaXMuc2lkZUltcHVsc2UgPSAwOwogICAgICB0aGlzLmZvcndhcmRJbXB1bHNlID0gMDsKICAgICAgdGhpcy5yYXljYXN0UmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTsKICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTsKICAgICAgdGhpcy5pc0luQ29udGFjdCA9IGZhbHNlOwogICAgfQoKICAgIHVwZGF0ZVdoZWVsKGNoYXNzaXMpIHsKICAgICAgY29uc3QgcmF5Y2FzdFJlc3VsdCA9IHRoaXMucmF5Y2FzdFJlc3VsdDsKCiAgICAgIGlmICh0aGlzLmlzSW5Db250YWN0KSB7CiAgICAgICAgY29uc3QgcHJvamVjdCA9IHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KHJheWNhc3RSZXN1bHQuZGlyZWN0aW9uV29ybGQpOwogICAgICAgIHJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXMucG9zaXRpb24sIHJlbHBvcyk7CiAgICAgICAgY2hhc3Npcy5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChyZWxwb3MsIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50KTsKICAgICAgICBjb25zdCBwcm9qVmVsID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QoY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQpOwoKICAgICAgICBpZiAocHJvamVjdCA+PSAtMC4xKSB7CiAgICAgICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMC4wOwogICAgICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxLjAgLyAwLjE7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IGludiA9IC0xIC8gcHJvamVjdDsKICAgICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSBwcm9qVmVsICogaW52OwogICAgICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSBpbnY7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vIE5vdCBpbiBjb250YWN0IDogcG9zaXRpb24gd2hlZWwgaW4gYSBuaWNlIChyZXN0IGxlbmd0aCkgcG9zaXRpb24KICAgICAgICByYXljYXN0UmVzdWx0LnN1c3BlbnNpb25MZW5ndGggPSB0aGlzLnN1c3BlbnNpb25SZXN0TGVuZ3RoOwogICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7CiAgICAgICAgcmF5Y2FzdFJlc3VsdC5kaXJlY3Rpb25Xb3JsZC5zY2FsZSgtMSwgcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZCk7CiAgICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxLjA7CiAgICAgIH0KICAgIH0KCiAgfQogIGNvbnN0IGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ID0gbmV3IFZlYzMoKTsKICBjb25zdCByZWxwb3MgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBWZWhpY2xlIGhlbHBlciBjbGFzcyB0aGF0IGNhc3RzIHJheXMgZnJvbSB0aGUgd2hlZWwgcG9zaXRpb25zIHRvd2FyZHMgdGhlIGdyb3VuZCBhbmQgYXBwbGllcyBmb3JjZXMuCiAgICovCiAgY2xhc3MgUmF5Y2FzdFZlaGljbGUgewogICAgLyoqIFRoZSBjYXIgY2hhc3NpcyBib2R5LiAqLwoKICAgIC8qKiBUaGUgd2hlZWxzLiAqLwoKICAgIC8qKiBXaWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBjYXIgaXMgc2xpZGluZy4gKi8KCiAgICAvKiogSW5kZXggb2YgdGhlIHJpZ2h0IGF4aXMuIHg9MCwgeT0xLCB6PTIgKi8KCiAgICAvKiogSW5kZXggb2YgdGhlIGZvcndhcmQgYXhpcy4geD0wLCB5PTEsIHo9MiAqLwoKICAgIC8qKiBJbmRleCBvZiB0aGUgdXAgYXhpcy4geD0wLCB5PTEsIHo9MiAqLwoKICAgIC8qKiBUaGUgY29uc3RyYWludHMuICovCgogICAgLyoqIE9wdGlvbmFsIHByZS1zdGVwIGNhbGxiYWNrLiAqLwoKICAgIC8qKiBOdW1iZXIgb2Ygd2hlZWxzIG9uIHRoZSBncm91bmQuICovCiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7CiAgICAgIHRoaXMuY2hhc3Npc0JvZHkgPSBvcHRpb25zLmNoYXNzaXNCb2R5OwogICAgICB0aGlzLndoZWVsSW5mb3MgPSBbXTsKICAgICAgdGhpcy5zbGlkaW5nID0gZmFsc2U7CiAgICAgIHRoaXMud29ybGQgPSBudWxsOwogICAgICB0aGlzLmluZGV4UmlnaHRBeGlzID0gdHlwZW9mIG9wdGlvbnMuaW5kZXhSaWdodEF4aXMgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbmRleFJpZ2h0QXhpcyA6IDI7CiAgICAgIHRoaXMuaW5kZXhGb3J3YXJkQXhpcyA9IHR5cGVvZiBvcHRpb25zLmluZGV4Rm9yd2FyZEF4aXMgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbmRleEZvcndhcmRBeGlzIDogMDsKICAgICAgdGhpcy5pbmRleFVwQXhpcyA9IHR5cGVvZiBvcHRpb25zLmluZGV4VXBBeGlzICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuaW5kZXhVcEF4aXMgOiAxOwogICAgICB0aGlzLmNvbnN0cmFpbnRzID0gW107CgogICAgICB0aGlzLnByZVN0ZXBDYWxsYmFjayA9ICgpID0+IHt9OwoKICAgICAgdGhpcy5jdXJyZW50VmVoaWNsZVNwZWVkS21Ib3VyID0gMDsKICAgICAgdGhpcy5udW1XaGVlbHNPbkdyb3VuZCA9IDA7CiAgICB9CiAgICAvKioKICAgICAqIEFkZCBhIHdoZWVsLiBGb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9wdGlvbnMsIHNlZSBgV2hlZWxJbmZvYC4KICAgICAqLwoKCiAgICBhZGRXaGVlbChvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIGNvbnN0IGluZm8gPSBuZXcgV2hlZWxJbmZvKG9wdGlvbnMpOwogICAgICBjb25zdCBpbmRleCA9IHRoaXMud2hlZWxJbmZvcy5sZW5ndGg7CiAgICAgIHRoaXMud2hlZWxJbmZvcy5wdXNoKGluZm8pOwogICAgICByZXR1cm4gaW5kZXg7CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0aGUgc3RlZXJpbmcgdmFsdWUgb2YgYSB3aGVlbC4KICAgICAqLwoKCiAgICBzZXRTdGVlcmluZ1ZhbHVlKHZhbHVlLCB3aGVlbEluZGV4KSB7CiAgICAgIGNvbnN0IHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdOwogICAgICB3aGVlbC5zdGVlcmluZyA9IHZhbHVlOwogICAgfQogICAgLyoqCiAgICAgKiBTZXQgdGhlIHdoZWVsIGZvcmNlIHRvIGFwcGx5IG9uIG9uZSBvZiB0aGUgd2hlZWxzIGVhY2ggdGltZSBzdGVwCiAgICAgKi8KCgogICAgYXBwbHlFbmdpbmVGb3JjZSh2YWx1ZSwgd2hlZWxJbmRleCkgewogICAgICB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0uZW5naW5lRm9yY2UgPSB2YWx1ZTsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHRoZSBicmFraW5nIGZvcmNlIG9mIGEgd2hlZWwKICAgICAqLwoKCiAgICBzZXRCcmFrZShicmFrZSwgd2hlZWxJbmRleCkgewogICAgICB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0uYnJha2UgPSBicmFrZTsKICAgIH0KICAgIC8qKgogICAgICogQWRkIHRoZSB2ZWhpY2xlIGluY2x1ZGluZyBpdHMgY29uc3RyYWludHMgdG8gdGhlIHdvcmxkLgogICAgICovCgoKICAgIGFkZFRvV29ybGQod29ybGQpIHsKICAgICAgd29ybGQuYWRkQm9keSh0aGlzLmNoYXNzaXNCb2R5KTsKICAgICAgY29uc3QgdGhhdCA9IHRoaXM7CgogICAgICB0aGlzLnByZVN0ZXBDYWxsYmFjayA9ICgpID0+IHsKICAgICAgICB0aGF0LnVwZGF0ZVZlaGljbGUod29ybGQuZHQpOwogICAgICB9OwoKICAgICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTsKICAgICAgdGhpcy53b3JsZCA9IHdvcmxkOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgb25lIG9mIHRoZSB3aGVlbCBheGxlcywgd29ybGQtb3JpZW50ZWQuCiAgICAgKi8KCgogICAgZ2V0VmVoaWNsZUF4aXNXb3JsZChheGlzSW5kZXgsIHJlc3VsdCkgewogICAgICByZXN1bHQuc2V0KGF4aXNJbmRleCA9PT0gMCA/IDEgOiAwLCBheGlzSW5kZXggPT09IDEgPyAxIDogMCwgYXhpc0luZGV4ID09PSAyID8gMSA6IDApOwogICAgICB0aGlzLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShyZXN1bHQsIHJlc3VsdCk7CiAgICB9CgogICAgdXBkYXRlVmVoaWNsZSh0aW1lU3RlcCkgewogICAgICBjb25zdCB3aGVlbEluZm9zID0gdGhpcy53aGVlbEluZm9zOwogICAgICBjb25zdCBudW1XaGVlbHMgPSB3aGVlbEluZm9zLmxlbmd0aDsKICAgICAgY29uc3QgY2hhc3Npc0JvZHkgPSB0aGlzLmNoYXNzaXNCb2R5OwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykgewogICAgICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm0oaSk7CiAgICAgIH0KCiAgICAgIHRoaXMuY3VycmVudFZlaGljbGVTcGVlZEttSG91ciA9IDMuNiAqIGNoYXNzaXNCb2R5LnZlbG9jaXR5Lmxlbmd0aCgpOwogICAgICBjb25zdCBmb3J3YXJkV29ybGQgPSBuZXcgVmVjMygpOwogICAgICB0aGlzLmdldFZlaGljbGVBeGlzV29ybGQodGhpcy5pbmRleEZvcndhcmRBeGlzLCBmb3J3YXJkV29ybGQpOwoKICAgICAgaWYgKGZvcndhcmRXb3JsZC5kb3QoY2hhc3Npc0JvZHkudmVsb2NpdHkpIDwgMCkgewogICAgICAgIHRoaXMuY3VycmVudFZlaGljbGVTcGVlZEttSG91ciAqPSAtMTsKICAgICAgfSAvLyBzaW11bGF0ZSBzdXNwZW5zaW9uCgoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykgewogICAgICAgIHRoaXMuY2FzdFJheSh3aGVlbEluZm9zW2ldKTsKICAgICAgfQoKICAgICAgdGhpcy51cGRhdGVTdXNwZW5zaW9uKHRpbWVTdGVwKTsKICAgICAgY29uc3QgaW1wdWxzZSA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHJlbHBvcyA9IG5ldyBWZWMzKCk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7CiAgICAgICAgLy9hcHBseSBzdXNwZW5zaW9uIGZvcmNlCiAgICAgICAgY29uc3Qgd2hlZWwgPSB3aGVlbEluZm9zW2ldOwogICAgICAgIGxldCBzdXNwZW5zaW9uRm9yY2UgPSB3aGVlbC5zdXNwZW5zaW9uRm9yY2U7CgogICAgICAgIGlmIChzdXNwZW5zaW9uRm9yY2UgPiB3aGVlbC5tYXhTdXNwZW5zaW9uRm9yY2UpIHsKICAgICAgICAgIHN1c3BlbnNpb25Gb3JjZSA9IHdoZWVsLm1heFN1c3BlbnNpb25Gb3JjZTsKICAgICAgICB9CgogICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuc2NhbGUoc3VzcGVuc2lvbkZvcmNlICogdGltZVN0ZXAsIGltcHVsc2UpOwogICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXNCb2R5LnBvc2l0aW9uLCByZWxwb3MpOwogICAgICAgIGNoYXNzaXNCb2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlLCByZWxwb3MpOwogICAgICB9CgogICAgICB0aGlzLnVwZGF0ZUZyaWN0aW9uKHRpbWVTdGVwKTsKICAgICAgY29uc3QgaGl0Tm9ybWFsV29ybGRTY2FsZWRXaXRoUHJvaiA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IGZ3ZCA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IHZlbCA9IG5ldyBWZWMzKCk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7CiAgICAgICAgY29uc3Qgd2hlZWwgPSB3aGVlbEluZm9zW2ldOyAvL2NvbnN0IHJlbHBvcyA9IG5ldyBWZWMzKCk7CiAgICAgICAgLy93aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQudnN1YihjaGFzc2lzQm9keS5wb3NpdGlvbiwgcmVscG9zKTsKCiAgICAgICAgY2hhc3Npc0JvZHkuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLCB2ZWwpOyAvLyBIYWNrIHRvIGdldCB0aGUgcm90YXRpb24gaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uCgogICAgICAgIGxldCBtID0gMTsKCiAgICAgICAgc3dpdGNoICh0aGlzLmluZGV4VXBBeGlzKSB7CiAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgIG0gPSAtMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgfQoKICAgICAgICBpZiAod2hlZWwuaXNJbkNvbnRhY3QpIHsKICAgICAgICAgIHRoaXMuZ2V0VmVoaWNsZUF4aXNXb3JsZCh0aGlzLmluZGV4Rm9yd2FyZEF4aXMsIGZ3ZCk7CiAgICAgICAgICBjb25zdCBwcm9qID0gZndkLmRvdCh3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkKTsKICAgICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuc2NhbGUocHJvaiwgaGl0Tm9ybWFsV29ybGRTY2FsZWRXaXRoUHJvaik7CiAgICAgICAgICBmd2QudnN1YihoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qLCBmd2QpOwogICAgICAgICAgY29uc3QgcHJvajIgPSBmd2QuZG90KHZlbCk7CiAgICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uID0gbSAqIHByb2oyICogdGltZVN0ZXAgLyB3aGVlbC5yYWRpdXM7CiAgICAgICAgfQoKICAgICAgICBpZiAoKHdoZWVsLnNsaWRpbmcgfHwgIXdoZWVsLmlzSW5Db250YWN0KSAmJiB3aGVlbC5lbmdpbmVGb3JjZSAhPT0gMCAmJiB3aGVlbC51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkKSB7CiAgICAgICAgICAvLyBBcHBseSBjdXN0b20gcm90YXRpb24gd2hlbiBhY2NlbGVyYXRpbmcgYW5kIHNsaWRpbmcKICAgICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gPSAod2hlZWwuZW5naW5lRm9yY2UgPiAwID8gMSA6IC0xKSAqIHdoZWVsLmN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQgKiB0aW1lU3RlcDsKICAgICAgICB9IC8vIExvY2sgd2hlZWxzCgoKICAgICAgICBpZiAoTWF0aC5hYnMod2hlZWwuYnJha2UpID4gTWF0aC5hYnMod2hlZWwuZW5naW5lRm9yY2UpKSB7CiAgICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uID0gMDsKICAgICAgICB9CgogICAgICAgIHdoZWVsLnJvdGF0aW9uICs9IHdoZWVsLmRlbHRhUm90YXRpb247IC8vIFVzZSB0aGUgb2xkIHZhbHVlCgogICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gKj0gMC45OTsgLy8gZGFtcGluZyBvZiByb3RhdGlvbiB3aGVuIG5vdCBpbiBjb250YWN0CiAgICAgIH0KICAgIH0KCiAgICB1cGRhdGVTdXNwZW5zaW9uKGRlbHRhVGltZSkgewogICAgICBjb25zdCBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7CiAgICAgIGNvbnN0IGNoYXNzaXNNYXNzID0gY2hhc3Npc0JvZHkubWFzczsKICAgICAgY29uc3Qgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvczsKICAgICAgY29uc3QgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7CgogICAgICBmb3IgKGxldCB3X2l0ID0gMDsgd19pdCA8IG51bVdoZWVsczsgd19pdCsrKSB7CiAgICAgICAgY29uc3Qgd2hlZWwgPSB3aGVlbEluZm9zW3dfaXRdOwoKICAgICAgICBpZiAod2hlZWwuaXNJbkNvbnRhY3QpIHsKICAgICAgICAgIGxldCBmb3JjZTsgLy8gU3ByaW5nCgogICAgICAgICAgY29uc3Qgc3VzcF9sZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aDsKICAgICAgICAgIGNvbnN0IGN1cnJlbnRfbGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvbkxlbmd0aDsKICAgICAgICAgIGNvbnN0IGxlbmd0aF9kaWZmID0gc3VzcF9sZW5ndGggLSBjdXJyZW50X2xlbmd0aDsKICAgICAgICAgIGZvcmNlID0gd2hlZWwuc3VzcGVuc2lvblN0aWZmbmVzcyAqIGxlbmd0aF9kaWZmICogd2hlZWwuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uOyAvLyBEYW1wZXIKCiAgICAgICAgICBjb25zdCBwcm9qZWN0ZWRfcmVsX3ZlbCA9IHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5OwogICAgICAgICAgbGV0IHN1c3BfZGFtcGluZzsKCiAgICAgICAgICBpZiAocHJvamVjdGVkX3JlbF92ZWwgPCAwKSB7CiAgICAgICAgICAgIHN1c3BfZGFtcGluZyA9IHdoZWVsLmRhbXBpbmdDb21wcmVzc2lvbjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN1c3BfZGFtcGluZyA9IHdoZWVsLmRhbXBpbmdSZWxheGF0aW9uOwogICAgICAgICAgfQoKICAgICAgICAgIGZvcmNlIC09IHN1c3BfZGFtcGluZyAqIHByb2plY3RlZF9yZWxfdmVsOwogICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gZm9yY2UgKiBjaGFzc2lzTWFzczsKCiAgICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkZvcmNlIDwgMCkgewogICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uRm9yY2UgPSAwOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uRm9yY2UgPSAwOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmUgdGhlIHZlaGljbGUgaW5jbHVkaW5nIGl0cyBjb25zdHJhaW50cyBmcm9tIHRoZSB3b3JsZC4KICAgICAqLwoKCiAgICByZW1vdmVGcm9tV29ybGQod29ybGQpIHsKICAgICAgdGhpcy5jb25zdHJhaW50czsKICAgICAgd29ybGQucmVtb3ZlQm9keSh0aGlzLmNoYXNzaXNCb2R5KTsKICAgICAgd29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTsKICAgICAgdGhpcy53b3JsZCA9IG51bGw7CiAgICB9CgogICAgY2FzdFJheSh3aGVlbCkgewogICAgICBjb25zdCByYXl2ZWN0b3IgPSBjYXN0UmF5X3JheXZlY3RvcjsKICAgICAgY29uc3QgdGFyZ2V0ID0gY2FzdFJheV90YXJnZXQ7CiAgICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm1Xb3JsZCh3aGVlbCk7CiAgICAgIGNvbnN0IGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTsKICAgICAgbGV0IGRlcHRoID0gLTE7CiAgICAgIGNvbnN0IHJheWxlbiA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwucmFkaXVzOwogICAgICB3aGVlbC5kaXJlY3Rpb25Xb3JsZC5zY2FsZShyYXlsZW4sIHJheXZlY3Rvcik7CiAgICAgIGNvbnN0IHNvdXJjZSA9IHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZDsKICAgICAgc291cmNlLnZhZGQocmF5dmVjdG9yLCB0YXJnZXQpOwogICAgICBjb25zdCByYXljYXN0UmVzdWx0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdDsKICAgICAgcmF5Y2FzdFJlc3VsdC5yZXNldCgpOyAvLyBUdXJuIG9mZiByYXkgY29sbGlzaW9uIHdpdGggdGhlIGNoYXNzaXMgdGVtcG9yYXJpbHkKCiAgICAgIGNvbnN0IG9sZFN0YXRlID0gY2hhc3Npc0JvZHkuY29sbGlzaW9uUmVzcG9uc2U7CiAgICAgIGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlID0gZmFsc2U7IC8vIENhc3QgcmF5IGFnYWluc3Qgd29ybGQKCiAgICAgIHRoaXMud29ybGQucmF5VGVzdChzb3VyY2UsIHRhcmdldCwgcmF5Y2FzdFJlc3VsdCk7CiAgICAgIGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlID0gb2xkU3RhdGU7CiAgICAgIGNvbnN0IG9iamVjdCA9IHJheWNhc3RSZXN1bHQuYm9keTsKICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5ncm91bmRPYmplY3QgPSAwOwoKICAgICAgaWYgKG9iamVjdCkgewogICAgICAgIGRlcHRoID0gcmF5Y2FzdFJlc3VsdC5kaXN0YW5jZTsKICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZDsKICAgICAgICB3aGVlbC5pc0luQ29udGFjdCA9IHRydWU7CiAgICAgICAgY29uc3QgaGl0RGlzdGFuY2UgPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlOwogICAgICAgIHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPSBoaXREaXN0YW5jZSAtIHdoZWVsLnJhZGl1czsgLy8gY2xhbXAgb24gbWF4IHN1c3BlbnNpb24gdHJhdmVsCgogICAgICAgIGNvbnN0IG1pblN1c3BlbnNpb25MZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aCAtIHdoZWVsLm1heFN1c3BlbnNpb25UcmF2ZWw7CiAgICAgICAgY29uc3QgbWF4U3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDsKCiAgICAgICAgaWYgKHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPCBtaW5TdXNwZW5zaW9uTGVuZ3RoKSB7CiAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gbWluU3VzcGVuc2lvbkxlbmd0aDsKICAgICAgICB9CgogICAgICAgIGlmICh3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID4gbWF4U3VzcGVuc2lvbkxlbmd0aCkgewogICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA9IG1heFN1c3BlbnNpb25MZW5ndGg7CiAgICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LnJlc2V0KCk7CiAgICAgICAgfQoKICAgICAgICBjb25zdCBkZW5vbWluYXRvciA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KHdoZWVsLmRpcmVjdGlvbldvcmxkKTsKICAgICAgICBjb25zdCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCA9IG5ldyBWZWMzKCk7CiAgICAgICAgY2hhc3Npc0JvZHkuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCk7CiAgICAgICAgY29uc3QgcHJvalZlbCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50KTsKCiAgICAgICAgaWYgKGRlbm9taW5hdG9yID49IC0wLjEpIHsKICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMDsKICAgICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEgLyAwLjE7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IGludiA9IC0xIC8gZGVub21pbmF0b3I7CiAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IHByb2pWZWwgKiBpbnY7CiAgICAgICAgICB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSBpbnY7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vcHV0IHdoZWVsIGluZm8gYXMgaW4gcmVzdCBwb3NpdGlvbgogICAgICAgIHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aCArIDAgKiB3aGVlbC5tYXhTdXNwZW5zaW9uVHJhdmVsOwogICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMC4wOwogICAgICAgIHdoZWVsLmRpcmVjdGlvbldvcmxkLnNjYWxlKC0xLCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkKTsKICAgICAgICB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxLjA7CiAgICAgIH0KCiAgICAgIHJldHVybiBkZXB0aDsKICAgIH0KCiAgICB1cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsKSB7CiAgICAgIHdoZWVsLmlzSW5Db250YWN0ID0gZmFsc2U7CiAgICAgIGNvbnN0IGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTsKICAgICAgY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsLCB3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQpOwogICAgICBjaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUod2hlZWwuZGlyZWN0aW9uTG9jYWwsIHdoZWVsLmRpcmVjdGlvbldvcmxkKTsKICAgICAgY2hhc3Npc0JvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKHdoZWVsLmF4bGVMb2NhbCwgd2hlZWwuYXhsZVdvcmxkKTsKICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlIG9uZSBvZiB0aGUgd2hlZWwgdHJhbnNmb3JtLgogICAgICogTm90ZSB3aGVuIHJlbmRlcmluZyB3aGVlbHM6IGR1cmluZyBlYWNoIHN0ZXAsIHdoZWVsIHRyYW5zZm9ybXMgYXJlIHVwZGF0ZWQgQkVGT1JFIHRoZSBjaGFzc2lzOyBpZS4gdGhlaXIgcG9zaXRpb24gYmVjb21lcyBpbnZhbGlkIGFmdGVyIHRoZSBzdGVwLiBUaHVzIHdoZW4geW91IHJlbmRlciB3aGVlbHMsIHlvdSBtdXN0IHVwZGF0ZSB3aGVlbCB0cmFuc2Zvcm1zIGJlZm9yZSByZW5kZXJpbmcgdGhlbS4gU2VlIHJheWNhc3RWZWhpY2xlIGRlbW8gZm9yIGFuIGV4YW1wbGUuCiAgICAgKiBAcGFyYW0gd2hlZWxJbmRleCBUaGUgd2hlZWwgaW5kZXggdG8gdXBkYXRlLgogICAgICovCgoKICAgIHVwZGF0ZVdoZWVsVHJhbnNmb3JtKHdoZWVsSW5kZXgpIHsKICAgICAgY29uc3QgdXAgPSB0bXBWZWM0OwogICAgICBjb25zdCByaWdodCA9IHRtcFZlYzU7CiAgICAgIGNvbnN0IGZ3ZCA9IHRtcFZlYzY7CiAgICAgIGNvbnN0IHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdOwogICAgICB0aGlzLnVwZGF0ZVdoZWVsVHJhbnNmb3JtV29ybGQod2hlZWwpOwogICAgICB3aGVlbC5kaXJlY3Rpb25Mb2NhbC5zY2FsZSgtMSwgdXApOwogICAgICByaWdodC5jb3B5KHdoZWVsLmF4bGVMb2NhbCk7CiAgICAgIHVwLmNyb3NzKHJpZ2h0LCBmd2QpOwogICAgICBmd2Qubm9ybWFsaXplKCk7CiAgICAgIHJpZ2h0Lm5vcm1hbGl6ZSgpOyAvLyBSb3RhdGUgYXJvdW5kIHN0ZWVyaW5nIG92ZXIgdGhlIHdoZWVsQXhsZQoKICAgICAgY29uc3Qgc3RlZXJpbmcgPSB3aGVlbC5zdGVlcmluZzsKICAgICAgY29uc3Qgc3RlZXJpbmdPcm4gPSBuZXcgUXVhdGVybmlvbigpOwogICAgICBzdGVlcmluZ09ybi5zZXRGcm9tQXhpc0FuZ2xlKHVwLCBzdGVlcmluZyk7CiAgICAgIGNvbnN0IHJvdGF0aW5nT3JuID0gbmV3IFF1YXRlcm5pb24oKTsKICAgICAgcm90YXRpbmdPcm4uc2V0RnJvbUF4aXNBbmdsZShyaWdodCwgd2hlZWwucm90YXRpb24pOyAvLyBXb3JsZCByb3RhdGlvbiBvZiB0aGUgd2hlZWwKCiAgICAgIGNvbnN0IHEgPSB3aGVlbC53b3JsZFRyYW5zZm9ybS5xdWF0ZXJuaW9uOwogICAgICB0aGlzLmNoYXNzaXNCb2R5LnF1YXRlcm5pb24ubXVsdChzdGVlcmluZ09ybiwgcSk7CiAgICAgIHEubXVsdChyb3RhdGluZ09ybiwgcSk7CiAgICAgIHEubm9ybWFsaXplKCk7IC8vIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB3aGVlbAoKICAgICAgY29uc3QgcCA9IHdoZWVsLndvcmxkVHJhbnNmb3JtLnBvc2l0aW9uOwogICAgICBwLmNvcHkod2hlZWwuZGlyZWN0aW9uV29ybGQpOwogICAgICBwLnNjYWxlKHdoZWVsLnN1c3BlbnNpb25MZW5ndGgsIHApOwogICAgICBwLnZhZGQod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLCBwKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSB3b3JsZCB0cmFuc2Zvcm0gb2Ygb25lIG9mIHRoZSB3aGVlbHMKICAgICAqLwoKCiAgICBnZXRXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsSW5kZXgpIHsKICAgICAgcmV0dXJuIHRoaXMud2hlZWxJbmZvc1t3aGVlbEluZGV4XS53b3JsZFRyYW5zZm9ybTsKICAgIH0KCiAgICB1cGRhdGVGcmljdGlvbih0aW1lU3RlcCkgewogICAgICBjb25zdCBzdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2o7IC8vY2FsY3VsYXRlIHRoZSBpbXB1bHNlLCBzbyB0aGF0IHRoZSB3aGVlbHMgZG9uJ3QgbW92ZSBzaWRld2FyZHMKCiAgICAgIGNvbnN0IHdoZWVsSW5mb3MgPSB0aGlzLndoZWVsSW5mb3M7CiAgICAgIGNvbnN0IG51bVdoZWVscyA9IHdoZWVsSW5mb3MubGVuZ3RoOwogICAgICBjb25zdCBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7CiAgICAgIGNvbnN0IGZvcndhcmRXUyA9IHVwZGF0ZUZyaWN0aW9uX2ZvcndhcmRXUzsKICAgICAgY29uc3QgYXhsZSA9IHVwZGF0ZUZyaWN0aW9uX2F4bGU7CiAgICAgIHRoaXMubnVtV2hlZWxzT25Hcm91bmQgPSAwOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykgewogICAgICAgIGNvbnN0IHdoZWVsID0gd2hlZWxJbmZvc1tpXTsKICAgICAgICBjb25zdCBncm91bmRPYmplY3QgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmJvZHk7CgogICAgICAgIGlmIChncm91bmRPYmplY3QpIHsKICAgICAgICAgIHRoaXMubnVtV2hlZWxzT25Hcm91bmQrKzsKICAgICAgICB9CgogICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlID0gMDsKICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSA9IDA7CgogICAgICAgIGlmICghZm9yd2FyZFdTW2ldKSB7CiAgICAgICAgICBmb3J3YXJkV1NbaV0gPSBuZXcgVmVjMygpOwogICAgICAgIH0KCiAgICAgICAgaWYgKCFheGxlW2ldKSB7CiAgICAgICAgICBheGxlW2ldID0gbmV3IFZlYzMoKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHsKICAgICAgICBjb25zdCB3aGVlbCA9IHdoZWVsSW5mb3NbaV07CiAgICAgICAgY29uc3QgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5OwoKICAgICAgICBpZiAoZ3JvdW5kT2JqZWN0KSB7CiAgICAgICAgICBjb25zdCBheGxlaSA9IGF4bGVbaV07CiAgICAgICAgICBjb25zdCB3aGVlbFRyYW5zID0gdGhpcy5nZXRXaGVlbFRyYW5zZm9ybVdvcmxkKGkpOyAvLyBHZXQgd29ybGQgYXhsZQoKICAgICAgICAgIHdoZWVsVHJhbnMudmVjdG9yVG9Xb3JsZEZyYW1lKGRpcmVjdGlvbnNbdGhpcy5pbmRleFJpZ2h0QXhpc10sIGF4bGVpKTsKICAgICAgICAgIGNvbnN0IHN1cmZOb3JtYWxXUyA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQ7CiAgICAgICAgICBjb25zdCBwcm9qID0gYXhsZWkuZG90KHN1cmZOb3JtYWxXUyk7CiAgICAgICAgICBzdXJmTm9ybWFsV1Muc2NhbGUocHJvaiwgc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qKTsKICAgICAgICAgIGF4bGVpLnZzdWIoc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qLCBheGxlaSk7CiAgICAgICAgICBheGxlaS5ub3JtYWxpemUoKTsKICAgICAgICAgIHN1cmZOb3JtYWxXUy5jcm9zcyhheGxlaSwgZm9yd2FyZFdTW2ldKTsKICAgICAgICAgIGZvcndhcmRXU1tpXS5ub3JtYWxpemUoKTsKICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlID0gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbChjaGFzc2lzQm9keSwgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLCBncm91bmRPYmplY3QsIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCwgYXhsZWkpOwogICAgICAgICAgd2hlZWwuc2lkZUltcHVsc2UgKj0gc2lkZUZyaWN0aW9uU3RpZmZuZXNzMjsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGNvbnN0IHNpZGVGYWN0b3IgPSAxOwogICAgICBjb25zdCBmd2RGYWN0b3IgPSAwLjU7CiAgICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykgewogICAgICAgIGNvbnN0IHdoZWVsID0gd2hlZWxJbmZvc1tpXTsKICAgICAgICBjb25zdCBncm91bmRPYmplY3QgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmJvZHk7CiAgICAgICAgbGV0IHJvbGxpbmdGcmljdGlvbiA9IDA7CiAgICAgICAgd2hlZWwuc2xpcEluZm8gPSAxOwoKICAgICAgICBpZiAoZ3JvdW5kT2JqZWN0KSB7CiAgICAgICAgICBjb25zdCBkZWZhdWx0Um9sbGluZ0ZyaWN0aW9uSW1wdWxzZSA9IDA7CiAgICAgICAgICBjb25zdCBtYXhJbXB1bHNlID0gd2hlZWwuYnJha2UgPyB3aGVlbC5icmFrZSA6IGRlZmF1bHRSb2xsaW5nRnJpY3Rpb25JbXB1bHNlOyAvLyBidFdoZWVsQ29udGFjdFBvaW50IGNvbnRhY3RQdChjaGFzc2lzQm9keSxncm91bmRPYmplY3Qsd2hlZWxJbmZyYXljYXN0SW5mby5oaXRQb2ludFdvcmxkLGZvcndhcmRXU1t3aGVlbF0sbWF4SW1wdWxzZSk7CiAgICAgICAgICAvLyByb2xsaW5nRnJpY3Rpb24gPSBjYWxjUm9sbGluZ0ZyaWN0aW9uKGNvbnRhY3RQdCk7CgogICAgICAgICAgcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjaGFzc2lzQm9keSwgZ3JvdW5kT2JqZWN0LCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsIGZvcndhcmRXU1tpXSwgbWF4SW1wdWxzZSk7CiAgICAgICAgICByb2xsaW5nRnJpY3Rpb24gKz0gd2hlZWwuZW5naW5lRm9yY2UgKiB0aW1lU3RlcDsgLy8gcm9sbGluZ0ZyaWN0aW9uID0gMDsKCiAgICAgICAgICBjb25zdCBmYWN0b3IgPSBtYXhJbXB1bHNlIC8gcm9sbGluZ0ZyaWN0aW9uOwogICAgICAgICAgd2hlZWwuc2xpcEluZm8gKj0gZmFjdG9yOwogICAgICAgIH0gLy9zd2l0Y2ggYmV0d2VlbiBhY3RpdmUgcm9sbGluZyAodGhyb3R0bGUpLCBicmFraW5nIGFuZCBub24tYWN0aXZlIHJvbGxpbmcgZnJpY3Rpb24gKG50aHJvdHRsZS9icmVhaykKCgogICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlID0gMDsKICAgICAgICB3aGVlbC5za2lkSW5mbyA9IDE7CgogICAgICAgIGlmIChncm91bmRPYmplY3QpIHsKICAgICAgICAgIHdoZWVsLnNraWRJbmZvID0gMTsKICAgICAgICAgIGNvbnN0IG1heGltcCA9IHdoZWVsLnN1c3BlbnNpb25Gb3JjZSAqIHRpbWVTdGVwICogd2hlZWwuZnJpY3Rpb25TbGlwOwogICAgICAgICAgY29uc3QgbWF4aW1wU2lkZSA9IG1heGltcDsKICAgICAgICAgIGNvbnN0IG1heGltcFNxdWFyZWQgPSBtYXhpbXAgKiBtYXhpbXBTaWRlOwogICAgICAgICAgd2hlZWwuZm9yd2FyZEltcHVsc2UgPSByb2xsaW5nRnJpY3Rpb247IC8vd2hlZWxJbmZvLmVuZ2luZUZvcmNlKiB0aW1lU3RlcDsKCiAgICAgICAgICBjb25zdCB4ID0gd2hlZWwuZm9yd2FyZEltcHVsc2UgKiBmd2RGYWN0b3IgLyB3aGVlbC5mb3J3YXJkQWNjZWxlcmF0aW9uOwogICAgICAgICAgY29uc3QgeSA9IHdoZWVsLnNpZGVJbXB1bHNlICogc2lkZUZhY3RvciAvIHdoZWVsLnNpZGVBY2NlbGVyYXRpb247CiAgICAgICAgICBjb25zdCBpbXB1bHNlU3F1YXJlZCA9IHggKiB4ICsgeSAqIHk7CiAgICAgICAgICB3aGVlbC5zbGlkaW5nID0gZmFsc2U7CgogICAgICAgICAgaWYgKGltcHVsc2VTcXVhcmVkID4gbWF4aW1wU3F1YXJlZCkgewogICAgICAgICAgICB0aGlzLnNsaWRpbmcgPSB0cnVlOwogICAgICAgICAgICB3aGVlbC5zbGlkaW5nID0gdHJ1ZTsKICAgICAgICAgICAgY29uc3QgZmFjdG9yID0gbWF4aW1wIC8gTWF0aC5zcXJ0KGltcHVsc2VTcXVhcmVkKTsKICAgICAgICAgICAgd2hlZWwuc2tpZEluZm8gKj0gZmFjdG9yOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHRoaXMuc2xpZGluZykgewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHsKICAgICAgICAgIGNvbnN0IHdoZWVsID0gd2hlZWxJbmZvc1tpXTsKCiAgICAgICAgICBpZiAod2hlZWwuc2lkZUltcHVsc2UgIT09IDApIHsKICAgICAgICAgICAgaWYgKHdoZWVsLnNraWRJbmZvIDwgMSkgewogICAgICAgICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlICo9IHdoZWVsLnNraWRJbmZvOwogICAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlICo9IHdoZWVsLnNraWRJbmZvOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIGFwcGx5IHRoZSBpbXB1bHNlcwoKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHsKICAgICAgICBjb25zdCB3aGVlbCA9IHdoZWVsSW5mb3NbaV07CiAgICAgICAgY29uc3QgcmVsX3BvcyA9IG5ldyBWZWMzKCk7CiAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbF9wb3MpOyAvLyBjYW5ub25zIGFwcGx5aW1wdWxzZSBpcyB1c2luZyB3b3JsZCBjb29yZCBmb3IgdGhlIHBvc2l0aW9uCiAgICAgICAgLy9yZWxfcG9zLmNvcHkod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkKTsKCiAgICAgICAgaWYgKHdoZWVsLmZvcndhcmRJbXB1bHNlICE9PSAwKSB7CiAgICAgICAgICBjb25zdCBpbXB1bHNlID0gbmV3IFZlYzMoKTsKICAgICAgICAgIGZvcndhcmRXU1tpXS5zY2FsZSh3aGVlbC5mb3J3YXJkSW1wdWxzZSwgaW1wdWxzZSk7CiAgICAgICAgICBjaGFzc2lzQm9keS5hcHBseUltcHVsc2UoaW1wdWxzZSwgcmVsX3Bvcyk7CiAgICAgICAgfQoKICAgICAgICBpZiAod2hlZWwuc2lkZUltcHVsc2UgIT09IDApIHsKICAgICAgICAgIGNvbnN0IGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTsKICAgICAgICAgIGNvbnN0IHJlbF9wb3MyID0gbmV3IFZlYzMoKTsKICAgICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGdyb3VuZE9iamVjdC5wb3NpdGlvbiwgcmVsX3BvczIpOyAvL3JlbF9wb3MyLmNvcHkod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkKTsKCiAgICAgICAgICBjb25zdCBzaWRlSW1wID0gbmV3IFZlYzMoKTsKICAgICAgICAgIGF4bGVbaV0uc2NhbGUod2hlZWwuc2lkZUltcHVsc2UsIHNpZGVJbXApOyAvLyBTY2FsZSB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlIHVwIGRpcmVjdGlvbiB3aXRoIHJvbGxJbmZsdWVuY2UuCiAgICAgICAgICAvLyBJZiByb2xsSW5mbHVlbmNlIGlzIDEsIHRoZSBpbXB1bHNlIHdpbGwgYmUgYXBwbGllZCBvbiB0aGUgaGl0UG9pbnQgKGVhc3kgdG8gcm9sbCBvdmVyKSwgaWYgaXQgaXMgemVybyBpdCB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIHNhbWUgcGxhbmUgYXMgdGhlIGNlbnRlciBvZiBtYXNzIChub3QgZWFzeSB0byByb2xsIG92ZXIpLgoKICAgICAgICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvTG9jYWxGcmFtZShyZWxfcG9zLCByZWxfcG9zKTsKICAgICAgICAgIHJlbF9wb3NbJ3h5eidbdGhpcy5pbmRleFVwQXhpc11dICo9IHdoZWVsLnJvbGxJbmZsdWVuY2U7CiAgICAgICAgICBjaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUocmVsX3BvcywgcmVsX3Bvcyk7CiAgICAgICAgICBjaGFzc2lzQm9keS5hcHBseUltcHVsc2Uoc2lkZUltcCwgcmVsX3Bvcyk7IC8vYXBwbHkgZnJpY3Rpb24gaW1wdWxzZSBvbiB0aGUgZ3JvdW5kCgogICAgICAgICAgc2lkZUltcC5zY2FsZSgtMSwgc2lkZUltcCk7CiAgICAgICAgICBncm91bmRPYmplY3QuYXBwbHlJbXB1bHNlKHNpZGVJbXAsIHJlbF9wb3MyKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgfQogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IHRtcFZlYzQgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRtcFZlYzUgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRtcFZlYzYgPSBuZXcgVmVjMygpOwogIG5ldyBSYXkoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IGNhc3RSYXlfcmF5dmVjdG9yID0gbmV3IFZlYzMoKTsKICBjb25zdCBjYXN0UmF5X3RhcmdldCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgZGlyZWN0aW9ucyA9IFtuZXcgVmVjMygxLCAwLCAwKSwgbmV3IFZlYzMoMCwgMSwgMCksIG5ldyBWZWMzKDAsIDAsIDEpXTsKICBjb25zdCB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSBuZXcgVmVjMygpOwogIGNvbnN0IHVwZGF0ZUZyaWN0aW9uX2F4bGUgPSBbXTsKICBjb25zdCB1cGRhdGVGcmljdGlvbl9mb3J3YXJkV1MgPSBbXTsKICBjb25zdCBzaWRlRnJpY3Rpb25TdGlmZm5lc3MyID0gMTsKICBjb25zdCBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwgPSBuZXcgVmVjMygpOwoKICBmdW5jdGlvbiBjYWxjUm9sbGluZ0ZyaWN0aW9uKGJvZHkwLCBib2R5MSwgZnJpY3Rpb25Qb3NXb3JsZCwgZnJpY3Rpb25EaXJlY3Rpb25Xb3JsZCwgbWF4SW1wdWxzZSkgewogICAgbGV0IGoxID0gMDsKICAgIGNvbnN0IGNvbnRhY3RQb3NXb3JsZCA9IGZyaWN0aW9uUG9zV29ybGQ7IC8vIGNvbnN0IHJlbF9wb3MxID0gbmV3IFZlYzMoKTsKICAgIC8vIGNvbnN0IHJlbF9wb3MyID0gbmV3IFZlYzMoKTsKCiAgICBjb25zdCB2ZWwxID0gY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwxOwogICAgY29uc3QgdmVsMiA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMjsKICAgIGNvbnN0IHZlbCA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsOyAvLyBjb250YWN0UG9zV29ybGQudnN1Yihib2R5MC5wb3NpdGlvbiwgcmVsX3BvczEpOwogICAgLy8gY29udGFjdFBvc1dvcmxkLnZzdWIoYm9keTEucG9zaXRpb24sIHJlbF9wb3MyKTsKCiAgICBib2R5MC5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChjb250YWN0UG9zV29ybGQsIHZlbDEpOwogICAgYm9keTEuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoY29udGFjdFBvc1dvcmxkLCB2ZWwyKTsKICAgIHZlbDEudnN1Yih2ZWwyLCB2ZWwpOwogICAgY29uc3QgdnJlbCA9IGZyaWN0aW9uRGlyZWN0aW9uV29ybGQuZG90KHZlbCk7CiAgICBjb25zdCBkZW5vbTAgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yKGJvZHkwLCBmcmljdGlvblBvc1dvcmxkLCBmcmljdGlvbkRpcmVjdGlvbldvcmxkKTsKICAgIGNvbnN0IGRlbm9tMSA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keTEsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQpOwogICAgY29uc3QgcmVsYXhhdGlvbiA9IDE7CiAgICBjb25zdCBqYWNEaWFnQUJJbnYgPSByZWxheGF0aW9uIC8gKGRlbm9tMCArIGRlbm9tMSk7IC8vIGNhbGN1bGF0ZSBqIHRoYXQgbW92ZXMgdXMgdG8gemVybyByZWxhdGl2ZSB2ZWxvY2l0eQoKICAgIGoxID0gLXZyZWwgKiBqYWNEaWFnQUJJbnY7CgogICAgaWYgKG1heEltcHVsc2UgPCBqMSkgewogICAgICBqMSA9IG1heEltcHVsc2U7CiAgICB9CgogICAgaWYgKGoxIDwgLW1heEltcHVsc2UpIHsKICAgICAgajEgPSAtbWF4SW1wdWxzZTsKICAgIH0KCiAgICByZXR1cm4gajE7CiAgfQoKICBjb25zdCBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwID0gbmV3IFZlYzMoKTsKICBjb25zdCBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX2MwID0gbmV3IFZlYzMoKTsKICBjb25zdCBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3ZlYyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tID0gbmV3IFZlYzMoKTsKCiAgZnVuY3Rpb24gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcihib2R5LCBwb3MsIG5vcm1hbCkgewogICAgY29uc3QgcjAgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwOwogICAgY29uc3QgYzAgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX2MwOwogICAgY29uc3QgdmVjID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl92ZWM7CiAgICBjb25zdCBtID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tOwogICAgcG9zLnZzdWIoYm9keS5wb3NpdGlvbiwgcjApOwogICAgcjAuY3Jvc3Mobm9ybWFsLCBjMCk7CiAgICBib2R5LmludkluZXJ0aWFXb3JsZC52bXVsdChjMCwgbSk7CiAgICBtLmNyb3NzKHIwLCB2ZWMpOwogICAgcmV0dXJuIGJvZHkuaW52TWFzcyArIG5vcm1hbC5kb3QodmVjKTsKICB9CgogIGNvbnN0IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwyID0gbmV3IFZlYzMoKTsKICBjb25zdCByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbCA9IG5ldyBWZWMzKCk7IC8vIGJpbGF0ZXJhbCBjb25zdHJhaW50IGJldHdlZW4gdHdvIGR5bmFtaWMgb2JqZWN0cwoKICBmdW5jdGlvbiByZXNvbHZlU2luZ2xlQmlsYXRlcmFsKGJvZHkxLCBwb3MxLCBib2R5MiwgcG9zMiwgbm9ybWFsKSB7CiAgICBjb25zdCBub3JtYWxMZW5TcXIgPSBub3JtYWwubGVuZ3RoU3F1YXJlZCgpOwoKICAgIGlmIChub3JtYWxMZW5TcXIgPiAxLjEpIHsKICAgICAgcmV0dXJuIDA7IC8vIG5vIGltcHVsc2UKICAgIH0gLy8gY29uc3QgcmVsX3BvczEgPSBuZXcgVmVjMygpOwogICAgLy8gY29uc3QgcmVsX3BvczIgPSBuZXcgVmVjMygpOwogICAgLy8gcG9zMS52c3ViKGJvZHkxLnBvc2l0aW9uLCByZWxfcG9zMSk7CiAgICAvLyBwb3MyLnZzdWIoYm9keTIucG9zaXRpb24sIHJlbF9wb3MyKTsKCgogICAgY29uc3QgdmVsMSA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMTsKICAgIGNvbnN0IHZlbDIgPSByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDI7CiAgICBjb25zdCB2ZWwgPSByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDsKICAgIGJvZHkxLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHBvczEsIHZlbDEpOwogICAgYm9keTIuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocG9zMiwgdmVsMik7CiAgICB2ZWwxLnZzdWIodmVsMiwgdmVsKTsKICAgIGNvbnN0IHJlbF92ZWwgPSBub3JtYWwuZG90KHZlbCk7CiAgICBjb25zdCBjb250YWN0RGFtcGluZyA9IDAuMjsKICAgIGNvbnN0IG1hc3NUZXJtID0gMSAvIChib2R5MS5pbnZNYXNzICsgYm9keTIuaW52TWFzcyk7CiAgICBjb25zdCBpbXB1bHNlID0gLWNvbnRhY3REYW1waW5nICogcmVsX3ZlbCAqIG1hc3NUZXJtOwogICAgcmV0dXJuIGltcHVsc2U7CiAgfQoKICAvKioKICAgKiBTcGhlcmljYWwgc2hhcGUKICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCByYWRpdXMgPSAxCiAgICogICAgIGNvbnN0IHNwaGVyZVNoYXBlID0gbmV3IENBTk5PTi5TcGhlcmUocmFkaXVzKQogICAqICAgICBjb25zdCBzcGhlcmVCb2R5ID0gbmV3IENBTk5PTi5Cb2R5KHsgbWFzczogMSwgc2hhcGU6IHNwaGVyZVNoYXBlIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkoc3BoZXJlQm9keSkKICAgKi8KICBjbGFzcyBTcGhlcmUgZXh0ZW5kcyBTaGFwZSB7CiAgICAvKioKICAgICAqIFRoZSByYWRpdXMgb2YgdGhlIHNwaGVyZS4KICAgICAqLwoKICAgIC8qKgogICAgICoKICAgICAqIEBwYXJhbSByYWRpdXMgVGhlIHJhZGl1cyBvZiB0aGUgc3BoZXJlLCBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuCiAgICAgKi8KICAgIGNvbnN0cnVjdG9yKHJhZGl1cykgewogICAgICBzdXBlcih7CiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuU1BIRVJFCiAgICAgIH0pOwogICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyAhPT0gdW5kZWZpbmVkID8gcmFkaXVzIDogMS4wOwoKICAgICAgaWYgKHRoaXMucmFkaXVzIDwgMCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNwaGVyZSByYWRpdXMgY2Fubm90IGJlIG5lZ2F0aXZlLicpOwogICAgICB9CgogICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7CiAgICB9CiAgICAvKiogY2FsY3VsYXRlTG9jYWxJbmVydGlhICovCgoKICAgIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYShtYXNzLCB0YXJnZXQpIHsKICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGFyZ2V0ID0gbmV3IFZlYzMoKTsKICAgICAgfQoKICAgICAgY29uc3QgSSA9IDIuMCAqIG1hc3MgKiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzIC8gNS4wOwogICAgICB0YXJnZXQueCA9IEk7CiAgICAgIHRhcmdldC55ID0gSTsKICAgICAgdGFyZ2V0LnogPSBJOwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQogICAgLyoqIHZvbHVtZSAqLwoKCiAgICB2b2x1bWUoKSB7CiAgICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogTWF0aC5wb3codGhpcy5yYWRpdXMsIDMpIC8gMy4wOwogICAgfQoKICAgIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkgewogICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gdGhpcy5yYWRpdXM7CiAgICB9CgogICAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHsKICAgICAgY29uc3QgciA9IHRoaXMucmFkaXVzOwogICAgICBjb25zdCBheGVzID0gWyd4JywgJ3knLCAneiddOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgYXggPSBheGVzW2ldOwogICAgICAgIG1pbltheF0gPSBwb3NbYXhdIC0gcjsKICAgICAgICBtYXhbYXhdID0gcG9zW2F4XSArIHI7CiAgICAgIH0KICAgIH0KCiAgfQogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOyAvLyBUZW1wIHZlY3RvcnMgZm9yIGNhbGN1bGF0aW9uCgogIG5ldyBWZWMzKCk7IC8vIFJlbGF0aXZlIHZlbG9jaXR5CgogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKCiAgLyoqCiAgICogQ3lsaW5kZXIgY2xhc3MuCiAgICogQGV4YW1wbGUKICAgKiAgICAgY29uc3QgcmFkaXVzVG9wID0gMC41CiAgICogICAgIGNvbnN0IHJhZGl1c0JvdHRvbSA9IDAuNQogICAqICAgICBjb25zdCBoZWlnaHQgPSAyCiAgICogICAgIGNvbnN0IG51bVNlZ21lbnRzID0gMTIKICAgKiAgICAgY29uc3QgY3lsaW5kZXJTaGFwZSA9IG5ldyBDQU5OT04uQ3lsaW5kZXIocmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgbnVtU2VnbWVudHMpCiAgICogICAgIGNvbnN0IGN5bGluZGVyQm9keSA9IG5ldyBDQU5OT04uQm9keSh7IG1hc3M6IDEsIHNoYXBlOiBjeWxpbmRlclNoYXBlIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkoY3lsaW5kZXJCb2R5KQogICAqLwoKICBjbGFzcyBDeWxpbmRlciBleHRlbmRzIENvbnZleFBvbHloZWRyb24gewogICAgLyoqIFRoZSByYWRpdXMgb2YgdGhlIHRvcCBvZiB0aGUgQ3lsaW5kZXIuICovCgogICAgLyoqIFRoZSByYWRpdXMgb2YgdGhlIGJvdHRvbSBvZiB0aGUgQ3lsaW5kZXIuICovCgogICAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIEN5bGluZGVyLiAqLwoKICAgIC8qKiBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIHRvIGJ1aWxkIHRoZSBjeWxpbmRlciBvdXQgb2YuICovCgogICAgLyoqCiAgICAgKiBAcGFyYW0gcmFkaXVzVG9wIFRoZSByYWRpdXMgb2YgdGhlIHRvcCBvZiB0aGUgQ3lsaW5kZXIuCiAgICAgKiBAcGFyYW0gcmFkaXVzQm90dG9tIFRoZSByYWRpdXMgb2YgdGhlIGJvdHRvbSBvZiB0aGUgQ3lsaW5kZXIuCiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIEN5bGluZGVyLgogICAgICogQHBhcmFtIG51bVNlZ21lbnRzIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgdG8gYnVpbGQgdGhlIGN5bGluZGVyIG91dCBvZi4KICAgICAqLwogICAgY29uc3RydWN0b3IocmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgbnVtU2VnbWVudHMpIHsKICAgICAgaWYgKHJhZGl1c1RvcCA9PT0gdm9pZCAwKSB7CiAgICAgICAgcmFkaXVzVG9wID0gMTsKICAgICAgfQoKICAgICAgaWYgKHJhZGl1c0JvdHRvbSA9PT0gdm9pZCAwKSB7CiAgICAgICAgcmFkaXVzQm90dG9tID0gMTsKICAgICAgfQoKICAgICAgaWYgKGhlaWdodCA9PT0gdm9pZCAwKSB7CiAgICAgICAgaGVpZ2h0ID0gMTsKICAgICAgfQoKICAgICAgaWYgKG51bVNlZ21lbnRzID09PSB2b2lkIDApIHsKICAgICAgICBudW1TZWdtZW50cyA9IDg7CiAgICAgIH0KCiAgICAgIGlmIChyYWRpdXNUb3AgPCAwKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3lsaW5kZXIgcmFkaXVzVG9wIGNhbm5vdCBiZSBuZWdhdGl2ZS4nKTsKICAgICAgfQoKICAgICAgaWYgKHJhZGl1c0JvdHRvbSA8IDApIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjeWxpbmRlciByYWRpdXNCb3R0b20gY2Fubm90IGJlIG5lZ2F0aXZlLicpOwogICAgICB9CgogICAgICBjb25zdCBOID0gbnVtU2VnbWVudHM7CiAgICAgIGNvbnN0IHZlcnRpY2VzID0gW107CiAgICAgIGNvbnN0IGF4ZXMgPSBbXTsKICAgICAgY29uc3QgZmFjZXMgPSBbXTsKICAgICAgY29uc3QgYm90dG9tZmFjZSA9IFtdOwogICAgICBjb25zdCB0b3BmYWNlID0gW107CiAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zOwogICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbjsgLy8gRmlyc3QgYm90dG9tIHBvaW50CgogICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZWMzKC1yYWRpdXNCb3R0b20gKiBzaW4oMCksIC1oZWlnaHQgKiAwLjUsIHJhZGl1c0JvdHRvbSAqIGNvcygwKSkpOwogICAgICBib3R0b21mYWNlLnB1c2goMCk7IC8vIEZpcnN0IHRvcCBwb2ludAoKICAgICAgdmVydGljZXMucHVzaChuZXcgVmVjMygtcmFkaXVzVG9wICogc2luKDApLCBoZWlnaHQgKiAwLjUsIHJhZGl1c1RvcCAqIGNvcygwKSkpOwogICAgICB0b3BmYWNlLnB1c2goMSk7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykgewogICAgICAgIGNvbnN0IHRoZXRhID0gMiAqIE1hdGguUEkgLyBOICogKGkgKyAxKTsKICAgICAgICBjb25zdCB0aGV0YU4gPSAyICogTWF0aC5QSSAvIE4gKiAoaSArIDAuNSk7CgogICAgICAgIGlmIChpIDwgTiAtIDEpIHsKICAgICAgICAgIC8vIEJvdHRvbQogICAgICAgICAgdmVydGljZXMucHVzaChuZXcgVmVjMygtcmFkaXVzQm90dG9tICogc2luKHRoZXRhKSwgLWhlaWdodCAqIDAuNSwgcmFkaXVzQm90dG9tICogY29zKHRoZXRhKSkpOwogICAgICAgICAgYm90dG9tZmFjZS5wdXNoKDIgKiBpICsgMik7IC8vIFRvcAoKICAgICAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlYzMoLXJhZGl1c1RvcCAqIHNpbih0aGV0YSksIGhlaWdodCAqIDAuNSwgcmFkaXVzVG9wICogY29zKHRoZXRhKSkpOwogICAgICAgICAgdG9wZmFjZS5wdXNoKDIgKiBpICsgMyk7IC8vIEZhY2UKCiAgICAgICAgICBmYWNlcy5wdXNoKFsyICogaSwgMiAqIGkgKyAxLCAyICogaSArIDMsIDIgKiBpICsgMl0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBmYWNlcy5wdXNoKFsyICogaSwgMiAqIGkgKyAxLCAxLCAwXSk7IC8vIENvbm5lY3QKICAgICAgICB9IC8vIEF4aXM6IHdlIGNhbiBjdXQgb2ZmIGhhbGYgb2YgdGhlbSBpZiB3ZSBoYXZlIGV2ZW4gbnVtYmVyIG9mIHNlZ21lbnRzCgoKICAgICAgICBpZiAoTiAlIDIgPT09IDEgfHwgaSA8IE4gLyAyKSB7CiAgICAgICAgICBheGVzLnB1c2gobmV3IFZlYzMoLXNpbih0aGV0YU4pLCAwLCBjb3ModGhldGFOKSkpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgZmFjZXMucHVzaChib3R0b21mYWNlKTsKICAgICAgYXhlcy5wdXNoKG5ldyBWZWMzKDAsIDEsIDApKTsgLy8gUmVvcmRlciB0b3AgZmFjZQoKICAgICAgY29uc3QgdGVtcCA9IFtdOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3BmYWNlLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdGVtcC5wdXNoKHRvcGZhY2VbdG9wZmFjZS5sZW5ndGggLSBpIC0gMV0pOwogICAgICB9CgogICAgICBmYWNlcy5wdXNoKHRlbXApOwogICAgICBzdXBlcih7CiAgICAgICAgdmVydGljZXMsCiAgICAgICAgZmFjZXMsCiAgICAgICAgYXhlcwogICAgICB9KTsKICAgICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuQ1lMSU5ERVI7CiAgICAgIHRoaXMucmFkaXVzVG9wID0gcmFkaXVzVG9wOwogICAgICB0aGlzLnJhZGl1c0JvdHRvbSA9IHJhZGl1c0JvdHRvbTsKICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7CiAgICAgIHRoaXMubnVtU2VnbWVudHMgPSBudW1TZWdtZW50czsKICAgIH0KCiAgfQoKICAvKioKICAgKiBQYXJ0aWNsZSBzaGFwZS4KICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCBwYXJ0aWNsZVNoYXBlID0gbmV3IENBTk5PTi5QYXJ0aWNsZSgpCiAgICogICAgIGNvbnN0IHBhcnRpY2xlQm9keSA9IG5ldyBDQU5OT04uQm9keSh7IG1hc3M6IDEsIHNoYXBlOiBwYXJ0aWNsZVNoYXBlIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkocGFydGljbGVCb2R5KQogICAqLwogIGNsYXNzIFBhcnRpY2xlIGV4dGVuZHMgU2hhcGUgewogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHN1cGVyKHsKICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5QQVJUSUNMRQogICAgICB9KTsKICAgIH0KICAgIC8qKgogICAgICogY2FsY3VsYXRlTG9jYWxJbmVydGlhCiAgICAgKi8KCgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0YXJnZXQuc2V0KDAsIDAsIDApOwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQoKICAgIHZvbHVtZSgpIHsKICAgICAgcmV0dXJuIDA7CiAgICB9CgogICAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7CiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSAwOwogICAgfQoKICAgIGNhbGN1bGF0ZVdvcmxkQUFCQihwb3MsIHF1YXQsIG1pbiwgbWF4KSB7CiAgICAgIC8vIEdldCBlYWNoIGF4aXMgbWF4CiAgICAgIG1pbi5jb3B5KHBvcyk7CiAgICAgIG1heC5jb3B5KHBvcyk7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQSBwbGFuZSwgZmFjaW5nIGluIHRoZSBaIGRpcmVjdGlvbi4gVGhlIHBsYW5lIGhhcyBpdHMgc3VyZmFjZSBhdCB6PTAgYW5kIGV2ZXJ5dGhpbmcgYmVsb3cgej0wIGlzIGFzc3VtZWQgdG8gYmUgc29saWQgcGxhbmUuIFRvIG1ha2UgdGhlIHBsYW5lIGZhY2UgaW4gc29tZSBvdGhlciBkaXJlY3Rpb24gdGhhbiB6LCB5b3UgbXVzdCBwdXQgaXQgaW5zaWRlIGEgQm9keSBhbmQgcm90YXRlIHRoYXQgYm9keS4gU2VlIHRoZSBkZW1vcy4KICAgKiBAZXhhbXBsZQogICAqICAgICBjb25zdCBwbGFuZVNoYXBlID0gbmV3IENBTk5PTi5QbGFuZSgpCiAgICogICAgIGNvbnN0IHBsYW5lQm9keSA9IG5ldyBDQU5OT04uQm9keSh7IG1hc3M6IDAsIHNoYXBlOiAgcGxhbmVTaGFwZSB9KQogICAqICAgICBwbGFuZUJvZHkucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoLU1hdGguUEkgLyAyLCAwLCAwKSAvLyBtYWtlIGl0IGZhY2UgdXAKICAgKiAgICAgd29ybGQuYWRkQm9keShwbGFuZUJvZHkpCiAgICovCiAgY2xhc3MgUGxhbmUgZXh0ZW5kcyBTaGFwZSB7CiAgICAvKiogd29ybGROb3JtYWwgKi8KCiAgICAvKiogd29ybGROb3JtYWxOZWVkc1VwZGF0ZSAqLwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHN1cGVyKHsKICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5QTEFORQogICAgICB9KTsgLy8gV29ybGQgb3JpZW50ZWQgbm9ybWFsCgogICAgICB0aGlzLndvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlID0gdHJ1ZTsKICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7CiAgICB9CiAgICAvKiogY29tcHV0ZVdvcmxkTm9ybWFsICovCgoKICAgIGNvbXB1dGVXb3JsZE5vcm1hbChxdWF0KSB7CiAgICAgIGNvbnN0IG4gPSB0aGlzLndvcmxkTm9ybWFsOwogICAgICBuLnNldCgwLCAwLCAxKTsKICAgICAgcXVhdC52bXVsdChuLCBuKTsKICAgICAgdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlID0gZmFsc2U7CiAgICB9CgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQoKICAgIHZvbHVtZSgpIHsKICAgICAgcmV0dXJuICgvLyBUaGUgcGxhbmUgaXMgaW5maW5pdGUuLi4KICAgICAgICBOdW1iZXIuTUFYX1ZBTFVFCiAgICAgICk7CiAgICB9CgogICAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHsKICAgICAgLy8gVGhlIHBsYW5lIEFBQkIgaXMgaW5maW5pdGUsIGV4Y2VwdCBpZiB0aGUgbm9ybWFsIGlzIHBvaW50aW5nIGFsb25nIGFueSBheGlzCiAgICAgIHRlbXBOb3JtYWwuc2V0KDAsIDAsIDEpOyAvLyBEZWZhdWx0IHBsYW5lIG5vcm1hbCBpcyB6CgogICAgICBxdWF0LnZtdWx0KHRlbXBOb3JtYWwsIHRlbXBOb3JtYWwpOwogICAgICBjb25zdCBtYXhWYWwgPSBOdW1iZXIuTUFYX1ZBTFVFOwogICAgICBtaW4uc2V0KC1tYXhWYWwsIC1tYXhWYWwsIC1tYXhWYWwpOwogICAgICBtYXguc2V0KG1heFZhbCwgbWF4VmFsLCBtYXhWYWwpOwoKICAgICAgaWYgKHRlbXBOb3JtYWwueCA9PT0gMSkgewogICAgICAgIG1heC54ID0gcG9zLng7CiAgICAgIH0gZWxzZSBpZiAodGVtcE5vcm1hbC54ID09PSAtMSkgewogICAgICAgIG1pbi54ID0gcG9zLng7CiAgICAgIH0KCiAgICAgIGlmICh0ZW1wTm9ybWFsLnkgPT09IDEpIHsKICAgICAgICBtYXgueSA9IHBvcy55OwogICAgICB9IGVsc2UgaWYgKHRlbXBOb3JtYWwueSA9PT0gLTEpIHsKICAgICAgICBtaW4ueSA9IHBvcy55OwogICAgICB9CgogICAgICBpZiAodGVtcE5vcm1hbC56ID09PSAxKSB7CiAgICAgICAgbWF4LnogPSBwb3MuejsKICAgICAgfSBlbHNlIGlmICh0ZW1wTm9ybWFsLnogPT09IC0xKSB7CiAgICAgICAgbWluLnogPSBwb3MuejsKICAgICAgfQogICAgfQoKICAgIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkgewogICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTsKICAgIH0KCiAgfQogIGNvbnN0IHRlbXBOb3JtYWwgPSBuZXcgVmVjMygpOwoKICAvKioKICAgKiBIZWlnaHRmaWVsZCBzaGFwZSBjbGFzcy4gSGVpZ2h0IGRhdGEgaXMgZ2l2ZW4gYXMgYW4gYXJyYXkuIFRoZXNlIGRhdGEgcG9pbnRzIGFyZSBzcHJlYWQgb3V0IGV2ZW5seSB3aXRoIGEgZ2l2ZW4gZGlzdGFuY2UuCiAgICogQHRvZG8gU2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVzZSBhbG9uZyBhbGwgYXhlcywgbm90IGp1c3QgeQogICAqIEB0b2RvIHNob3VsZCBiZSBwb3NzaWJsZSB0byBzY2FsZSBhbG9uZyBhbGwgYXhlcwogICAqIEB0b2RvIFJlZmFjdG9yIGVsZW1lbnRTaXplIHRvIGVsZW1lbnRTaXplWCBhbmQgZWxlbWVudFNpemVZCiAgICoKICAgKiBAZXhhbXBsZQogICAqICAgICAvLyBHZW5lcmF0ZSBzb21lIGhlaWdodCBkYXRhICh5LXZhbHVlcykuCiAgICogICAgIGNvbnN0IGRhdGEgPSBbXQogICAqICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDA7IGkrKykgewogICAqICAgICAgICAgY29uc3QgeSA9IDAuNSAqIE1hdGguY29zKDAuMiAqIGkpCiAgICogICAgICAgICBkYXRhLnB1c2goeSkKICAgKiAgICAgfQogICAqCiAgICogICAgIC8vIENyZWF0ZSB0aGUgaGVpZ2h0ZmllbGQgc2hhcGUKICAgKiAgICAgY29uc3QgaGVpZ2h0ZmllbGRTaGFwZSA9IG5ldyBDQU5OT04uSGVpZ2h0ZmllbGQoZGF0YSwgewogICAqICAgICAgICAgZWxlbWVudFNpemU6IDEgLy8gRGlzdGFuY2UgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBhbmQgWSBkaXJlY3Rpb25zCiAgICogICAgIH0pCiAgICogICAgIGNvbnN0IGhlaWdodGZpZWxkQm9keSA9IG5ldyBDQU5OT04uQm9keSh7IHNoYXBlOiBoZWlnaHRmaWVsZFNoYXBlIH0pCiAgICogICAgIHdvcmxkLmFkZEJvZHkoaGVpZ2h0ZmllbGRCb2R5KQogICAqLwogIGNsYXNzIEhlaWdodGZpZWxkIGV4dGVuZHMgU2hhcGUgewogICAgLyoqCiAgICAgKiBBbiBhcnJheSBvZiBudW1iZXJzLCBvciBoZWlnaHQgdmFsdWVzLCB0aGF0IGFyZSBzcHJlYWQgb3V0IGFsb25nIHRoZSB4IGF4aXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludHMgaW4gdGhlIGRhdGEgYXJyYXkuCiAgICAgKi8KCiAgICAvKioKICAgICAqIE1pbmltdW0gdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnRzIGluIHRoZSBkYXRhIGFycmF5LgogICAgICovCgogICAgLyoqCiAgICAgKiBXb3JsZCBzcGFjaW5nIGJldHdlZW4gdGhlIGRhdGEgcG9pbnRzIGluIFggYW5kIFkgZGlyZWN0aW9uLgogICAgICogQHRvZG8gZWxlbWVudFNpemVYIGFuZCBZCiAgICAgKiBAZGVmYXVsdCAxCiAgICAgKi8KCiAgICAvKioKICAgICAqIEBkZWZhdWx0IHRydWUKICAgICAqLwoKICAgIC8qKgogICAgICogQHBhcmFtIGRhdGEgQW4gYXJyYXkgb2YgbnVtYmVycywgb3IgaGVpZ2h0IHZhbHVlcywgdGhhdCBhcmUgc3ByZWFkIG91dCBhbG9uZyB0aGUgeCBheGlzLgogICAgICovCiAgICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7CiAgICAgICAgbWF4VmFsdWU6IG51bGwsCiAgICAgICAgbWluVmFsdWU6IG51bGwsCiAgICAgICAgZWxlbWVudFNpemU6IDEKICAgICAgfSk7CiAgICAgIHN1cGVyKHsKICAgICAgICB0eXBlOiBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRAogICAgICB9KTsKICAgICAgdGhpcy5kYXRhID0gZGF0YTsKICAgICAgdGhpcy5tYXhWYWx1ZSA9IG9wdGlvbnMubWF4VmFsdWU7CiAgICAgIHRoaXMubWluVmFsdWUgPSBvcHRpb25zLm1pblZhbHVlOwogICAgICB0aGlzLmVsZW1lbnRTaXplID0gb3B0aW9ucy5lbGVtZW50U2l6ZTsKCiAgICAgIGlmIChvcHRpb25zLm1pblZhbHVlID09PSBudWxsKSB7CiAgICAgICAgdGhpcy51cGRhdGVNaW5WYWx1ZSgpOwogICAgICB9CgogICAgICBpZiAob3B0aW9ucy5tYXhWYWx1ZSA9PT0gbnVsbCkgewogICAgICAgIHRoaXMudXBkYXRlTWF4VmFsdWUoKTsKICAgICAgfQoKICAgICAgdGhpcy5jYWNoZUVuYWJsZWQgPSB0cnVlOwogICAgICB0aGlzLnBpbGxhckNvbnZleCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7CiAgICAgIHRoaXMucGlsbGFyT2Zmc2V0ID0gbmV3IFZlYzMoKTsKICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpOyAvLyAiaV9qX2lzVXBwZXIiID0+IHsgY29udmV4OiAuLi4sIG9mZnNldDogLi4uIH0KICAgICAgLy8gZm9yIGV4YW1wbGU6CiAgICAgIC8vIF9jYWNoZWRQaWxsYXJzWyIwXzJfMSJdCgogICAgICB0aGlzLl9jYWNoZWRQaWxsYXJzID0ge307CiAgICB9CiAgICAvKioKICAgICAqIENhbGwgd2hlbmV2ZXIgeW91IGNoYW5nZSB0aGUgZGF0YSBhcnJheS4KICAgICAqLwoKCiAgICB1cGRhdGUoKSB7CiAgICAgIHRoaXMuX2NhY2hlZFBpbGxhcnMgPSB7fTsKICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlIHRoZSBgbWluVmFsdWVgIHByb3BlcnR5CiAgICAgKi8KCgogICAgdXBkYXRlTWluVmFsdWUoKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGxldCBtaW5WYWx1ZSA9IGRhdGFbMF1bMF07CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBkYXRhW2ldLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBjb25zdCB2ID0gZGF0YVtpXVtqXTsKCiAgICAgICAgICBpZiAodiA8IG1pblZhbHVlKSB7CiAgICAgICAgICAgIG1pblZhbHVlID0gdjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMubWluVmFsdWUgPSBtaW5WYWx1ZTsKICAgIH0KICAgIC8qKgogICAgICogVXBkYXRlIHRoZSBgbWF4VmFsdWVgIHByb3BlcnR5CiAgICAgKi8KCgogICAgdXBkYXRlTWF4VmFsdWUoKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGxldCBtYXhWYWx1ZSA9IGRhdGFbMF1bMF07CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBkYXRhW2ldLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBjb25zdCB2ID0gZGF0YVtpXVtqXTsKCiAgICAgICAgICBpZiAodiA+IG1heFZhbHVlKSB7CiAgICAgICAgICAgIG1heFZhbHVlID0gdjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMubWF4VmFsdWUgPSBtYXhWYWx1ZTsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHRoZSBoZWlnaHQgdmFsdWUgYXQgYW4gaW5kZXguIERvbid0IGZvcmdldCB0byB1cGRhdGUgbWF4VmFsdWUgYW5kIG1pblZhbHVlIGFmdGVyIHlvdSdyZSBkb25lLgogICAgICovCgoKICAgIHNldEhlaWdodFZhbHVlQXRJbmRleCh4aSwgeWksIHZhbHVlKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGRhdGFbeGldW3lpXSA9IHZhbHVlOyAvLyBJbnZhbGlkYXRlIGNhY2hlCgogICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBmYWxzZSk7CgogICAgICBpZiAoeGkgPiAwKSB7CiAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpIC0gMSwgeWksIHRydWUpOwogICAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSAtIDEsIHlpLCBmYWxzZSk7CiAgICAgIH0KCiAgICAgIGlmICh5aSA+IDApIHsKICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpIC0gMSwgdHJ1ZSk7CiAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSAtIDEsIGZhbHNlKTsKICAgICAgfQoKICAgICAgaWYgKHlpID4gMCAmJiB4aSA+IDApIHsKICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSAtIDEsIHRydWUpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEdldCBtYXgvbWluIGluIGEgcmVjdGFuZ2xlIGluIHRoZSBtYXRyaXggZGF0YQogICAgICogQHBhcmFtIHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi4KICAgICAqIEByZXR1cm4gVGhlIHJlc3VsdCBhcnJheSwgaWYgaXQgd2FzIHBhc3NlZCBpbi4gTWluaW11bSB3aWxsIGJlIGF0IHBvc2l0aW9uIDAgYW5kIG1heCBhdCAxLgogICAgICovCgoKICAgIGdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIHJlc3VsdCkgewogICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsKICAgICAgICByZXN1bHQgPSBbXTsKICAgICAgfQoKICAgICAgLy8gR2V0IG1heCBhbmQgbWluIG9mIHRoZSBkYXRhCiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7IC8vIFNldCBmaXJzdCB2YWx1ZQoKICAgICAgbGV0IG1heCA9IHRoaXMubWluVmFsdWU7CgogICAgICBmb3IgKGxldCBpID0gaU1pblg7IGkgPD0gaU1heFg7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSBpTWluWTsgaiA8PSBpTWF4WTsgaisrKSB7CiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBkYXRhW2ldW2pdOwoKICAgICAgICAgIGlmIChoZWlnaHQgPiBtYXgpIHsKICAgICAgICAgICAgbWF4ID0gaGVpZ2h0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmVzdWx0WzBdID0gdGhpcy5taW5WYWx1ZTsKICAgICAgcmVzdWx0WzFdID0gbWF4OwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGluZGV4IG9mIGEgbG9jYWwgcG9zaXRpb24gb24gdGhlIGhlaWdodGZpZWxkLiBUaGUgaW5kZXhlcyBpbmRpY2F0ZSB0aGUgcmVjdGFuZ2xlcywgc28gaWYgeW91ciB0ZXJyYWluIGlzIG1hZGUgb2YgTiB4IE4gaGVpZ2h0IGRhdGEgcG9pbnRzLCB5b3Ugd2lsbCBoYXZlIHJlY3RhbmdsZSBpbmRleGVzIHJhbmdpbmcgZnJvbSAwIHRvIE4tMS4KICAgICAqIEBwYXJhbSByZXN1bHQgVHdvLWVsZW1lbnQgYXJyYXkKICAgICAqIEBwYXJhbSBjbGFtcCBJZiB0aGUgcG9zaXRpb24gc2hvdWxkIGJlIGNsYW1wZWQgdG8gdGhlIGhlaWdodGZpZWxkIGVkZ2UuCiAgICAgKi8KCgogICAgZ2V0SW5kZXhPZlBvc2l0aW9uKHgsIHksIHJlc3VsdCwgY2xhbXApIHsKICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0CiAgICAgIGNvbnN0IHcgPSB0aGlzLmVsZW1lbnRTaXplOwogICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhOwogICAgICBsZXQgeGkgPSBNYXRoLmZsb29yKHggLyB3KTsKICAgICAgbGV0IHlpID0gTWF0aC5mbG9vcih5IC8gdyk7CiAgICAgIHJlc3VsdFswXSA9IHhpOwogICAgICByZXN1bHRbMV0gPSB5aTsKCiAgICAgIGlmIChjbGFtcCkgewogICAgICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzCiAgICAgICAgaWYgKHhpIDwgMCkgewogICAgICAgICAgeGkgPSAwOwogICAgICAgIH0KCiAgICAgICAgaWYgKHlpIDwgMCkgewogICAgICAgICAgeWkgPSAwOwogICAgICAgIH0KCiAgICAgICAgaWYgKHhpID49IGRhdGEubGVuZ3RoIC0gMSkgewogICAgICAgICAgeGkgPSBkYXRhLmxlbmd0aCAtIDE7CiAgICAgICAgfQoKICAgICAgICBpZiAoeWkgPj0gZGF0YVswXS5sZW5ndGggLSAxKSB7CiAgICAgICAgICB5aSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsKICAgICAgICB9CiAgICAgIH0gLy8gQmFpbCBvdXQgaWYgd2UgYXJlIG91dCBvZiB0aGUgdGVycmFpbgoKCiAgICAgIGlmICh4aSA8IDAgfHwgeWkgPCAwIHx8IHhpID49IGRhdGEubGVuZ3RoIC0gMSB8fCB5aSA+PSBkYXRhWzBdLmxlbmd0aCAtIDEpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGdldFRyaWFuZ2xlQXQoeCwgeSwgZWRnZUNsYW1wLCBhLCBiLCBjKSB7CiAgICAgIGNvbnN0IGlkeCA9IGdldEhlaWdodEF0X2lkeDsKICAgICAgdGhpcy5nZXRJbmRleE9mUG9zaXRpb24oeCwgeSwgaWR4LCBlZGdlQ2xhbXApOwogICAgICBsZXQgeGkgPSBpZHhbMF07CiAgICAgIGxldCB5aSA9IGlkeFsxXTsKICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTsKCiAgICAgIGlmIChlZGdlQ2xhbXApIHsKICAgICAgICB4aSA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gMiwgTWF0aC5tYXgoMCwgeGkpKTsKICAgICAgICB5aSA9IE1hdGgubWluKGRhdGFbMF0ubGVuZ3RoIC0gMiwgTWF0aC5tYXgoMCwgeWkpKTsKICAgICAgfQoKICAgICAgY29uc3QgZWxlbWVudFNpemUgPSB0aGlzLmVsZW1lbnRTaXplOwogICAgICBjb25zdCBsb3dlckRpc3QyID0gKHggLyBlbGVtZW50U2l6ZSAtIHhpKSAqKiAyICsgKHkgLyBlbGVtZW50U2l6ZSAtIHlpKSAqKiAyOwogICAgICBjb25zdCB1cHBlckRpc3QyID0gKHggLyBlbGVtZW50U2l6ZSAtICh4aSArIDEpKSAqKiAyICsgKHkgLyBlbGVtZW50U2l6ZSAtICh5aSArIDEpKSAqKiAyOwogICAgICBjb25zdCB1cHBlciA9IGxvd2VyRGlzdDIgPiB1cHBlckRpc3QyOwogICAgICB0aGlzLmdldFRyaWFuZ2xlKHhpLCB5aSwgdXBwZXIsIGEsIGIsIGMpOwogICAgICByZXR1cm4gdXBwZXI7CiAgICB9CgogICAgZ2V0Tm9ybWFsQXQoeCwgeSwgZWRnZUNsYW1wLCByZXN1bHQpIHsKICAgICAgY29uc3QgYSA9IGdldE5vcm1hbEF0X2E7CiAgICAgIGNvbnN0IGIgPSBnZXROb3JtYWxBdF9iOwogICAgICBjb25zdCBjID0gZ2V0Tm9ybWFsQXRfYzsKICAgICAgY29uc3QgZTAgPSBnZXROb3JtYWxBdF9lMDsKICAgICAgY29uc3QgZTEgPSBnZXROb3JtYWxBdF9lMTsKICAgICAgdGhpcy5nZXRUcmlhbmdsZUF0KHgsIHksIGVkZ2VDbGFtcCwgYSwgYiwgYyk7CiAgICAgIGIudnN1YihhLCBlMCk7CiAgICAgIGMudnN1YihhLCBlMSk7CiAgICAgIGUwLmNyb3NzKGUxLCByZXN1bHQpOwogICAgICByZXN1bHQubm9ybWFsaXplKCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhbiBBQUJCIG9mIGEgc3F1YXJlIGluIHRoZSBoZWlnaHRmaWVsZAogICAgICogQHBhcmFtIHhpCiAgICAgKiBAcGFyYW0geWkKICAgICAqIEBwYXJhbSByZXN1bHQKICAgICAqLwoKCiAgICBnZXRBYWJiQXRJbmRleCh4aSwgeWksIF9yZWYpIHsKICAgICAgbGV0IHsKICAgICAgICBsb3dlckJvdW5kLAogICAgICAgIHVwcGVyQm91bmQKICAgICAgfSA9IF9yZWY7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gdGhpcy5lbGVtZW50U2l6ZTsKICAgICAgbG93ZXJCb3VuZC5zZXQoeGkgKiBlbGVtZW50U2l6ZSwgeWkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWldKTsKICAgICAgdXBwZXJCb3VuZC5zZXQoKHhpICsgMSkgKiBlbGVtZW50U2l6ZSwgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aSArIDFdW3lpICsgMV0pOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdGhlIGhlaWdodCBpbiB0aGUgaGVpZ2h0ZmllbGQgYXQgYSBnaXZlbiBwb3NpdGlvbgogICAgICovCgoKICAgIGdldEhlaWdodEF0KHgsIHksIGVkZ2VDbGFtcCkgewogICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhOwogICAgICBjb25zdCBhID0gZ2V0SGVpZ2h0QXRfYTsKICAgICAgY29uc3QgYiA9IGdldEhlaWdodEF0X2I7CiAgICAgIGNvbnN0IGMgPSBnZXRIZWlnaHRBdF9jOwogICAgICBjb25zdCBpZHggPSBnZXRIZWlnaHRBdF9pZHg7CiAgICAgIHRoaXMuZ2V0SW5kZXhPZlBvc2l0aW9uKHgsIHksIGlkeCwgZWRnZUNsYW1wKTsKICAgICAgbGV0IHhpID0gaWR4WzBdOwogICAgICBsZXQgeWkgPSBpZHhbMV07CgogICAgICBpZiAoZWRnZUNsYW1wKSB7CiAgICAgICAgeGkgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIDIsIE1hdGgubWF4KDAsIHhpKSk7CiAgICAgICAgeWkgPSBNYXRoLm1pbihkYXRhWzBdLmxlbmd0aCAtIDIsIE1hdGgubWF4KDAsIHlpKSk7CiAgICAgIH0KCiAgICAgIGNvbnN0IHVwcGVyID0gdGhpcy5nZXRUcmlhbmdsZUF0KHgsIHksIGVkZ2VDbGFtcCwgYSwgYiwgYyk7CiAgICAgIGJhcnljZW50cmljV2VpZ2h0cyh4LCB5LCBhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBnZXRIZWlnaHRBdF93ZWlnaHRzKTsKICAgICAgY29uc3QgdyA9IGdldEhlaWdodEF0X3dlaWdodHM7CgogICAgICBpZiAodXBwZXIpIHsKICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHMKICAgICAgICByZXR1cm4gZGF0YVt4aSArIDFdW3lpICsgMV0gKiB3LnggKyBkYXRhW3hpXVt5aSArIDFdICogdy55ICsgZGF0YVt4aSArIDFdW3lpXSAqIHcuejsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHMKICAgICAgICByZXR1cm4gZGF0YVt4aV1beWldICogdy54ICsgZGF0YVt4aSArIDFdW3lpXSAqIHcueSArIGRhdGFbeGldW3lpICsgMV0gKiB3Lno7CiAgICAgIH0KICAgIH0KCiAgICBnZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSkgewogICAgICByZXR1cm4gYCR7eGl9XyR7eWl9XyR7Z2V0VXBwZXJUcmlhbmdsZSA/IDEgOiAwfWA7CiAgICB9CgogICAgZ2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKSB7CiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQaWxsYXJzW3RoaXMuZ2V0Q2FjaGVDb252ZXhUcmlhbmdsZVBpbGxhcktleSh4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpXTsKICAgIH0KCiAgICBzZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUsIGNvbnZleCwgb2Zmc2V0KSB7CiAgICAgIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldID0gewogICAgICAgIGNvbnZleCwKICAgICAgICBvZmZzZXQKICAgICAgfTsKICAgIH0KCiAgICBjbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSkgewogICAgICBkZWxldGUgdGhpcy5fY2FjaGVkUGlsbGFyc1t0aGlzLmdldENhY2hlQ29udmV4VHJpYW5nbGVQaWxsYXJLZXkoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKV07CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhIHRyaWFuZ2xlIGZyb20gdGhlIGhlaWdodGZpZWxkCiAgICAgKi8KCgogICAgZ2V0VHJpYW5nbGUoeGksIHlpLCB1cHBlciwgYSwgYiwgYykgewogICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhOwogICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHRoaXMuZWxlbWVudFNpemU7CgogICAgICBpZiAodXBwZXIpIHsKICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHMKICAgICAgICBhLnNldCgoeGkgKyAxKSAqIGVsZW1lbnRTaXplLCAoeWkgKyAxKSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpICsgMV1beWkgKyAxXSk7CiAgICAgICAgYi5zZXQoeGkgKiBlbGVtZW50U2l6ZSwgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWkgKyAxXSk7CiAgICAgICAgYy5zZXQoKHhpICsgMSkgKiBlbGVtZW50U2l6ZSwgeWkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aSArIDFdW3lpXSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzCiAgICAgICAgYS5zZXQoeGkgKiBlbGVtZW50U2l6ZSwgeWkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWldKTsKICAgICAgICBiLnNldCgoeGkgKyAxKSAqIGVsZW1lbnRTaXplLCB5aSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpICsgMV1beWldKTsKICAgICAgICBjLnNldCh4aSAqIGVsZW1lbnRTaXplLCAoeWkgKyAxKSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpXVt5aSArIDFdKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBHZXQgYSB0cmlhbmdsZSBpbiB0aGUgdGVycmFpbiBpbiB0aGUgZm9ybSBvZiBhIHRyaWFuZ3VsYXIgY29udmV4IHNoYXBlLgogICAgICovCgoKICAgIGdldENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSkgewogICAgICBsZXQgcmVzdWx0ID0gdGhpcy5waWxsYXJDb252ZXg7CiAgICAgIGxldCBvZmZzZXRSZXN1bHQgPSB0aGlzLnBpbGxhck9mZnNldDsKCiAgICAgIGlmICh0aGlzLmNhY2hlRW5hYmxlZCkgewogICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSk7CgogICAgICAgIGlmIChkYXRhKSB7CiAgICAgICAgICB0aGlzLnBpbGxhckNvbnZleCA9IGRhdGEuY29udmV4OwogICAgICAgICAgdGhpcy5waWxsYXJPZmZzZXQgPSBkYXRhLm9mZnNldDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CgogICAgICAgIHJlc3VsdCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7CiAgICAgICAgb2Zmc2V0UmVzdWx0ID0gbmV3IFZlYzMoKTsKICAgICAgICB0aGlzLnBpbGxhckNvbnZleCA9IHJlc3VsdDsKICAgICAgICB0aGlzLnBpbGxhck9mZnNldCA9IG9mZnNldFJlc3VsdDsKICAgICAgfQoKICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTsKICAgICAgY29uc3QgZWxlbWVudFNpemUgPSB0aGlzLmVsZW1lbnRTaXplOwogICAgICBjb25zdCBmYWNlcyA9IHJlc3VsdC5mYWNlczsgLy8gUmV1c2UgdmVydHMgaWYgcG9zc2libGUKCiAgICAgIHJlc3VsdC52ZXJ0aWNlcy5sZW5ndGggPSA2OwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHsKICAgICAgICBpZiAoIXJlc3VsdC52ZXJ0aWNlc1tpXSkgewogICAgICAgICAgcmVzdWx0LnZlcnRpY2VzW2ldID0gbmV3IFZlYzMoKTsKICAgICAgICB9CiAgICAgIH0gLy8gUmV1c2UgZmFjZXMgaWYgcG9zc2libGUKCgogICAgICBmYWNlcy5sZW5ndGggPSA1OwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHsKICAgICAgICBpZiAoIWZhY2VzW2ldKSB7CiAgICAgICAgICBmYWNlc1tpXSA9IFtdOwogICAgICAgIH0KICAgICAgfQoKICAgICAgY29uc3QgdmVydHMgPSByZXN1bHQudmVydGljZXM7CiAgICAgIGNvbnN0IGggPSAoTWF0aC5taW4oZGF0YVt4aV1beWldLCBkYXRhW3hpICsgMV1beWldLCBkYXRhW3hpXVt5aSArIDFdLCBkYXRhW3hpICsgMV1beWkgKyAxXSkgLSB0aGlzLm1pblZhbHVlKSAvIDIgKyB0aGlzLm1pblZhbHVlOwoKICAgICAgaWYgKCFnZXRVcHBlclRyaWFuZ2xlKSB7CiAgICAgICAgLy8gQ2VudGVyIG9mIHRoZSB0cmlhbmdsZSBwaWxsYXIgLSBhbGwgcG9seWdvbnMgYXJlIGdpdmVuIHJlbGF0aXZlIHRvIHRoaXMgb25lCiAgICAgICAgb2Zmc2V0UmVzdWx0LnNldCgoeGkgKyAwLjI1KSAqIGVsZW1lbnRTaXplLCAvLyBzb3J0IG9mIGNlbnRlciBvZiBhIHRyaWFuZ2xlCiAgICAgICAgKHlpICsgMC4yNSkgKiBlbGVtZW50U2l6ZSwgaCAvLyB2ZXJ0aWNhbCBjZW50ZXIKICAgICAgICApOyAvLyBUb3AgdHJpYW5nbGUgdmVydHMKCiAgICAgICAgdmVydHNbMF0uc2V0KC0wLjI1ICogZWxlbWVudFNpemUsIC0wLjI1ICogZWxlbWVudFNpemUsIGRhdGFbeGldW3lpXSAtIGgpOwogICAgICAgIHZlcnRzWzFdLnNldCgwLjc1ICogZWxlbWVudFNpemUsIC0wLjI1ICogZWxlbWVudFNpemUsIGRhdGFbeGkgKyAxXVt5aV0gLSBoKTsKICAgICAgICB2ZXJ0c1syXS5zZXQoLTAuMjUgKiBlbGVtZW50U2l6ZSwgMC43NSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpXVt5aSArIDFdIC0gaCk7IC8vIGJvdHRvbSB0cmlhbmdsZSB2ZXJ0cwoKICAgICAgICB2ZXJ0c1szXS5zZXQoLTAuMjUgKiBlbGVtZW50U2l6ZSwgLTAuMjUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7CiAgICAgICAgdmVydHNbNF0uc2V0KDAuNzUgKiBlbGVtZW50U2l6ZSwgLTAuMjUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7CiAgICAgICAgdmVydHNbNV0uc2V0KC0wLjI1ICogZWxlbWVudFNpemUsIDAuNzUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7IC8vIHRvcCB0cmlhbmdsZQoKICAgICAgICBmYWNlc1swXVswXSA9IDA7CiAgICAgICAgZmFjZXNbMF1bMV0gPSAxOwogICAgICAgIGZhY2VzWzBdWzJdID0gMjsgLy8gYm90dG9tIHRyaWFuZ2xlCgogICAgICAgIGZhY2VzWzFdWzBdID0gNTsKICAgICAgICBmYWNlc1sxXVsxXSA9IDQ7CiAgICAgICAgZmFjZXNbMV1bMl0gPSAzOyAvLyAteCBmYWNpbmcgcXVhZAoKICAgICAgICBmYWNlc1syXVswXSA9IDA7CiAgICAgICAgZmFjZXNbMl1bMV0gPSAyOwogICAgICAgIGZhY2VzWzJdWzJdID0gNTsKICAgICAgICBmYWNlc1syXVszXSA9IDM7IC8vIC15IGZhY2luZyBxdWFkCgogICAgICAgIGZhY2VzWzNdWzBdID0gMTsKICAgICAgICBmYWNlc1szXVsxXSA9IDA7CiAgICAgICAgZmFjZXNbM11bMl0gPSAzOwogICAgICAgIGZhY2VzWzNdWzNdID0gNDsgLy8gK3h5IGZhY2luZyBxdWFkCgogICAgICAgIGZhY2VzWzRdWzBdID0gNDsKICAgICAgICBmYWNlc1s0XVsxXSA9IDU7CiAgICAgICAgZmFjZXNbNF1bMl0gPSAyOwogICAgICAgIGZhY2VzWzRdWzNdID0gMTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBDZW50ZXIgb2YgdGhlIHRyaWFuZ2xlIHBpbGxhciAtIGFsbCBwb2x5Z29ucyBhcmUgZ2l2ZW4gcmVsYXRpdmUgdG8gdGhpcyBvbmUKICAgICAgICBvZmZzZXRSZXN1bHQuc2V0KCh4aSArIDAuNzUpICogZWxlbWVudFNpemUsIC8vIHNvcnQgb2YgY2VudGVyIG9mIGEgdHJpYW5nbGUKICAgICAgICAoeWkgKyAwLjc1KSAqIGVsZW1lbnRTaXplLCBoIC8vIHZlcnRpY2FsIGNlbnRlcgogICAgICAgICk7IC8vIFRvcCB0cmlhbmdsZSB2ZXJ0cwoKICAgICAgICB2ZXJ0c1swXS5zZXQoMC4yNSAqIGVsZW1lbnRTaXplLCAwLjI1ICogZWxlbWVudFNpemUsIGRhdGFbeGkgKyAxXVt5aSArIDFdIC0gaCk7CiAgICAgICAgdmVydHNbMV0uc2V0KC0wLjc1ICogZWxlbWVudFNpemUsIDAuMjUgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWkgKyAxXSAtIGgpOwogICAgICAgIHZlcnRzWzJdLnNldCgwLjI1ICogZWxlbWVudFNpemUsIC0wLjc1ICogZWxlbWVudFNpemUsIGRhdGFbeGkgKyAxXVt5aV0gLSBoKTsgLy8gYm90dG9tIHRyaWFuZ2xlIHZlcnRzCgogICAgICAgIHZlcnRzWzNdLnNldCgwLjI1ICogZWxlbWVudFNpemUsIDAuMjUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7CiAgICAgICAgdmVydHNbNF0uc2V0KC0wLjc1ICogZWxlbWVudFNpemUsIDAuMjUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7CiAgICAgICAgdmVydHNbNV0uc2V0KDAuMjUgKiBlbGVtZW50U2l6ZSwgLTAuNzUgKiBlbGVtZW50U2l6ZSwgLU1hdGguYWJzKGgpIC0gMSk7IC8vIFRvcCB0cmlhbmdsZQoKICAgICAgICBmYWNlc1swXVswXSA9IDA7CiAgICAgICAgZmFjZXNbMF1bMV0gPSAxOwogICAgICAgIGZhY2VzWzBdWzJdID0gMjsgLy8gYm90dG9tIHRyaWFuZ2xlCgogICAgICAgIGZhY2VzWzFdWzBdID0gNTsKICAgICAgICBmYWNlc1sxXVsxXSA9IDQ7CiAgICAgICAgZmFjZXNbMV1bMl0gPSAzOyAvLyAreCBmYWNpbmcgcXVhZAoKICAgICAgICBmYWNlc1syXVswXSA9IDI7CiAgICAgICAgZmFjZXNbMl1bMV0gPSA1OwogICAgICAgIGZhY2VzWzJdWzJdID0gMzsKICAgICAgICBmYWNlc1syXVszXSA9IDA7IC8vICt5IGZhY2luZyBxdWFkCgogICAgICAgIGZhY2VzWzNdWzBdID0gMzsKICAgICAgICBmYWNlc1szXVsxXSA9IDQ7CiAgICAgICAgZmFjZXNbM11bMl0gPSAxOwogICAgICAgIGZhY2VzWzNdWzNdID0gMDsgLy8gLXh5IGZhY2luZyBxdWFkCgogICAgICAgIGZhY2VzWzRdWzBdID0gMTsKICAgICAgICBmYWNlc1s0XVsxXSA9IDQ7CiAgICAgICAgZmFjZXNbNF1bMl0gPSA1OwogICAgICAgIGZhY2VzWzRdWzNdID0gMjsKICAgICAgfQoKICAgICAgcmVzdWx0LmNvbXB1dGVOb3JtYWxzKCk7CiAgICAgIHJlc3VsdC5jb21wdXRlRWRnZXMoKTsKICAgICAgcmVzdWx0LnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7CiAgICAgIHRoaXMuc2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlLCByZXN1bHQsIG9mZnNldFJlc3VsdCk7CiAgICB9CgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsKICAgICAgICB0YXJnZXQgPSBuZXcgVmVjMygpOwogICAgICB9CgogICAgICB0YXJnZXQuc2V0KDAsIDAsIDApOwogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQoKICAgIHZvbHVtZSgpIHsKICAgICAgcmV0dXJuICgvLyBUaGUgdGVycmFpbiBpcyBpbmZpbml0ZQogICAgICAgIE51bWJlci5NQVhfVkFMVUUKICAgICAgKTsKICAgIH0KCiAgICBjYWxjdWxhdGVXb3JsZEFBQkIocG9zLCBxdWF0LCBtaW4sIG1heCkgewogICAgICAvKiogQFRPRE8gZG8gaXQgcHJvcGVybHkgKi8KICAgICAgbWluLnNldCgtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFKTsKICAgICAgbWF4LnNldChOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTsKICAgIH0KCiAgICB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIHsKICAgICAgLy8gVXNlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIG1pbi9tYXggdmFsdWVzCiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGNvbnN0IHMgPSB0aGlzLmVsZW1lbnRTaXplOwogICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gbmV3IFZlYzMoZGF0YS5sZW5ndGggKiBzLCBkYXRhWzBdLmxlbmd0aCAqIHMsIE1hdGgubWF4KE1hdGguYWJzKHRoaXMubWF4VmFsdWUpLCBNYXRoLmFicyh0aGlzLm1pblZhbHVlKSkpLmxlbmd0aCgpOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgdmFsdWVzIGZyb20gYW4gaW1hZ2UuIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBpbiBicm93c2VyLgogICAgICovCgoKICAgIHNldEhlaWdodHNGcm9tSW1hZ2UoaW1hZ2UsIHNjYWxlKSB7CiAgICAgIGNvbnN0IHsKICAgICAgICB4LAogICAgICAgIHosCiAgICAgICAgeQogICAgICB9ID0gc2NhbGU7CiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOwogICAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDsKICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDsKICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOwogICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7CiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpOwogICAgICBjb25zdCBtYXRyaXggPSB0aGlzLmRhdGE7CiAgICAgIG1hdHJpeC5sZW5ndGggPSAwOwogICAgICB0aGlzLmVsZW1lbnRTaXplID0gTWF0aC5hYnMoeCkgLyBpbWFnZURhdGEud2lkdGg7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlRGF0YS5oZWlnaHQ7IGkrKykgewogICAgICAgIGNvbnN0IHJvdyA9IFtdOwoKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGltYWdlRGF0YS53aWR0aDsgaisrKSB7CiAgICAgICAgICBjb25zdCBhID0gaW1hZ2VEYXRhLmRhdGFbKGkgKiBpbWFnZURhdGEuaGVpZ2h0ICsgaikgKiA0XTsKICAgICAgICAgIGNvbnN0IGIgPSBpbWFnZURhdGEuZGF0YVsoaSAqIGltYWdlRGF0YS5oZWlnaHQgKyBqKSAqIDQgKyAxXTsKICAgICAgICAgIGNvbnN0IGMgPSBpbWFnZURhdGEuZGF0YVsoaSAqIGltYWdlRGF0YS5oZWlnaHQgKyBqKSAqIDQgKyAyXTsKICAgICAgICAgIGNvbnN0IGhlaWdodCA9IChhICsgYiArIGMpIC8gNCAvIDI1NSAqIHo7CgogICAgICAgICAgaWYgKHggPCAwKSB7CiAgICAgICAgICAgIHJvdy5wdXNoKGhlaWdodCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByb3cudW5zaGlmdChoZWlnaHQpOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKHkgPCAwKSB7CiAgICAgICAgICBtYXRyaXgudW5zaGlmdChyb3cpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBtYXRyaXgucHVzaChyb3cpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy51cGRhdGVNYXhWYWx1ZSgpOwogICAgICB0aGlzLnVwZGF0ZU1pblZhbHVlKCk7CiAgICAgIHRoaXMudXBkYXRlKCk7CiAgICB9CgogIH0KICBjb25zdCBnZXRIZWlnaHRBdF9pZHggPSBbXTsKICBjb25zdCBnZXRIZWlnaHRBdF93ZWlnaHRzID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXRIZWlnaHRBdF9hID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXRIZWlnaHRBdF9iID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXRIZWlnaHRBdF9jID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXROb3JtYWxBdF9hID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXROb3JtYWxBdF9iID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXROb3JtYWxBdF9jID0gbmV3IFZlYzMoKTsKICBjb25zdCBnZXROb3JtYWxBdF9lMCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgZ2V0Tm9ybWFsQXRfZTEgPSBuZXcgVmVjMygpOyAvLyBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JhcnljZW50cmljX2Nvb3JkaW5hdGVfc3lzdGVtCgogIGZ1bmN0aW9uIGJhcnljZW50cmljV2VpZ2h0cyh4LCB5LCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCByZXN1bHQpIHsKICAgIHJlc3VsdC54ID0gKChieSAtIGN5KSAqICh4IC0gY3gpICsgKGN4IC0gYngpICogKHkgLSBjeSkpIC8gKChieSAtIGN5KSAqIChheCAtIGN4KSArIChjeCAtIGJ4KSAqIChheSAtIGN5KSk7CiAgICByZXN1bHQueSA9ICgoY3kgLSBheSkgKiAoeCAtIGN4KSArIChheCAtIGN4KSAqICh5IC0gY3kpKSAvICgoYnkgLSBjeSkgKiAoYXggLSBjeCkgKyAoY3ggLSBieCkgKiAoYXkgLSBjeSkpOwogICAgcmVzdWx0LnogPSAxIC0gcmVzdWx0LnggLSByZXN1bHQueTsKICB9CgogIC8qKgogICAqIE9jdHJlZU5vZGUKICAgKi8KICBjbGFzcyBPY3RyZWVOb2RlIHsKICAgIC8qKiBUaGUgcm9vdCBub2RlICovCgogICAgLyoqIEJvdW5kYXJ5IG9mIHRoaXMgbm9kZSAqLwoKICAgIC8qKiBDb250YWluZWQgZGF0YSBhdCB0aGUgY3VycmVudCBub2RlIGxldmVsICovCgogICAgLyoqIENoaWxkcmVuIHRvIHRoaXMgbm9kZSAqLwogICAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgbnVsbDsKICAgICAgdGhpcy5hYWJiID0gb3B0aW9ucy5hYWJiID8gb3B0aW9ucy5hYWJiLmNsb25lKCkgOiBuZXcgQUFCQigpOwogICAgICB0aGlzLmRhdGEgPSBbXTsKICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdOwogICAgfQogICAgLyoqCiAgICAgKiByZXNldAogICAgICovCgoKICAgIHJlc2V0KCkgewogICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggPSAwOwogICAgfQogICAgLyoqCiAgICAgKiBJbnNlcnQgZGF0YSBpbnRvIHRoaXMgbm9kZQogICAgICogQHJldHVybiBUcnVlIGlmIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBmYWxzZQogICAgICovCgoKICAgIGluc2VydChhYWJiLCBlbGVtZW50RGF0YSwgbGV2ZWwpIHsKICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsKICAgICAgICBsZXZlbCA9IDA7CiAgICAgIH0KCiAgICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5kYXRhOyAvLyBJZ25vcmUgb2JqZWN0cyB0aGF0IGRvIG5vdCBiZWxvbmcgaW4gdGhpcyBub2RlCgogICAgICBpZiAoIXRoaXMuYWFiYi5jb250YWlucyhhYWJiKSkgewogICAgICAgIHJldHVybiBmYWxzZTsgLy8gb2JqZWN0IGNhbm5vdCBiZSBhZGRlZAogICAgICB9CgogICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47CiAgICAgIGNvbnN0IG1heERlcHRoID0gdGhpcy5tYXhEZXB0aCB8fCB0aGlzLnJvb3QubWF4RGVwdGg7CgogICAgICBpZiAobGV2ZWwgPCBtYXhEZXB0aCkgewogICAgICAgIC8vIFN1YmRpdmlkZSBpZiB0aGVyZSBhcmUgbm8gY2hpbGRyZW4geWV0CiAgICAgICAgbGV0IHN1YmRpdmlkZWQgPSBmYWxzZTsKCiAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgIHRoaXMuc3ViZGl2aWRlKCk7CiAgICAgICAgICBzdWJkaXZpZGVkID0gdHJ1ZTsKICAgICAgICB9IC8vIGFkZCB0byB3aGljaGV2ZXIgbm9kZSB3aWxsIGFjY2VwdCBpdAoKCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDg7IGkrKykgewogICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLmluc2VydChhYWJiLCBlbGVtZW50RGF0YSwgbGV2ZWwgKyAxKSkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGlmIChzdWJkaXZpZGVkKSB7CiAgICAgICAgICAvLyBObyBjaGlsZHJlbiBhY2NlcHRlZCEgTWlnaHQgYXMgd2VsbCBqdXN0IHJlbW92ZSBlbSBzaW5jZSB0aGV5IGNvbnRhaW4gbm9uZQogICAgICAgICAgY2hpbGRyZW4ubGVuZ3RoID0gMDsKICAgICAgICB9CiAgICAgIH0gLy8gVG9vIGRlZXAsIG9yIGNoaWxkcmVuIGRpZG50IHdhbnQgaXQuIGFkZCBpdCBpbiBjdXJyZW50IG5vZGUKCgogICAgICBub2RlRGF0YS5wdXNoKGVsZW1lbnREYXRhKTsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZSA4IGVxdWFsbHkgc2l6ZWQgY2hpbGRyZW4gbm9kZXMgYW5kIHB1dCB0aGVtIGluIHRoZSBgY2hpbGRyZW5gIGFycmF5LgogICAgICovCgoKICAgIHN1YmRpdmlkZSgpIHsKICAgICAgY29uc3QgYWFiYiA9IHRoaXMuYWFiYjsKICAgICAgY29uc3QgbCA9IGFhYmIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdSA9IGFhYmIudXBwZXJCb3VuZDsKICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuOwogICAgICBjaGlsZHJlbi5wdXNoKG5ldyBPY3RyZWVOb2RlKHsKICAgICAgICBhYWJiOiBuZXcgQUFCQih7CiAgICAgICAgICBsb3dlckJvdW5kOiBuZXcgVmVjMygwLCAwLCAwKQogICAgICAgIH0pCiAgICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7CiAgICAgICAgYWFiYjogbmV3IEFBQkIoewogICAgICAgICAgbG93ZXJCb3VuZDogbmV3IFZlYzMoMSwgMCwgMCkKICAgICAgICB9KQogICAgICB9KSwgbmV3IE9jdHJlZU5vZGUoewogICAgICAgIGFhYmI6IG5ldyBBQUJCKHsKICAgICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsIDEsIDApCiAgICAgICAgfSkKICAgICAgfSksIG5ldyBPY3RyZWVOb2RlKHsKICAgICAgICBhYWJiOiBuZXcgQUFCQih7CiAgICAgICAgICBsb3dlckJvdW5kOiBuZXcgVmVjMygxLCAxLCAxKQogICAgICAgIH0pCiAgICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7CiAgICAgICAgYWFiYjogbmV3IEFBQkIoewogICAgICAgICAgbG93ZXJCb3VuZDogbmV3IFZlYzMoMCwgMSwgMSkKICAgICAgICB9KQogICAgICB9KSwgbmV3IE9jdHJlZU5vZGUoewogICAgICAgIGFhYmI6IG5ldyBBQUJCKHsKICAgICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsIDAsIDEpCiAgICAgICAgfSkKICAgICAgfSksIG5ldyBPY3RyZWVOb2RlKHsKICAgICAgICBhYWJiOiBuZXcgQUFCQih7CiAgICAgICAgICBsb3dlckJvdW5kOiBuZXcgVmVjMygxLCAwLCAxKQogICAgICAgIH0pCiAgICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7CiAgICAgICAgYWFiYjogbmV3IEFBQkIoewogICAgICAgICAgbG93ZXJCb3VuZDogbmV3IFZlYzMoMCwgMSwgMCkKICAgICAgICB9KQogICAgICB9KSk7CiAgICAgIHUudnN1YihsLCBoYWxmRGlhZ29uYWwpOwogICAgICBoYWxmRGlhZ29uYWwuc2NhbGUoMC41LCBoYWxmRGlhZ29uYWwpOwogICAgICBjb25zdCByb290ID0gdGhpcy5yb290IHx8IHRoaXM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gODsgaSsrKSB7CiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTsgLy8gU2V0IGN1cnJlbnQgbm9kZSBhcyByb290CgogICAgICAgIGNoaWxkLnJvb3QgPSByb290OyAvLyBDb21wdXRlIGJvdW5kcwoKICAgICAgICBjb25zdCBsb3dlckJvdW5kID0gY2hpbGQuYWFiYi5sb3dlckJvdW5kOwogICAgICAgIGxvd2VyQm91bmQueCAqPSBoYWxmRGlhZ29uYWwueDsKICAgICAgICBsb3dlckJvdW5kLnkgKj0gaGFsZkRpYWdvbmFsLnk7CiAgICAgICAgbG93ZXJCb3VuZC56ICo9IGhhbGZEaWFnb25hbC56OwogICAgICAgIGxvd2VyQm91bmQudmFkZChsLCBsb3dlckJvdW5kKTsgLy8gVXBwZXIgYm91bmQgaXMgYWx3YXlzIGxvd2VyIGJvdW5kICsgaGFsZkRpYWdvbmFsCgogICAgICAgIGxvd2VyQm91bmQudmFkZChoYWxmRGlhZ29uYWwsIGNoaWxkLmFhYmIudXBwZXJCb3VuZCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogR2V0IGFsbCBkYXRhLCBwb3RlbnRpYWxseSB3aXRoaW4gYW4gQUFCQgogICAgICogQHJldHVybiBUaGUgInJlc3VsdCIgb2JqZWN0CiAgICAgKi8KCgogICAgYWFiYlF1ZXJ5KGFhYmIsIHJlc3VsdCkgewogICAgICB0aGlzLmRhdGE7IC8vIGFib3J0IGlmIHRoZSByYW5nZSBkb2VzIG5vdCBpbnRlcnNlY3QgdGhpcyBub2RlCiAgICAgIC8vIGlmICghdGhpcy5hYWJiLm92ZXJsYXBzKGFhYmIpKXsKICAgICAgLy8gICAgIHJldHVybiByZXN1bHQ7CiAgICAgIC8vIH0KICAgICAgLy8gQWRkIG9iamVjdHMgYXQgdGhpcyBsZXZlbAogICAgICAvLyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQsIG5vZGVEYXRhKTsKICAgICAgLy8gQWRkIGNoaWxkIGRhdGEKICAgICAgLy8gQHRvZG8gdW53cmFwIHJlY3Vyc2lvbiBpbnRvIGEgcXVldWUgLyBsb29wLCB0aGF0J3MgZmFzdGVyIGluIEpTCgogICAgICB0aGlzLmNoaWxkcmVuOyAvLyBmb3IgKGxldCBpID0gMCwgTiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICE9PSBOOyBpKyspIHsKICAgICAgLy8gICAgIGNoaWxkcmVuW2ldLmFhYmJRdWVyeShhYWJiLCByZXN1bHQpOwogICAgICAvLyB9CgogICAgICBjb25zdCBxdWV1ZSA9IFt0aGlzXTsKCiAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHsKICAgICAgICBjb25zdCBub2RlID0gcXVldWUucG9wKCk7CgogICAgICAgIGlmIChub2RlLmFhYmIub3ZlcmxhcHMoYWFiYikpIHsKICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5kYXRhKTsKICAgICAgICB9CgogICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHF1ZXVlLCBub2RlLmNoaWxkcmVuKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGFsbCBkYXRhLCBwb3RlbnRpYWxseSBpbnRlcnNlY3RlZCBieSBhIHJheS4KICAgICAqIEByZXR1cm4gVGhlICJyZXN1bHQiIG9iamVjdAogICAgICovCgoKICAgIHJheVF1ZXJ5KHJheSwgdHJlZVRyYW5zZm9ybSwgcmVzdWx0KSB7CiAgICAgIC8vIFVzZSBhYWJiIHF1ZXJ5IGZvciBub3cuCgogICAgICAvKiogQHRvZG8gaW1wbGVtZW50IHJlYWwgcmF5IHF1ZXJ5IHdoaWNoIG5lZWRzIGxlc3MgbG9va3VwcyAqLwogICAgICByYXkuZ2V0QUFCQih0bXBBQUJCKTsKICAgICAgdG1wQUFCQi50b0xvY2FsRnJhbWUodHJlZVRyYW5zZm9ybSwgdG1wQUFCQik7CiAgICAgIHRoaXMuYWFiYlF1ZXJ5KHRtcEFBQkIsIHJlc3VsdCk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIHJlbW92ZUVtcHR5Tm9kZXMKICAgICAqLwoKCiAgICByZW1vdmVFbXB0eU5vZGVzKCkgewogICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucmVtb3ZlRW1wdHlOb2RlcygpOwoKICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW5baV0uY2hpbGRyZW4ubGVuZ3RoICYmICF0aGlzLmNoaWxkcmVuW2ldLmRhdGEubGVuZ3RoKSB7CiAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpLCAxKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgfQogIC8qKgogICAqIE9jdHJlZQogICAqLwoKCiAgY2xhc3MgT2N0cmVlIGV4dGVuZHMgT2N0cmVlTm9kZSB7CiAgICAvKioKICAgICAqIE1heGltdW0gc3ViZGl2aXNpb24gZGVwdGgKICAgICAqIEBkZWZhdWx0IDgKICAgICAqLwoKICAgIC8qKgogICAgICogQHBhcmFtIGFhYmIgVGhlIHRvdGFsIEFBQkIgb2YgdGhlIHRyZWUKICAgICAqLwogICAgY29uc3RydWN0b3IoYWFiYiwgb3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBzdXBlcih7CiAgICAgICAgcm9vdDogbnVsbCwKICAgICAgICBhYWJiCiAgICAgIH0pOwogICAgICB0aGlzLm1heERlcHRoID0gdHlwZW9mIG9wdGlvbnMubWF4RGVwdGggIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhEZXB0aCA6IDg7CiAgICB9CgogIH0KICBjb25zdCBoYWxmRGlhZ29uYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IHRtcEFBQkIgPSBuZXcgQUFCQigpOwoKICAvKioKICAgKiBUcmltZXNoLgogICAqIEBleGFtcGxlCiAgICogICAgIC8vIEhvdyB0byBtYWtlIGEgbWVzaCB3aXRoIGEgc2luZ2xlIHRyaWFuZ2xlCiAgICogICAgIGNvbnN0IHZlcnRpY2VzID0gWwogICAqICAgICAgICAgMCwgMCwgMCwgLy8gdmVydGV4IDAKICAgKiAgICAgICAgIDEsIDAsIDAsIC8vIHZlcnRleCAxCiAgICogICAgICAgICAwLCAxLCAwICAvLyB2ZXJ0ZXggMgogICAqICAgICBdCiAgICogICAgIGNvbnN0IGluZGljZXMgPSBbCiAgICogICAgICAgICAwLCAxLCAyICAvLyB0cmlhbmdsZSAwCiAgICogICAgIF0KICAgKiAgICAgY29uc3QgdHJpbWVzaFNoYXBlID0gbmV3IENBTk5PTi5UcmltZXNoKHZlcnRpY2VzLCBpbmRpY2VzKQogICAqLwogIGNsYXNzIFRyaW1lc2ggZXh0ZW5kcyBTaGFwZSB7CiAgICAvKioKICAgICAqIHZlcnRpY2VzCiAgICAgKi8KCiAgICAvKioKICAgICAqIEFycmF5IG9mIGludGVnZXJzLCBpbmRpY2F0aW5nIHdoaWNoIHZlcnRpY2VzIGVhY2ggdHJpYW5nbGUgY29uc2lzdHMgb2YuIFRoZSBsZW5ndGggb2YgdGhpcyBhcnJheSBpcyB0aHVzIDMgdGltZXMgdGhlIG51bWJlciBvZiB0cmlhbmdsZXMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBub3JtYWxzIGRhdGEuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBsb2NhbCBBQUJCIG9mIHRoZSBtZXNoLgogICAgICovCgogICAgLyoqCiAgICAgKiBSZWZlcmVuY2VzIHRvIHZlcnRleCBwYWlycywgbWFraW5nIHVwIGFsbCB1bmlxdWUgZWRnZXMgaW4gdGhlIHRyaW1lc2guCiAgICAgKi8KCiAgICAvKioKICAgICAqIExvY2FsIHNjYWxpbmcgb2YgdGhlIG1lc2guIFVzZSAuc2V0U2NhbGUoKSB0byBzZXQgaXQuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBpbmRleGVkIHRyaWFuZ2xlcy4gVXNlIC51cGRhdGVUcmVlKCkgdG8gdXBkYXRlIGl0LgogICAgICovCiAgICBjb25zdHJ1Y3Rvcih2ZXJ0aWNlcywgaW5kaWNlcykgewogICAgICBzdXBlcih7CiAgICAgICAgdHlwZTogU2hhcGUudHlwZXMuVFJJTUVTSAogICAgICB9KTsKICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMpOwogICAgICB0aGlzLmluZGljZXMgPSBuZXcgSW50MTZBcnJheShpbmRpY2VzKTsKICAgICAgdGhpcy5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShpbmRpY2VzLmxlbmd0aCk7CiAgICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7CiAgICAgIHRoaXMuZWRnZXMgPSBudWxsOwogICAgICB0aGlzLnNjYWxlID0gbmV3IFZlYzMoMSwgMSwgMSk7CiAgICAgIHRoaXMudHJlZSA9IG5ldyBPY3RyZWUoKTsKICAgICAgdGhpcy51cGRhdGVFZGdlcygpOwogICAgICB0aGlzLnVwZGF0ZU5vcm1hbHMoKTsKICAgICAgdGhpcy51cGRhdGVBQUJCKCk7CiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTsKICAgICAgdGhpcy51cGRhdGVUcmVlKCk7CiAgICB9CiAgICAvKioKICAgICAqIHVwZGF0ZVRyZWUKICAgICAqLwoKCiAgICB1cGRhdGVUcmVlKCkgewogICAgICBjb25zdCB0cmVlID0gdGhpcy50cmVlOwogICAgICB0cmVlLnJlc2V0KCk7CiAgICAgIHRyZWUuYWFiYi5jb3B5KHRoaXMuYWFiYik7CiAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTsgLy8gVGhlIGxvY2FsIG1lc2ggQUFCQiBpcyBzY2FsZWQsIGJ1dCB0aGUgb2N0cmVlIEFBQkIgc2hvdWxkIGJlIHVuc2NhbGVkCgogICAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC54ICo9IDEgLyBzY2FsZS54OwogICAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55OwogICAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC56ICo9IDEgLyBzY2FsZS56OwogICAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC54ICo9IDEgLyBzY2FsZS54OwogICAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55OwogICAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC56ICo9IDEgLyBzY2FsZS56OyAvLyBJbnNlcnQgYWxsIHRyaWFuZ2xlcwoKICAgICAgY29uc3QgdHJpYW5nbGVBQUJCID0gbmV3IEFBQkIoKTsKICAgICAgY29uc3QgYSA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IGIgPSBuZXcgVmVjMygpOwogICAgICBjb25zdCBjID0gbmV3IFZlYzMoKTsKICAgICAgY29uc3QgcG9pbnRzID0gW2EsIGIsIGNdOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAgICAgLy90aGlzLmdldFRyaWFuZ2xlVmVydGljZXMoaSwgYSwgYiwgYyk7CiAgICAgICAgLy8gR2V0IHVuc2NhbGVkIHRyaWFuZ2xlIHZlcnRzCiAgICAgICAgY29uc3QgaTMgPSBpICogMzsKCiAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzXSwgYSk7CgogICAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDFdLCBiKTsKCiAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMl0sIGMpOwoKICAgICAgICB0cmlhbmdsZUFBQkIuc2V0RnJvbVBvaW50cyhwb2ludHMpOwogICAgICAgIHRyZWUuaW5zZXJ0KHRyaWFuZ2xlQUFCQiwgaSk7CiAgICAgIH0KCiAgICAgIHRyZWUucmVtb3ZlRW1wdHlOb2RlcygpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgdHJpYW5nbGVzIGluIGEgbG9jYWwgQUFCQiBmcm9tIHRoZSB0cmltZXNoLgogICAgICogQHBhcmFtIHJlc3VsdCBBbiBhcnJheSBvZiBpbnRlZ2VycywgcmVmZXJlbmNpbmcgdGhlIHF1ZXJpZWQgdHJpYW5nbGVzLgogICAgICovCgoKICAgIGdldFRyaWFuZ2xlc0luQUFCQihhYWJiLCByZXN1bHQpIHsKICAgICAgdW5zY2FsZWRBQUJCLmNvcHkoYWFiYik7IC8vIFNjYWxlIGl0IHRvIGxvY2FsCgogICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7CiAgICAgIGNvbnN0IGlzeCA9IHNjYWxlLng7CiAgICAgIGNvbnN0IGlzeSA9IHNjYWxlLnk7CiAgICAgIGNvbnN0IGlzeiA9IHNjYWxlLno7CiAgICAgIGNvbnN0IGwgPSB1bnNjYWxlZEFBQkIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdSA9IHVuc2NhbGVkQUFCQi51cHBlckJvdW5kOwogICAgICBsLnggLz0gaXN4OwogICAgICBsLnkgLz0gaXN5OwogICAgICBsLnogLz0gaXN6OwogICAgICB1LnggLz0gaXN4OwogICAgICB1LnkgLz0gaXN5OwogICAgICB1LnogLz0gaXN6OwogICAgICByZXR1cm4gdGhpcy50cmVlLmFhYmJRdWVyeSh1bnNjYWxlZEFBQkIsIHJlc3VsdCk7CiAgICB9CiAgICAvKioKICAgICAqIHNldFNjYWxlCiAgICAgKi8KCgogICAgc2V0U2NhbGUoc2NhbGUpIHsKICAgICAgY29uc3Qgd2FzVW5pZm9ybSA9IHRoaXMuc2NhbGUueCA9PT0gdGhpcy5zY2FsZS55ICYmIHRoaXMuc2NhbGUueSA9PT0gdGhpcy5zY2FsZS56OwogICAgICBjb25zdCBpc1VuaWZvcm0gPSBzY2FsZS54ID09PSBzY2FsZS55ICYmIHNjYWxlLnkgPT09IHNjYWxlLno7CgogICAgICBpZiAoISh3YXNVbmlmb3JtICYmIGlzVW5pZm9ybSkpIHsKICAgICAgICAvLyBOb24tdW5pZm9ybSBzY2FsaW5nLiBOZWVkIHRvIHVwZGF0ZSBub3JtYWxzLgogICAgICAgIHRoaXMudXBkYXRlTm9ybWFscygpOwogICAgICB9CgogICAgICB0aGlzLnNjYWxlLmNvcHkoc2NhbGUpOwogICAgICB0aGlzLnVwZGF0ZUFBQkIoKTsKICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlIHRoZSBub3JtYWxzIG9mIHRoZSBmYWNlcy4gV2lsbCBzYXZlIGluIHRoZSBgLm5vcm1hbHNgIGFycmF5LgogICAgICovCgoKICAgIHVwZGF0ZU5vcm1hbHMoKSB7CiAgICAgIGNvbnN0IG4gPSBjb21wdXRlTm9ybWFsc19uOyAvLyBHZW5lcmF0ZSBub3JtYWxzCgogICAgICBjb25zdCBub3JtYWxzID0gdGhpcy5ub3JtYWxzOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAgICAgY29uc3QgaTMgPSBpICogMzsKICAgICAgICBjb25zdCBhID0gdGhpcy5pbmRpY2VzW2kzXTsKICAgICAgICBjb25zdCBiID0gdGhpcy5pbmRpY2VzW2kzICsgMV07CiAgICAgICAgY29uc3QgYyA9IHRoaXMuaW5kaWNlc1tpMyArIDJdOwogICAgICAgIHRoaXMuZ2V0VmVydGV4KGEsIHZhKTsKICAgICAgICB0aGlzLmdldFZlcnRleChiLCB2Yik7CiAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoYywgdmMpOwogICAgICAgIFRyaW1lc2guY29tcHV0ZU5vcm1hbCh2YiwgdmEsIHZjLCBuKTsKICAgICAgICBub3JtYWxzW2kzXSA9IG4ueDsKICAgICAgICBub3JtYWxzW2kzICsgMV0gPSBuLnk7CiAgICAgICAgbm9ybWFsc1tpMyArIDJdID0gbi56OwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFVwZGF0ZSB0aGUgYC5lZGdlc2AgcHJvcGVydHkKICAgICAqLwoKCiAgICB1cGRhdGVFZGdlcygpIHsKICAgICAgY29uc3QgZWRnZXMgPSB7fTsKCiAgICAgIGNvbnN0IGFkZCA9IChhLCBiKSA9PiB7CiAgICAgICAgY29uc3Qga2V5ID0gYSA8IGIgPyBgJHthfV8ke2J9YCA6IGAke2J9XyR7YX1gOwogICAgICAgIGVkZ2VzW2tleV0gPSB0cnVlOwogICAgICB9OwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAgICAgY29uc3QgaTMgPSBpICogMzsKICAgICAgICBjb25zdCBhID0gdGhpcy5pbmRpY2VzW2kzXTsKICAgICAgICBjb25zdCBiID0gdGhpcy5pbmRpY2VzW2kzICsgMV07CiAgICAgICAgY29uc3QgYyA9IHRoaXMuaW5kaWNlc1tpMyArIDJdOwogICAgICAgIGFkZChhLCBiKTsKICAgICAgICBhZGQoYiwgYyk7CiAgICAgICAgYWRkKGMsIGEpOwogICAgICB9CgogICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZWRnZXMpOwogICAgICB0aGlzLmVkZ2VzID0gbmV3IEludDE2QXJyYXkoa2V5cy5sZW5ndGggKiAyKTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGluZGljZXMgPSBrZXlzW2ldLnNwbGl0KCdfJyk7CiAgICAgICAgdGhpcy5lZGdlc1syICogaV0gPSBwYXJzZUludChpbmRpY2VzWzBdLCAxMCk7CiAgICAgICAgdGhpcy5lZGdlc1syICogaSArIDFdID0gcGFyc2VJbnQoaW5kaWNlc1sxXSwgMTApOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhbiBlZGdlIHZlcnRleAogICAgICogQHBhcmFtIGZpcnN0T3JTZWNvbmQgMCBvciAxLCBkZXBlbmRpbmcgb24gd2hpY2ggb25lIG9mIHRoZSB2ZXJ0aWNlcyB5b3UgbmVlZC4KICAgICAqIEBwYXJhbSB2ZXJ0ZXhTdG9yZSBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0CiAgICAgKi8KCgogICAgZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIGZpcnN0T3JTZWNvbmQsIHZlcnRleFN0b3JlKSB7CiAgICAgIGNvbnN0IHZlcnRleEluZGV4ID0gdGhpcy5lZGdlc1tlZGdlSW5kZXggKiAyICsgKGZpcnN0T3JTZWNvbmQgPyAxIDogMCldOwogICAgICB0aGlzLmdldFZlcnRleCh2ZXJ0ZXhJbmRleCwgdmVydGV4U3RvcmUpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgYSB2ZWN0b3IgYWxvbmcgYW4gZWRnZS4KICAgICAqLwoKCiAgICBnZXRFZGdlVmVjdG9yKGVkZ2VJbmRleCwgdmVjdG9yU3RvcmUpIHsKICAgICAgY29uc3QgdmEgPSBnZXRFZGdlVmVjdG9yX3ZhOwogICAgICBjb25zdCB2YiA9IGdldEVkZ2VWZWN0b3JfdmI7CiAgICAgIHRoaXMuZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIDAsIHZhKTsKICAgICAgdGhpcy5nZXRFZGdlVmVydGV4KGVkZ2VJbmRleCwgMSwgdmIpOwogICAgICB2Yi52c3ViKHZhLCB2ZWN0b3JTdG9yZSk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBmYWNlIG5vcm1hbCBnaXZlbiAzIHZlcnRpY2VzCiAgICAgKi8KCgogICAgc3RhdGljIGNvbXB1dGVOb3JtYWwodmEsIHZiLCB2YywgdGFyZ2V0KSB7CiAgICAgIHZiLnZzdWIodmEsIGFiKTsKICAgICAgdmMudnN1Yih2YiwgY2IpOwogICAgICBjYi5jcm9zcyhhYiwgdGFyZ2V0KTsKCiAgICAgIGlmICghdGFyZ2V0LmlzWmVybygpKSB7CiAgICAgICAgdGFyZ2V0Lm5vcm1hbGl6ZSgpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEdldCB2ZXJ0ZXggaS4KICAgICAqIEByZXR1cm4gVGhlICJvdXQiIHZlY3RvciBvYmplY3QKICAgICAqLwoKCiAgICBnZXRWZXJ0ZXgoaSwgb3V0KSB7CiAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTsKCiAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KGksIG91dCk7CgogICAgICBvdXQueCAqPSBzY2FsZS54OwogICAgICBvdXQueSAqPSBzY2FsZS55OwogICAgICBvdXQueiAqPSBzY2FsZS56OwogICAgICByZXR1cm4gb3V0OwogICAgfQogICAgLyoqCiAgICAgKiBHZXQgcmF3IHZlcnRleCBpCiAgICAgKiBAcmV0dXJuIFRoZSAib3V0IiB2ZWN0b3Igb2JqZWN0CiAgICAgKi8KCgogICAgX2dldFVuc2NhbGVkVmVydGV4KGksIG91dCkgewogICAgICBjb25zdCBpMyA9IGkgKiAzOwogICAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7CiAgICAgIHJldHVybiBvdXQuc2V0KHZlcnRpY2VzW2kzXSwgdmVydGljZXNbaTMgKyAxXSwgdmVydGljZXNbaTMgKyAyXSk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhIHZlcnRleCBmcm9tIHRoZSB0cmltZXNoLHRyYW5zZm9ybWVkIGJ5IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgcXVhdGVybmlvbi4KICAgICAqIEByZXR1cm4gVGhlICJvdXQiIHZlY3RvciBvYmplY3QKICAgICAqLwoKCiAgICBnZXRXb3JsZFZlcnRleChpLCBwb3MsIHF1YXQsIG91dCkgewogICAgICB0aGlzLmdldFZlcnRleChpLCBvdXQpOwogICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zLCBxdWF0LCBvdXQsIG91dCk7CiAgICAgIHJldHVybiBvdXQ7CiAgICB9CiAgICAvKioKICAgICAqIEdldCB0aGUgdGhyZWUgdmVydGljZXMgZm9yIHRyaWFuZ2xlIGkuCiAgICAgKi8KCgogICAgZ2V0VHJpYW5nbGVWZXJ0aWNlcyhpLCBhLCBiLCBjKSB7CiAgICAgIGNvbnN0IGkzID0gaSAqIDM7CiAgICAgIHRoaXMuZ2V0VmVydGV4KHRoaXMuaW5kaWNlc1tpM10sIGEpOwogICAgICB0aGlzLmdldFZlcnRleCh0aGlzLmluZGljZXNbaTMgKyAxXSwgYik7CiAgICAgIHRoaXMuZ2V0VmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDJdLCBjKTsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZSB0aGUgbm9ybWFsIG9mIHRyaWFuZ2xlIGkuCiAgICAgKiBAcmV0dXJuIFRoZSAidGFyZ2V0IiB2ZWN0b3Igb2JqZWN0CiAgICAgKi8KCgogICAgZ2V0Tm9ybWFsKGksIHRhcmdldCkgewogICAgICBjb25zdCBpMyA9IGkgKiAzOwogICAgICByZXR1cm4gdGFyZ2V0LnNldCh0aGlzLm5vcm1hbHNbaTNdLCB0aGlzLm5vcm1hbHNbaTMgKyAxXSwgdGhpcy5ub3JtYWxzW2kzICsgMl0pOwogICAgfQogICAgLyoqCiAgICAgKiBAcmV0dXJuIFRoZSAidGFyZ2V0IiB2ZWN0b3Igb2JqZWN0CiAgICAgKi8KCgogICAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkgewogICAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhCiAgICAgIC8vIEV4YWN0IGluZXJ0aWEgY2FsY3VsYXRpb24gaXMgb3ZlcmtpbGwsIGJ1dCBzZWUgaHR0cDovL2dlb21ldHJpY3Rvb2xzLmNvbS9Eb2N1bWVudGF0aW9uL1BvbHloZWRyYWxNYXNzUHJvcGVydGllcy5wZGYgZm9yIHRoZSBjb3JyZWN0IHdheSB0byBkbyBpdAogICAgICB0aGlzLmNvbXB1dGVMb2NhbEFBQkIoY2xpX2FhYmIpOwogICAgICBjb25zdCB4ID0gY2xpX2FhYmIudXBwZXJCb3VuZC54IC0gY2xpX2FhYmIubG93ZXJCb3VuZC54OwogICAgICBjb25zdCB5ID0gY2xpX2FhYmIudXBwZXJCb3VuZC55IC0gY2xpX2FhYmIubG93ZXJCb3VuZC55OwogICAgICBjb25zdCB6ID0gY2xpX2FhYmIudXBwZXJCb3VuZC56IC0gY2xpX2FhYmIubG93ZXJCb3VuZC56OwogICAgICByZXR1cm4gdGFyZ2V0LnNldCgxLjAgLyAxMi4wICogbWFzcyAqICgyICogeSAqIDIgKiB5ICsgMiAqIHogKiAyICogeiksIDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiB4ICogMiAqIHggKyAyICogeiAqIDIgKiB6KSwgMS4wIC8gMTIuMCAqIG1hc3MgKiAoMiAqIHkgKiAyICogeSArIDIgKiB4ICogMiAqIHgpKTsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZSB0aGUgbG9jYWwgQUFCQiBmb3IgdGhlIHRyaW1lc2gKICAgICAqLwoKCiAgICBjb21wdXRlTG9jYWxBQUJCKGFhYmIpIHsKICAgICAgY29uc3QgbCA9IGFhYmIubG93ZXJCb3VuZDsKICAgICAgY29uc3QgdSA9IGFhYmIudXBwZXJCb3VuZDsKICAgICAgY29uc3QgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoOwogICAgICB0aGlzLnZlcnRpY2VzOwogICAgICBjb25zdCB2ID0gY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQ7CiAgICAgIHRoaXMuZ2V0VmVydGV4KDAsIHYpOwogICAgICBsLmNvcHkodik7CiAgICAgIHUuY29weSh2KTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBuOyBpKyspIHsKICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTsKCiAgICAgICAgaWYgKHYueCA8IGwueCkgewogICAgICAgICAgbC54ID0gdi54OwogICAgICAgIH0gZWxzZSBpZiAodi54ID4gdS54KSB7CiAgICAgICAgICB1LnggPSB2Lng7CiAgICAgICAgfQoKICAgICAgICBpZiAodi55IDwgbC55KSB7CiAgICAgICAgICBsLnkgPSB2Lnk7CiAgICAgICAgfSBlbHNlIGlmICh2LnkgPiB1LnkpIHsKICAgICAgICAgIHUueSA9IHYueTsKICAgICAgICB9CgogICAgICAgIGlmICh2LnogPCBsLnopIHsKICAgICAgICAgIGwueiA9IHYuejsKICAgICAgICB9IGVsc2UgaWYgKHYueiA+IHUueikgewogICAgICAgICAgdS56ID0gdi56OwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBVcGRhdGUgdGhlIGAuYWFiYmAgcHJvcGVydHkKICAgICAqLwoKCiAgICB1cGRhdGVBQUJCKCkgewogICAgICB0aGlzLmNvbXB1dGVMb2NhbEFBQkIodGhpcy5hYWJiKTsKICAgIH0KICAgIC8qKgogICAgICogV2lsbCB1cGRhdGUgdGhlIGAuYm91bmRpbmdTcGhlcmVSYWRpdXNgIHByb3BlcnR5CiAgICAgKi8KCgogICAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7CiAgICAgIC8vIEFzc3VtZSBwb2ludHMgYXJlIGRpc3RyaWJ1dGVkIHdpdGggbG9jYWwgKDAsMCwwKSBhcyBjZW50ZXIKICAgICAgbGV0IG1heDIgPSAwOwogICAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7CiAgICAgIGNvbnN0IHYgPSBuZXcgVmVjMygpOwoKICAgICAgZm9yIChsZXQgaSA9IDAsIE4gPSB2ZXJ0aWNlcy5sZW5ndGggLyAzOyBpICE9PSBOOyBpKyspIHsKICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTsKICAgICAgICBjb25zdCBub3JtMiA9IHYubGVuZ3RoU3F1YXJlZCgpOwoKICAgICAgICBpZiAobm9ybTIgPiBtYXgyKSB7CiAgICAgICAgICBtYXgyID0gbm9ybTI7CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gTWF0aC5zcXJ0KG1heDIpOwogICAgfQogICAgLyoqCiAgICAgKiBjYWxjdWxhdGVXb3JsZEFBQkIKICAgICAqLwoKCiAgICBjYWxjdWxhdGVXb3JsZEFBQkIocG9zLCBxdWF0LCBtaW4sIG1heCkgewogICAgICAvKgogICAgICAgICAgY29uc3QgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC8gMywKICAgICAgICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXM7CiAgICAgICAgICBjb25zdCBtaW54LG1pbnksbWlueixtYXh4LG1heHksbWF4ejsKICAgICAgICAgICBjb25zdCB2ID0gdGVtcFdvcmxkVmVydGV4OwogICAgICAgICAgZm9yKGxldCBpPTA7IGk8bjsgaSsrKXsKICAgICAgICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTsKICAgICAgICAgICAgICBxdWF0LnZtdWx0KHYsIHYpOwogICAgICAgICAgICAgIHBvcy52YWRkKHYsIHYpOwogICAgICAgICAgICAgIGlmICh2LnggPCBtaW54IHx8IG1pbng9PT11bmRlZmluZWQpewogICAgICAgICAgICAgICAgICBtaW54ID0gdi54OwogICAgICAgICAgICAgIH0gZWxzZSBpZih2LnggPiBtYXh4IHx8IG1heHg9PT11bmRlZmluZWQpewogICAgICAgICAgICAgICAgICBtYXh4ID0gdi54OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgaWYgKHYueSA8IG1pbnkgfHwgbWlueT09PXVuZGVmaW5lZCl7CiAgICAgICAgICAgICAgICAgIG1pbnkgPSB2Lnk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmKHYueSA+IG1heHkgfHwgbWF4eT09PXVuZGVmaW5lZCl7CiAgICAgICAgICAgICAgICAgIG1heHkgPSB2Lnk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICBpZiAodi56IDwgbWlueiB8fCBtaW56PT09dW5kZWZpbmVkKXsKICAgICAgICAgICAgICAgICAgbWlueiA9IHYuejsKICAgICAgICAgICAgICB9IGVsc2UgaWYodi56ID4gbWF4eiB8fCBtYXh6PT09dW5kZWZpbmVkKXsKICAgICAgICAgICAgICAgICAgbWF4eiA9IHYuejsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBtaW4uc2V0KG1pbngsbWlueSxtaW56KTsKICAgICAgICAgIG1heC5zZXQobWF4eCxtYXh5LG1heHopOwogICAgICAgICAgKi8KICAgICAgLy8gRmFzdGVyIGFwcHJveGltYXRpb24gdXNpbmcgbG9jYWwgQUFCQgogICAgICBjb25zdCBmcmFtZSA9IGNhbGN1bGF0ZVdvcmxkQUFCQl9mcmFtZTsKICAgICAgY29uc3QgcmVzdWx0ID0gY2FsY3VsYXRlV29ybGRBQUJCX2FhYmI7CiAgICAgIGZyYW1lLnBvc2l0aW9uID0gcG9zOwogICAgICBmcmFtZS5xdWF0ZXJuaW9uID0gcXVhdDsKICAgICAgdGhpcy5hYWJiLnRvV29ybGRGcmFtZShmcmFtZSwgcmVzdWx0KTsKICAgICAgbWluLmNvcHkocmVzdWx0Lmxvd2VyQm91bmQpOwogICAgICBtYXguY29weShyZXN1bHQudXBwZXJCb3VuZCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldCBhcHByb3hpbWF0ZSB2b2x1bWUKICAgICAqLwoKCiAgICB2b2x1bWUoKSB7CiAgICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyAvIDMuMDsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlIGEgVHJpbWVzaCBpbnN0YW5jZSwgc2hhcGVkIGFzIGEgdG9ydXMuCiAgICAgKi8KCgogICAgc3RhdGljIGNyZWF0ZVRvcnVzKHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjKSB7CiAgICAgIGlmIChyYWRpdXMgPT09IHZvaWQgMCkgewogICAgICAgIHJhZGl1cyA9IDE7CiAgICAgIH0KCiAgICAgIGlmICh0dWJlID09PSB2b2lkIDApIHsKICAgICAgICB0dWJlID0gMC41OwogICAgICB9CgogICAgICBpZiAocmFkaWFsU2VnbWVudHMgPT09IHZvaWQgMCkgewogICAgICAgIHJhZGlhbFNlZ21lbnRzID0gODsKICAgICAgfQoKICAgICAgaWYgKHR1YnVsYXJTZWdtZW50cyA9PT0gdm9pZCAwKSB7CiAgICAgICAgdHVidWxhclNlZ21lbnRzID0gNjsKICAgICAgfQoKICAgICAgaWYgKGFyYyA9PT0gdm9pZCAwKSB7CiAgICAgICAgYXJjID0gTWF0aC5QSSAqIDI7CiAgICAgIH0KCiAgICAgIGNvbnN0IHZlcnRpY2VzID0gW107CiAgICAgIGNvbnN0IGluZGljZXMgPSBbXTsKCiAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqKyspIHsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkrKykgewogICAgICAgICAgY29uc3QgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7CiAgICAgICAgICBjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7CiAgICAgICAgICBjb25zdCB4ID0gKHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyh2KSkgKiBNYXRoLmNvcyh1KTsKICAgICAgICAgIGNvbnN0IHkgPSAocmFkaXVzICsgdHViZSAqIE1hdGguY29zKHYpKSAqIE1hdGguc2luKHUpOwogICAgICAgICAgY29uc3QgeiA9IHR1YmUgKiBNYXRoLnNpbih2KTsKICAgICAgICAgIHZlcnRpY2VzLnB1c2goeCwgeSwgeik7CiAgICAgICAgfQogICAgICB9CgogICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaisrKSB7CiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpKyspIHsKICAgICAgICAgIGNvbnN0IGEgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiBqICsgaSAtIDE7CiAgICAgICAgICBjb25zdCBiID0gKHR1YnVsYXJTZWdtZW50cyArIDEpICogKGogLSAxKSArIGkgLSAxOwogICAgICAgICAgY29uc3QgYyA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIChqIC0gMSkgKyBpOwogICAgICAgICAgY29uc3QgZCA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIGogKyBpOwogICAgICAgICAgaW5kaWNlcy5wdXNoKGEsIGIsIGQpOwogICAgICAgICAgaW5kaWNlcy5wdXNoKGIsIGMsIGQpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBUcmltZXNoKHZlcnRpY2VzLCBpbmRpY2VzKTsKICAgIH0KCiAgfQogIGNvbnN0IGNvbXB1dGVOb3JtYWxzX24gPSBuZXcgVmVjMygpOwogIGNvbnN0IHVuc2NhbGVkQUFCQiA9IG5ldyBBQUJCKCk7CiAgY29uc3QgZ2V0RWRnZVZlY3Rvcl92YSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgZ2V0RWRnZVZlY3Rvcl92YiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgY2IgPSBuZXcgVmVjMygpOwogIGNvbnN0IGFiID0gbmV3IFZlYzMoKTsKICBjb25zdCB2YSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdmIgPSBuZXcgVmVjMygpOwogIGNvbnN0IHZjID0gbmV3IFZlYzMoKTsKICBjb25zdCBjbGlfYWFiYiA9IG5ldyBBQUJCKCk7CiAgY29uc3QgY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNhbGN1bGF0ZVdvcmxkQUFCQl9mcmFtZSA9IG5ldyBUcmFuc2Zvcm0oKTsKICBjb25zdCBjYWxjdWxhdGVXb3JsZEFBQkJfYWFiYiA9IG5ldyBBQUJCKCk7CgogIC8qKgogICAqIENvbnN0cmFpbnQgZXF1YXRpb24gc29sdmVyIGJhc2UgY2xhc3MuCiAgICovCiAgY2xhc3MgU29sdmVyIHsKICAgIC8qKgogICAgICogQWxsIGVxdWF0aW9ucyB0byBiZSBzb2x2ZWQKICAgICAqLwoKICAgIC8qKgogICAgICogQHRvZG8gcmVtb3ZlIHVzZWxlc3MgY29uc3RydWN0b3IKICAgICAqLwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHRoaXMuZXF1YXRpb25zID0gW107CiAgICB9CiAgICAvKioKICAgICAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzIQogICAgICogQHRvZG8gdXNlIGFic3RyYWN0CiAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBpdGVyYXRpb25zIHBlcmZvcm1lZAogICAgICovCgoKICAgIHNvbHZlKGR0LCB3b3JsZCkgewogICAgICByZXR1cm4gKC8vIFNob3VsZCByZXR1cm4gdGhlIG51bWJlciBvZiBpdGVyYXRpb25zIGRvbmUhCiAgICAgICAgMAogICAgICApOwogICAgfQogICAgLyoqCiAgICAgKiBBZGQgYW4gZXF1YXRpb24KICAgICAqLwoKCiAgICBhZGRFcXVhdGlvbihlcSkgewogICAgICBpZiAoZXEuZW5hYmxlZCAmJiAhZXEuYmkuaXNUcmlnZ2VyICYmICFlcS5iai5pc1RyaWdnZXIpIHsKICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmUgYW4gZXF1YXRpb24KICAgICAqLwoKCiAgICByZW1vdmVFcXVhdGlvbihlcSkgewogICAgICBjb25zdCBlcXMgPSB0aGlzLmVxdWF0aW9uczsKICAgICAgY29uc3QgaSA9IGVxcy5pbmRleE9mKGVxKTsKCiAgICAgIGlmIChpICE9PSAtMSkgewogICAgICAgIGVxcy5zcGxpY2UoaSwgMSk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQWRkIGFsbCBlcXVhdGlvbnMKICAgICAqLwoKCiAgICByZW1vdmVBbGxFcXVhdGlvbnMoKSB7CiAgICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IDA7CiAgICB9CgogIH0KCiAgLyoqCiAgICogQ29uc3RyYWludCBlcXVhdGlvbiBHYXVzcy1TZWlkZWwgc29sdmVyLgogICAqIEB0b2RvIFRoZSBzcG9vayBwYXJhbWV0ZXJzIHNob3VsZCBiZSBzcGVjaWZpZWQgZm9yIGVhY2ggY29uc3RyYWludCwgbm90IGdsb2JhbGx5LgogICAqIEBzZWUgaHR0cHM6Ly93d3c4LmNzLnVtdS5zZS9rdXJzZXIvNURWMDU4L1ZUMDkvbGVjdHVyZXMvc3Bvb2tub3Rlcy5wZGYKICAgKi8KICBjbGFzcyBHU1NvbHZlciBleHRlbmRzIFNvbHZlciB7CiAgICAvKioKICAgICAqIFRoZSBudW1iZXIgb2Ygc29sdmVyIGl0ZXJhdGlvbnMgZGV0ZXJtaW5lcyBxdWFsaXR5IG9mIHRoZSBjb25zdHJhaW50cyBpbiB0aGUgd29ybGQuCiAgICAgKiBUaGUgbW9yZSBpdGVyYXRpb25zLCB0aGUgbW9yZSBjb3JyZWN0IHNpbXVsYXRpb24uIE1vcmUgaXRlcmF0aW9ucyBuZWVkIG1vcmUgY29tcHV0YXRpb25zIHRob3VnaC4gSWYgeW91IGhhdmUgYSBsYXJnZSBncmF2aXR5IGZvcmNlIGluIHlvdXIgd29ybGQsIHlvdSB3aWxsIG5lZWQgbW9yZSBpdGVyYXRpb25zLgogICAgICovCgogICAgLyoqCiAgICAgKiBXaGVuIHRvbGVyYW5jZSBpcyByZWFjaGVkLCB0aGUgc3lzdGVtIGlzIGFzc3VtZWQgdG8gYmUgY29udmVyZ2VkLgogICAgICovCgogICAgLyoqCiAgICAgKiBAdG9kbyByZW1vdmUgdXNlbGVzcyBjb25zdHJ1Y3RvcgogICAgICovCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgc3VwZXIoKTsKICAgICAgdGhpcy5pdGVyYXRpb25zID0gMTA7CiAgICAgIHRoaXMudG9sZXJhbmNlID0gMWUtNzsKICAgIH0KICAgIC8qKgogICAgICogU29sdmUKICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgcGVyZm9ybWVkCiAgICAgKi8KCgogICAgc29sdmUoZHQsIHdvcmxkKSB7CiAgICAgIGxldCBpdGVyID0gMDsKICAgICAgY29uc3QgbWF4SXRlciA9IHRoaXMuaXRlcmF0aW9uczsKICAgICAgY29uc3QgdG9sU3F1YXJlZCA9IHRoaXMudG9sZXJhbmNlICogdGhpcy50b2xlcmFuY2U7CiAgICAgIGNvbnN0IGVxdWF0aW9ucyA9IHRoaXMuZXF1YXRpb25zOwogICAgICBjb25zdCBOZXEgPSBlcXVhdGlvbnMubGVuZ3RoOwogICAgICBjb25zdCBib2RpZXMgPSB3b3JsZC5ib2RpZXM7CiAgICAgIGNvbnN0IE5ib2RpZXMgPSBib2RpZXMubGVuZ3RoOwogICAgICBjb25zdCBoID0gZHQ7CiAgICAgIGxldCBCOwogICAgICBsZXQgaW52QzsKICAgICAgbGV0IGRlbHRhbGFtYmRhOwogICAgICBsZXQgZGVsdGFsYW1iZGFUb3Q7CiAgICAgIGxldCBHV2xhbWJkYTsKICAgICAgbGV0IGxhbWJkYWo7IC8vIFVwZGF0ZSBzb2x2ZSBtYXNzCgogICAgICBpZiAoTmVxICE9PSAwKSB7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE5ib2RpZXM7IGkrKykgewogICAgICAgICAgYm9kaWVzW2ldLnVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMoKTsKICAgICAgICB9CiAgICAgIH0gLy8gVGhpbmdzIHRoYXQgZG8gbm90IGNoYW5nZSBkdXJpbmcgaXRlcmF0aW9uIGNhbiBiZSBjb21wdXRlZCBvbmNlCgoKICAgICAgY29uc3QgaW52Q3MgPSBHU1NvbHZlcl9zb2x2ZV9pbnZDczsKICAgICAgY29uc3QgQnMgPSBHU1NvbHZlcl9zb2x2ZV9CczsKICAgICAgY29uc3QgbGFtYmRhID0gR1NTb2x2ZXJfc29sdmVfbGFtYmRhOwogICAgICBpbnZDcy5sZW5ndGggPSBOZXE7CiAgICAgIEJzLmxlbmd0aCA9IE5lcTsKICAgICAgbGFtYmRhLmxlbmd0aCA9IE5lcTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOZXE7IGkrKykgewogICAgICAgIGNvbnN0IGMgPSBlcXVhdGlvbnNbaV07CiAgICAgICAgbGFtYmRhW2ldID0gMC4wOwogICAgICAgIEJzW2ldID0gYy5jb21wdXRlQihoKTsKICAgICAgICBpbnZDc1tpXSA9IDEuMCAvIGMuY29tcHV0ZUMoKTsKICAgICAgfQoKICAgICAgaWYgKE5lcSAhPT0gMCkgewogICAgICAgIC8vIFJlc2V0IHZsYW1iZGEKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7CiAgICAgICAgICBjb25zdCBiID0gYm9kaWVzW2ldOwogICAgICAgICAgY29uc3QgdmxhbWJkYSA9IGIudmxhbWJkYTsKICAgICAgICAgIGNvbnN0IHdsYW1iZGEgPSBiLndsYW1iZGE7CiAgICAgICAgICB2bGFtYmRhLnNldCgwLCAwLCAwKTsKICAgICAgICAgIHdsYW1iZGEuc2V0KDAsIDAsIDApOwogICAgICAgIH0gLy8gSXRlcmF0ZSBvdmVyIGVxdWF0aW9ucwoKCiAgICAgICAgZm9yIChpdGVyID0gMDsgaXRlciAhPT0gbWF4SXRlcjsgaXRlcisrKSB7CiAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uCiAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDsKCiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiAhPT0gTmVxOyBqKyspIHsKICAgICAgICAgICAgY29uc3QgYyA9IGVxdWF0aW9uc1tqXTsgLy8gQ29tcHV0ZSBpdGVyYXRpb24KCiAgICAgICAgICAgIEIgPSBCc1tqXTsKICAgICAgICAgICAgaW52QyA9IGludkNzW2pdOwogICAgICAgICAgICBsYW1iZGFqID0gbGFtYmRhW2pdOwogICAgICAgICAgICBHV2xhbWJkYSA9IGMuY29tcHV0ZUdXbGFtYmRhKCk7CiAgICAgICAgICAgIGRlbHRhbGFtYmRhID0gaW52QyAqIChCIC0gR1dsYW1iZGEgLSBjLmVwcyAqIGxhbWJkYWopOyAvLyBDbGFtcCBpZiB3ZSBhcmUgbm90IHdpdGhpbiB0aGUgbWluL21heCBpbnRlcnZhbAoKICAgICAgICAgICAgaWYgKGxhbWJkYWogKyBkZWx0YWxhbWJkYSA8IGMubWluRm9yY2UpIHsKICAgICAgICAgICAgICBkZWx0YWxhbWJkYSA9IGMubWluRm9yY2UgLSBsYW1iZGFqOwogICAgICAgICAgICB9IGVsc2UgaWYgKGxhbWJkYWogKyBkZWx0YWxhbWJkYSA+IGMubWF4Rm9yY2UpIHsKICAgICAgICAgICAgICBkZWx0YWxhbWJkYSA9IGMubWF4Rm9yY2UgLSBsYW1iZGFqOwogICAgICAgICAgICB9CgogICAgICAgICAgICBsYW1iZGFbal0gKz0gZGVsdGFsYW1iZGE7CiAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ICs9IGRlbHRhbGFtYmRhID4gMC4wID8gZGVsdGFsYW1iZGEgOiAtZGVsdGFsYW1iZGE7IC8vIGFicyhkZWx0YWxhbWJkYSkKCiAgICAgICAgICAgIGMuYWRkVG9XbGFtYmRhKGRlbHRhbGFtYmRhKTsKICAgICAgICAgIH0gLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZQoKCiAgICAgICAgICBpZiAoZGVsdGFsYW1iZGFUb3QgKiBkZWx0YWxhbWJkYVRvdCA8IHRvbFNxdWFyZWQpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBBZGQgcmVzdWx0IHRvIHZlbG9jaXR5CgoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7CiAgICAgICAgICBjb25zdCBiID0gYm9kaWVzW2ldOwogICAgICAgICAgY29uc3QgdiA9IGIudmVsb2NpdHk7CiAgICAgICAgICBjb25zdCB3ID0gYi5hbmd1bGFyVmVsb2NpdHk7CiAgICAgICAgICBiLnZsYW1iZGEudm11bChiLmxpbmVhckZhY3RvciwgYi52bGFtYmRhKTsKICAgICAgICAgIHYudmFkZChiLnZsYW1iZGEsIHYpOwogICAgICAgICAgYi53bGFtYmRhLnZtdWwoYi5hbmd1bGFyRmFjdG9yLCBiLndsYW1iZGEpOwogICAgICAgICAgdy52YWRkKGIud2xhbWJkYSwgdyk7CiAgICAgICAgfSAvLyBTZXQgdGhlIGAubXVsdGlwbGllcmAgcHJvcGVydHkgb2YgZWFjaCBlcXVhdGlvbgoKCiAgICAgICAgbGV0IGwgPSBlcXVhdGlvbnMubGVuZ3RoOwogICAgICAgIGNvbnN0IGludkR0ID0gMSAvIGg7CgogICAgICAgIHdoaWxlIChsLS0pIHsKICAgICAgICAgIGVxdWF0aW9uc1tsXS5tdWx0aXBsaWVyID0gbGFtYmRhW2xdICogaW52RHQ7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gaXRlcjsKICAgIH0KCiAgfSAvLyBKdXN0IHRlbXBvcmFyeSBudW1iZXIgaG9sZGVycyB0aGF0IHdlIHdhbnQgdG8gcmV1c2UgZWFjaCBpdGVyYXRpb24uCgogIGNvbnN0IEdTU29sdmVyX3NvbHZlX2xhbWJkYSA9IFtdOwogIGNvbnN0IEdTU29sdmVyX3NvbHZlX2ludkNzID0gW107CiAgY29uc3QgR1NTb2x2ZXJfc29sdmVfQnMgPSBbXTsKCiAgLyoqCiAgICogU3BsaXRzIHRoZSBlcXVhdGlvbnMgaW50byBpc2xhbmRzIGFuZCBzb2x2ZXMgdGhlbSBpbmRlcGVuZGVudGx5LiBDYW4gaW1wcm92ZSBwZXJmb3JtYW5jZS4KICAgKi8KICBjbGFzcyBTcGxpdFNvbHZlciBleHRlbmRzIFNvbHZlciB7CiAgICAvKioKICAgICAqIFRoZSBudW1iZXIgb2Ygc29sdmVyIGl0ZXJhdGlvbnMgZGV0ZXJtaW5lcyBxdWFsaXR5IG9mIHRoZSBjb25zdHJhaW50cyBpbiB0aGUgd29ybGQuIFRoZSBtb3JlIGl0ZXJhdGlvbnMsIHRoZSBtb3JlIGNvcnJlY3Qgc2ltdWxhdGlvbi4gTW9yZSBpdGVyYXRpb25zIG5lZWQgbW9yZSBjb21wdXRhdGlvbnMgdGhvdWdoLiBJZiB5b3UgaGF2ZSBhIGxhcmdlIGdyYXZpdHkgZm9yY2UgaW4geW91ciB3b3JsZCwgeW91IHdpbGwgbmVlZCBtb3JlIGl0ZXJhdGlvbnMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFdoZW4gdG9sZXJhbmNlIGlzIHJlYWNoZWQsIHRoZSBzeXN0ZW0gaXMgYXNzdW1lZCB0byBiZSBjb252ZXJnZWQuCiAgICAgKi8KCiAgICAvKiogc3Vic29sdmVyICovCiAgICBjb25zdHJ1Y3RvcihzdWJzb2x2ZXIpIHsKICAgICAgc3VwZXIoKTsKICAgICAgdGhpcy5pdGVyYXRpb25zID0gMTA7CiAgICAgIHRoaXMudG9sZXJhbmNlID0gMWUtNzsKICAgICAgdGhpcy5zdWJzb2x2ZXIgPSBzdWJzb2x2ZXI7CiAgICAgIHRoaXMubm9kZXMgPSBbXTsKICAgICAgdGhpcy5ub2RlUG9vbCA9IFtdOyAvLyBDcmVhdGUgbmVlZGVkIG5vZGVzLCByZXVzZSBpZiBwb3NzaWJsZQoKICAgICAgd2hpbGUgKHRoaXMubm9kZVBvb2wubGVuZ3RoIDwgMTI4KSB7CiAgICAgICAgdGhpcy5ub2RlUG9vbC5wdXNoKHRoaXMuY3JlYXRlTm9kZSgpKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBjcmVhdGVOb2RlCiAgICAgKi8KCgogICAgY3JlYXRlTm9kZSgpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICBib2R5OiBudWxsLAogICAgICAgIGNoaWxkcmVuOiBbXSwKICAgICAgICBlcXM6IFtdLAogICAgICAgIHZpc2l0ZWQ6IGZhbHNlCiAgICAgIH07CiAgICB9CiAgICAvKioKICAgICAqIFNvbHZlIHRoZSBzdWJzeXN0ZW1zCiAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBpdGVyYXRpb25zIHBlcmZvcm1lZAogICAgICovCgoKICAgIHNvbHZlKGR0LCB3b3JsZCkgewogICAgICBjb25zdCBub2RlcyA9IFNwbGl0U29sdmVyX3NvbHZlX25vZGVzOwogICAgICBjb25zdCBub2RlUG9vbCA9IHRoaXMubm9kZVBvb2w7CiAgICAgIGNvbnN0IGJvZGllcyA9IHdvcmxkLmJvZGllczsKICAgICAgY29uc3QgZXF1YXRpb25zID0gdGhpcy5lcXVhdGlvbnM7CiAgICAgIGNvbnN0IE5lcSA9IGVxdWF0aW9ucy5sZW5ndGg7CiAgICAgIGNvbnN0IE5ib2RpZXMgPSBib2RpZXMubGVuZ3RoOwogICAgICBjb25zdCBzdWJzb2x2ZXIgPSB0aGlzLnN1YnNvbHZlcjsgLy8gQ3JlYXRlIG5lZWRlZCBub2RlcywgcmV1c2UgaWYgcG9zc2libGUKCiAgICAgIHdoaWxlIChub2RlUG9vbC5sZW5ndGggPCBOYm9kaWVzKSB7CiAgICAgICAgbm9kZVBvb2wucHVzaCh0aGlzLmNyZWF0ZU5vZGUoKSk7CiAgICAgIH0KCiAgICAgIG5vZGVzLmxlbmd0aCA9IE5ib2RpZXM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5ib2RpZXM7IGkrKykgewogICAgICAgIG5vZGVzW2ldID0gbm9kZVBvb2xbaV07CiAgICAgIH0gLy8gUmVzZXQgbm9kZSB2YWx1ZXMKCgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7CiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldOwogICAgICAgIG5vZGUuYm9keSA9IGJvZGllc1tpXTsKICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7CiAgICAgICAgbm9kZS5lcXMubGVuZ3RoID0gMDsKICAgICAgICBub2RlLnZpc2l0ZWQgPSBmYWxzZTsKICAgICAgfQoKICAgICAgZm9yIChsZXQgayA9IDA7IGsgIT09IE5lcTsgaysrKSB7CiAgICAgICAgY29uc3QgZXEgPSBlcXVhdGlvbnNba107CiAgICAgICAgY29uc3QgaSA9IGJvZGllcy5pbmRleE9mKGVxLmJpKTsKICAgICAgICBjb25zdCBqID0gYm9kaWVzLmluZGV4T2YoZXEuYmopOwogICAgICAgIGNvbnN0IG5pID0gbm9kZXNbaV07CiAgICAgICAgY29uc3QgbmogPSBub2Rlc1tqXTsKICAgICAgICBuaS5jaGlsZHJlbi5wdXNoKG5qKTsKICAgICAgICBuaS5lcXMucHVzaChlcSk7CiAgICAgICAgbmouY2hpbGRyZW4ucHVzaChuaSk7CiAgICAgICAgbmouZXFzLnB1c2goZXEpOwogICAgICB9CgogICAgICBsZXQgY2hpbGQ7CiAgICAgIGxldCBuID0gMDsKICAgICAgbGV0IGVxcyA9IFNwbGl0U29sdmVyX3NvbHZlX2VxczsKICAgICAgc3Vic29sdmVyLnRvbGVyYW5jZSA9IHRoaXMudG9sZXJhbmNlOwogICAgICBzdWJzb2x2ZXIuaXRlcmF0aW9ucyA9IHRoaXMuaXRlcmF0aW9uczsKICAgICAgY29uc3QgZHVtbXlXb3JsZCA9IFNwbGl0U29sdmVyX3NvbHZlX2R1bW15V29ybGQ7CgogICAgICB3aGlsZSAoY2hpbGQgPSBnZXRVbnZpc2l0ZWROb2RlKG5vZGVzKSkgewogICAgICAgIGVxcy5sZW5ndGggPSAwOwogICAgICAgIGR1bW15V29ybGQuYm9kaWVzLmxlbmd0aCA9IDA7CiAgICAgICAgYmZzKGNoaWxkLCB2aXNpdEZ1bmMsIGR1bW15V29ybGQuYm9kaWVzLCBlcXMpOwogICAgICAgIGNvbnN0IE5lcXMgPSBlcXMubGVuZ3RoOwogICAgICAgIGVxcyA9IGVxcy5zb3J0KHNvcnRCeUlkKTsKCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE5lcXM7IGkrKykgewogICAgICAgICAgc3Vic29sdmVyLmFkZEVxdWF0aW9uKGVxc1tpXSk7CiAgICAgICAgfQoKICAgICAgICBzdWJzb2x2ZXIuc29sdmUoZHQsIGR1bW15V29ybGQpOwogICAgICAgIHN1YnNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTsKICAgICAgICBuKys7CiAgICAgIH0KCiAgICAgIHJldHVybiBuOwogICAgfQoKICB9IC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBzdWJzeXN0ZW1zCgogIGNvbnN0IFNwbGl0U29sdmVyX3NvbHZlX25vZGVzID0gW107IC8vIEFsbCBhbGxvY2F0ZWQgbm9kZSBvYmplY3RzCgogIGNvbnN0IFNwbGl0U29sdmVyX3NvbHZlX2VxcyA9IFtdOyAvLyBUZW1wIGFycmF5CgogIGNvbnN0IFNwbGl0U29sdmVyX3NvbHZlX2R1bW15V29ybGQgPSB7CiAgICBib2RpZXM6IFtdCiAgfTsgLy8gVGVtcCBvYmplY3QKCiAgY29uc3QgU1RBVElDID0gQm9keS5TVEFUSUM7CgogIGZ1bmN0aW9uIGdldFVudmlzaXRlZE5vZGUobm9kZXMpIHsKICAgIGNvbnN0IE5ub2RlcyA9IG5vZGVzLmxlbmd0aDsKCiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTm5vZGVzOyBpKyspIHsKICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldOwoKICAgICAgaWYgKCFub2RlLnZpc2l0ZWQgJiYgIShub2RlLmJvZHkudHlwZSAmIFNUQVRJQykpIHsKICAgICAgICByZXR1cm4gbm9kZTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiBmYWxzZTsKICB9CgogIGNvbnN0IHF1ZXVlID0gW107CgogIGZ1bmN0aW9uIGJmcyhyb290LCB2aXNpdEZ1bmMsIGJkcywgZXFzKSB7CiAgICBxdWV1ZS5wdXNoKHJvb3QpOwogICAgcm9vdC52aXNpdGVkID0gdHJ1ZTsKICAgIHZpc2l0RnVuYyhyb290LCBiZHMsIGVxcyk7CgogICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkgewogICAgICBjb25zdCBub2RlID0gcXVldWUucG9wKCk7IC8vIExvb3Agb3ZlciB1bnZpc2l0ZWQgY2hpbGQgbm9kZXMKCiAgICAgIGxldCBjaGlsZDsKCiAgICAgIHdoaWxlIChjaGlsZCA9IGdldFVudmlzaXRlZE5vZGUobm9kZS5jaGlsZHJlbikpIHsKICAgICAgICBjaGlsZC52aXNpdGVkID0gdHJ1ZTsKICAgICAgICB2aXNpdEZ1bmMoY2hpbGQsIGJkcywgZXFzKTsKICAgICAgICBxdWV1ZS5wdXNoKGNoaWxkKTsKICAgICAgfQogICAgfQogIH0KCiAgZnVuY3Rpb24gdmlzaXRGdW5jKG5vZGUsIGJkcywgZXFzKSB7CiAgICBiZHMucHVzaChub2RlLmJvZHkpOwogICAgY29uc3QgTmVxcyA9IG5vZGUuZXFzLmxlbmd0aDsKCiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmVxczsgaSsrKSB7CiAgICAgIGNvbnN0IGVxID0gbm9kZS5lcXNbaV07CgogICAgICBpZiAoIWVxcy5pbmNsdWRlcyhlcSkpIHsKICAgICAgICBlcXMucHVzaChlcSk7CiAgICAgIH0KICAgIH0KICB9CgogIGZ1bmN0aW9uIHNvcnRCeUlkKGEsIGIpIHsKICAgIHJldHVybiBiLmlkIC0gYS5pZDsKICB9CgogIC8qKgogICAqIEZvciBwb29saW5nIG9iamVjdHMgdGhhdCBjYW4gYmUgcmV1c2VkLgogICAqLwogIGNsYXNzIFBvb2wgewogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHRoaXMub2JqZWN0cyA9IFtdOwogICAgICB0aGlzLnR5cGUgPSBPYmplY3Q7CiAgICB9CgogICAgLyoqCiAgICAgKiBSZWxlYXNlIGFuIG9iamVjdCBhZnRlciB1c2UKICAgICAqLwogICAgcmVsZWFzZSgpIHsKICAgICAgY29uc3QgTmFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE5hcmdzOyBpKyspIHsKICAgICAgICB0aGlzLm9iamVjdHMucHVzaChpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV0pOwogICAgICB9CgogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogR2V0IGFuIG9iamVjdAogICAgICovCgoKICAgIGdldCgpIHsKICAgICAgaWYgKHRoaXMub2JqZWN0cy5sZW5ndGggPT09IDApIHsKICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RPYmplY3QoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RzLnBvcCgpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbnN0cnVjdCBhbiBvYmplY3QuIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBlYWNoIHN1YmNsYXNzLgogICAgICovCgoKICAgIGNvbnN0cnVjdE9iamVjdCgpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb25zdHJ1Y3RPYmplY3QoKSBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBQb29sIHN1YmNsYXNzIHlldCEnKTsKICAgIH0KICAgIC8qKgogICAgICogQHJldHVybiBTZWxmLCBmb3IgY2hhaW5pbmcKICAgICAqLwoKCiAgICByZXNpemUoc2l6ZSkgewogICAgICBjb25zdCBvYmplY3RzID0gdGhpcy5vYmplY3RzOwoKICAgICAgd2hpbGUgKG9iamVjdHMubGVuZ3RoID4gc2l6ZSkgewogICAgICAgIG9iamVjdHMucG9wKCk7CiAgICAgIH0KCiAgICAgIHdoaWxlIChvYmplY3RzLmxlbmd0aCA8IHNpemUpIHsKICAgICAgICBvYmplY3RzLnB1c2godGhpcy5jb25zdHJ1Y3RPYmplY3QoKSk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzOwogICAgfQoKICB9CgogIC8qKgogICAqIFZlYzNQb29sCiAgICovCgogIGNsYXNzIFZlYzNQb29sIGV4dGVuZHMgUG9vbCB7CiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTsKICAgICAgdGhpcy50eXBlID0gVmVjMzsKICAgIH0KCiAgICAvKioKICAgICAqIENvbnN0cnVjdCBhIHZlY3RvcgogICAgICovCiAgICBjb25zdHJ1Y3RPYmplY3QoKSB7CiAgICAgIHJldHVybiBuZXcgVmVjMygpOwogICAgfQoKICB9CgogIC8vIE5hbWluZyBydWxlOiBiYXNlZCBvZiB0aGUgb3JkZXIgaW4gU0hBUEVfVFlQRVMsCiAgLy8gdGhlIGZpcnN0IHBhcnQgb2YgdGhlIG1ldGhvZCBpcyBmb3JtZWQgYnkgdGhlCiAgLy8gc2hhcGUgdHlwZSB0aGF0IGNvbWVzIGJlZm9yZSwgaW4gdGhlIHNlY29uZCBwYXJ0CiAgLy8gdGhlcmUgaXMgdGhlIHNoYXBlIHR5cGUgdGhhdCBjb21lcyBhZnRlciBpbiB0aGUgU0hBUEVfVFlQRVMgbGlzdAogIGNvbnN0IENPTExJU0lPTl9UWVBFUyA9IHsKICAgIHNwaGVyZVNwaGVyZTogU2hhcGUudHlwZXMuU1BIRVJFLAogICAgc3BoZXJlUGxhbmU6IFNoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLlBMQU5FLAogICAgYm94Qm94OiBTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5CT1gsCiAgICBzcGhlcmVCb3g6IFNoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLkJPWCwKICAgIHBsYW5lQm94OiBTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLkJPWCwKICAgIGNvbnZleENvbnZleDogU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiwKICAgIHNwaGVyZUNvbnZleDogU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiwKICAgIHBsYW5lQ29udmV4OiBTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04sCiAgICBib3hDb252ZXg6IFNoYXBlLnR5cGVzLkJPWCB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04sCiAgICBzcGhlcmVIZWlnaHRmaWVsZDogU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTEQsCiAgICBib3hIZWlnaHRmaWVsZDogU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTEQsCiAgICBjb252ZXhIZWlnaHRmaWVsZDogU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiB8IFNoYXBlLnR5cGVzLkhFSUdIVEZJRUxELAogICAgc3BoZXJlUGFydGljbGU6IFNoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuU1BIRVJFLAogICAgcGxhbmVQYXJ0aWNsZTogU2hhcGUudHlwZXMuUExBTkUgfCBTaGFwZS50eXBlcy5QQVJUSUNMRSwKICAgIGJveFBhcnRpY2xlOiBTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5QQVJUSUNMRSwKICAgIGNvbnZleFBhcnRpY2xlOiBTaGFwZS50eXBlcy5QQVJUSUNMRSB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04sCiAgICBjeWxpbmRlckN5bGluZGVyOiBTaGFwZS50eXBlcy5DWUxJTkRFUiwKICAgIHNwaGVyZUN5bGluZGVyOiBTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5DWUxJTkRFUiwKICAgIHBsYW5lQ3lsaW5kZXI6IFNoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuQ1lMSU5ERVIsCiAgICBib3hDeWxpbmRlcjogU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuQ1lMSU5ERVIsCiAgICBjb252ZXhDeWxpbmRlcjogU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiB8IFNoYXBlLnR5cGVzLkNZTElOREVSLAogICAgaGVpZ2h0ZmllbGRDeWxpbmRlcjogU2hhcGUudHlwZXMuSEVJR0hURklFTEQgfCBTaGFwZS50eXBlcy5DWUxJTkRFUiwKICAgIHBhcnRpY2xlQ3lsaW5kZXI6IFNoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuQ1lMSU5ERVIsCiAgICBzcGhlcmVUcmltZXNoOiBTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5UUklNRVNILAogICAgcGxhbmVUcmltZXNoOiBTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLlRSSU1FU0gKICB9OwoKICAvKioKICAgKiBIZWxwZXIgY2xhc3MgZm9yIHRoZSBXb3JsZC4gR2VuZXJhdGVzIENvbnRhY3RFcXVhdGlvbnMuCiAgICogQHRvZG8gU3BoZXJlLUNvbnZleFBvbHloZWRyb24gY29udGFjdHMKICAgKiBAdG9kbyBDb250YWN0IHJlZHVjdGlvbgogICAqIEB0b2RvIHNob3VsZCBtb3ZlIG1ldGhvZHMgdG8gcHJvdG90eXBlCiAgICovCiAgY2xhc3MgTmFycm93cGhhc2UgewogICAgLyoqCiAgICAgKiBJbnRlcm5hbCBzdG9yYWdlIG9mIHBvb2xlZCBjb250YWN0IHBvaW50cy4KICAgICAqLwoKICAgIC8qKgogICAgICogUG9vbGVkIHZlY3RvcnMuCiAgICAgKi8KICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnNwaGVyZVNwaGVyZV0oKSB7CiAgICAgIHJldHVybiB0aGlzLnNwaGVyZVNwaGVyZTsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5zcGhlcmVQbGFuZV0oKSB7CiAgICAgIHJldHVybiB0aGlzLnNwaGVyZVBsYW5lOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmJveEJveF0oKSB7CiAgICAgIHJldHVybiB0aGlzLmJveEJveDsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5zcGhlcmVCb3hdKCkgewogICAgICByZXR1cm4gdGhpcy5zcGhlcmVCb3g7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMucGxhbmVCb3hdKCkgewogICAgICByZXR1cm4gdGhpcy5wbGFuZUJveDsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5jb252ZXhDb252ZXhdKCkgewogICAgICByZXR1cm4gdGhpcy5jb252ZXhDb252ZXg7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuc3BoZXJlQ29udmV4XSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc3BoZXJlQ29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnBsYW5lQ29udmV4XSgpIHsKICAgICAgcmV0dXJuIHRoaXMucGxhbmVDb252ZXg7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuYm94Q29udmV4XSgpIHsKICAgICAgcmV0dXJuIHRoaXMuYm94Q29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnNwaGVyZUhlaWdodGZpZWxkXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc3BoZXJlSGVpZ2h0ZmllbGQ7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuYm94SGVpZ2h0ZmllbGRdKCkgewogICAgICByZXR1cm4gdGhpcy5ib3hIZWlnaHRmaWVsZDsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5jb252ZXhIZWlnaHRmaWVsZF0oKSB7CiAgICAgIHJldHVybiB0aGlzLmNvbnZleEhlaWdodGZpZWxkOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnNwaGVyZVBhcnRpY2xlXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc3BoZXJlUGFydGljbGU7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMucGxhbmVQYXJ0aWNsZV0oKSB7CiAgICAgIHJldHVybiB0aGlzLnBsYW5lUGFydGljbGU7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuYm94UGFydGljbGVdKCkgewogICAgICByZXR1cm4gdGhpcy5ib3hQYXJ0aWNsZTsKICAgIH0KCiAgICBnZXQgW0NPTExJU0lPTl9UWVBFUy5jb252ZXhQYXJ0aWNsZV0oKSB7CiAgICAgIHJldHVybiB0aGlzLmNvbnZleFBhcnRpY2xlOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmN5bGluZGVyQ3lsaW5kZXJdKCkgewogICAgICByZXR1cm4gdGhpcy5jb252ZXhDb252ZXg7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMuc3BoZXJlQ3lsaW5kZXJdKCkgewogICAgICByZXR1cm4gdGhpcy5zcGhlcmVDb252ZXg7CiAgICB9CgogICAgZ2V0IFtDT0xMSVNJT05fVFlQRVMucGxhbmVDeWxpbmRlcl0oKSB7CiAgICAgIHJldHVybiB0aGlzLnBsYW5lQ29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmJveEN5bGluZGVyXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuYm94Q29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmNvbnZleEN5bGluZGVyXSgpIHsKICAgICAgcmV0dXJuIHRoaXMuY29udmV4Q29udmV4OwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLmhlaWdodGZpZWxkQ3lsaW5kZXJdKCkgewogICAgICByZXR1cm4gdGhpcy5oZWlnaHRmaWVsZEN5bGluZGVyOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnBhcnRpY2xlQ3lsaW5kZXJdKCkgewogICAgICByZXR1cm4gdGhpcy5wYXJ0aWNsZUN5bGluZGVyOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnNwaGVyZVRyaW1lc2hdKCkgewogICAgICByZXR1cm4gdGhpcy5zcGhlcmVUcmltZXNoOwogICAgfQoKICAgIGdldCBbQ09MTElTSU9OX1RZUEVTLnBsYW5lVHJpbWVzaF0oKSB7CiAgICAgIHJldHVybiB0aGlzLnBsYW5lVHJpbWVzaDsKICAgIH0gLy8gZ2V0IFtDT0xMSVNJT05fVFlQRVMuY29udmV4VHJpbWVzaF0oKSB7CiAgICAvLyAgIHJldHVybiB0aGlzLmNvbnZleFRyaW1lc2gKICAgIC8vIH0KCgogICAgY29uc3RydWN0b3Iod29ybGQpIHsKICAgICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gW107CiAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBbXTsKICAgICAgdGhpcy5yZXN1bHQgPSBbXTsKICAgICAgdGhpcy5mcmljdGlvblJlc3VsdCA9IFtdOwogICAgICB0aGlzLnYzcG9vbCA9IG5ldyBWZWMzUG9vbCgpOwogICAgICB0aGlzLndvcmxkID0gd29ybGQ7CiAgICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHdvcmxkLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7CiAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gPSBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogTWFrZSBhIGNvbnRhY3Qgb2JqZWN0LCBieSB1c2luZyB0aGUgaW50ZXJuYWwgcG9vbCBvciBjcmVhdGluZyBhIG5ldyBvbmUuCiAgICAgKi8KCgogICAgY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCBvdmVycmlkZVNoYXBlQSwgb3ZlcnJpZGVTaGFwZUIpIHsKICAgICAgbGV0IGM7CgogICAgICBpZiAodGhpcy5jb250YWN0UG9pbnRQb29sLmxlbmd0aCkgewogICAgICAgIGMgPSB0aGlzLmNvbnRhY3RQb2ludFBvb2wucG9wKCk7CiAgICAgICAgYy5iaSA9IGJpOwogICAgICAgIGMuYmogPSBiajsKICAgICAgfSBlbHNlIHsKICAgICAgICBjID0gbmV3IENvbnRhY3RFcXVhdGlvbihiaSwgYmopOwogICAgICB9CgogICAgICBjLmVuYWJsZWQgPSBiaS5jb2xsaXNpb25SZXNwb25zZSAmJiBiai5jb2xsaXNpb25SZXNwb25zZSAmJiBzaS5jb2xsaXNpb25SZXNwb25zZSAmJiBzai5jb2xsaXNpb25SZXNwb25zZTsKICAgICAgY29uc3QgY20gPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7CiAgICAgIGMucmVzdGl0dXRpb24gPSBjbS5yZXN0aXR1dGlvbjsKICAgICAgYy5zZXRTcG9va1BhcmFtcyhjbS5jb250YWN0RXF1YXRpb25TdGlmZm5lc3MsIGNtLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24sIHRoaXMud29ybGQuZHQpOwogICAgICBjb25zdCBtYXRBID0gc2kubWF0ZXJpYWwgfHwgYmkubWF0ZXJpYWw7CiAgICAgIGNvbnN0IG1hdEIgPSBzai5tYXRlcmlhbCB8fCBiai5tYXRlcmlhbDsKCiAgICAgIGlmIChtYXRBICYmIG1hdEIgJiYgbWF0QS5yZXN0aXR1dGlvbiA+PSAwICYmIG1hdEIucmVzdGl0dXRpb24gPj0gMCkgewogICAgICAgIGMucmVzdGl0dXRpb24gPSBtYXRBLnJlc3RpdHV0aW9uICogbWF0Qi5yZXN0aXR1dGlvbjsKICAgICAgfQoKICAgICAgYy5zaSA9IG92ZXJyaWRlU2hhcGVBIHx8IHNpOwogICAgICBjLnNqID0gb3ZlcnJpZGVTaGFwZUIgfHwgc2o7CiAgICAgIHJldHVybiBjOwogICAgfQoKICAgIGNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QoY29udGFjdEVxdWF0aW9uLCBvdXRBcnJheSkgewogICAgICBjb25zdCBib2R5QSA9IGNvbnRhY3RFcXVhdGlvbi5iaTsKICAgICAgY29uc3QgYm9keUIgPSBjb250YWN0RXF1YXRpb24uYmo7CiAgICAgIGNvbnN0IHNoYXBlQSA9IGNvbnRhY3RFcXVhdGlvbi5zaTsKICAgICAgY29uc3Qgc2hhcGVCID0gY29udGFjdEVxdWF0aW9uLnNqOwogICAgICBjb25zdCB3b3JsZCA9IHRoaXMud29ybGQ7CiAgICAgIGNvbnN0IGNtID0gdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsOyAvLyBJZiBmcmljdGlvbiBvciByZXN0aXR1dGlvbiB3ZXJlIHNwZWNpZmllZCBpbiB0aGUgbWF0ZXJpYWwsIHVzZSB0aGVtCgogICAgICBsZXQgZnJpY3Rpb24gPSBjbS5mcmljdGlvbjsKICAgICAgY29uc3QgbWF0QSA9IHNoYXBlQS5tYXRlcmlhbCB8fCBib2R5QS5tYXRlcmlhbDsKICAgICAgY29uc3QgbWF0QiA9IHNoYXBlQi5tYXRlcmlhbCB8fCBib2R5Qi5tYXRlcmlhbDsKCiAgICAgIGlmIChtYXRBICYmIG1hdEIgJiYgbWF0QS5mcmljdGlvbiA+PSAwICYmIG1hdEIuZnJpY3Rpb24gPj0gMCkgewogICAgICAgIGZyaWN0aW9uID0gbWF0QS5mcmljdGlvbiAqIG1hdEIuZnJpY3Rpb247CiAgICAgIH0KCiAgICAgIGlmIChmcmljdGlvbiA+IDApIHsKICAgICAgICAvLyBDcmVhdGUgMiB0YW5nZW50IGVxdWF0aW9ucwogICAgICAgIC8vIFVzZXJzIG1heSBwcm92aWRlIGEgZm9yY2UgZGlmZmVyZW50IGZyb20gZ2xvYmFsIGdyYXZpdHkgdG8gdXNlIHdoZW4gY29tcHV0aW5nIGNvbnRhY3QgZnJpY3Rpb24uCiAgICAgICAgY29uc3QgbXVnID0gZnJpY3Rpb24gKiAod29ybGQuZnJpY3Rpb25HcmF2aXR5IHx8IHdvcmxkLmdyYXZpdHkpLmxlbmd0aCgpOwogICAgICAgIGxldCByZWR1Y2VkTWFzcyA9IGJvZHlBLmludk1hc3MgKyBib2R5Qi5pbnZNYXNzOwoKICAgICAgICBpZiAocmVkdWNlZE1hc3MgPiAwKSB7CiAgICAgICAgICByZWR1Y2VkTWFzcyA9IDEgLyByZWR1Y2VkTWFzczsKICAgICAgICB9CgogICAgICAgIGNvbnN0IHBvb2wgPSB0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sOwogICAgICAgIGNvbnN0IGMxID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtdWcgKiByZWR1Y2VkTWFzcyk7CiAgICAgICAgY29uc3QgYzIgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgRnJpY3Rpb25FcXVhdGlvbihib2R5QSwgYm9keUIsIG11ZyAqIHJlZHVjZWRNYXNzKTsKICAgICAgICBjMS5iaSA9IGMyLmJpID0gYm9keUE7CiAgICAgICAgYzEuYmogPSBjMi5iaiA9IGJvZHlCOwogICAgICAgIGMxLm1pbkZvcmNlID0gYzIubWluRm9yY2UgPSAtbXVnICogcmVkdWNlZE1hc3M7CiAgICAgICAgYzEubWF4Rm9yY2UgPSBjMi5tYXhGb3JjZSA9IG11ZyAqIHJlZHVjZWRNYXNzOyAvLyBDb3B5IG92ZXIgdGhlIHJlbGF0aXZlIHZlY3RvcnMKCiAgICAgICAgYzEucmkuY29weShjb250YWN0RXF1YXRpb24ucmkpOwogICAgICAgIGMxLnJqLmNvcHkoY29udGFjdEVxdWF0aW9uLnJqKTsKICAgICAgICBjMi5yaS5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaSk7CiAgICAgICAgYzIucmouY29weShjb250YWN0RXF1YXRpb24ucmopOyAvLyBDb25zdHJ1Y3QgdGFuZ2VudHMKCiAgICAgICAgY29udGFjdEVxdWF0aW9uLm5pLnRhbmdlbnRzKGMxLnQsIGMyLnQpOyAvLyBTZXQgc3Bvb2sgcGFyYW1zCgogICAgICAgIGMxLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCB3b3JsZC5kdCk7CiAgICAgICAgYzIuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIHdvcmxkLmR0KTsKICAgICAgICBjMS5lbmFibGVkID0gYzIuZW5hYmxlZCA9IGNvbnRhY3RFcXVhdGlvbi5lbmFibGVkOwogICAgICAgIG91dEFycmF5LnB1c2goYzEsIGMyKTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQoKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgLyoqCiAgICAgKiBUYWtlIHRoZSBhdmVyYWdlIE4gbGF0ZXN0IGNvbnRhY3QgcG9pbnQgb24gdGhlIHBsYW5lLgogICAgICovCgoKICAgIGNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpIHsKICAgICAgLy8gVGhlIGxhc3QgY29udGFjdEVxdWF0aW9uCiAgICAgIGxldCBjID0gdGhpcy5yZXN1bHRbdGhpcy5yZXN1bHQubGVuZ3RoIC0gMV07IC8vIENyZWF0ZSB0aGUgcmVzdWx0OiB0d28gImF2ZXJhZ2UiIGZyaWN0aW9uIGVxdWF0aW9ucwoKICAgICAgaWYgKCF0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QoYywgdGhpcy5mcmljdGlvblJlc3VsdCkgfHwgbnVtQ29udGFjdHMgPT09IDEpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IGYxID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDJdOwogICAgICBjb25zdCBmMiA9IHRoaXMuZnJpY3Rpb25SZXN1bHRbdGhpcy5mcmljdGlvblJlc3VsdC5sZW5ndGggLSAxXTsKICAgICAgYXZlcmFnZU5vcm1hbC5zZXRaZXJvKCk7CiAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnNldFplcm8oKTsKICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEIuc2V0WmVybygpOwogICAgICBjb25zdCBib2R5QSA9IGMuYmk7CiAgICAgIGMuYmo7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gbnVtQ29udGFjdHM7IGkrKykgewogICAgICAgIGMgPSB0aGlzLnJlc3VsdFt0aGlzLnJlc3VsdC5sZW5ndGggLSAxIC0gaV07CgogICAgICAgIGlmIChjLmJpICE9PSBib2R5QSkgewogICAgICAgICAgYXZlcmFnZU5vcm1hbC52YWRkKGMubmksIGF2ZXJhZ2VOb3JtYWwpOwogICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEEudmFkZChjLnJpLCBhdmVyYWdlQ29udGFjdFBvaW50QSk7CiAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi52YWRkKGMucmosIGF2ZXJhZ2VDb250YWN0UG9pbnRCKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgYXZlcmFnZU5vcm1hbC52c3ViKGMubmksIGF2ZXJhZ2VOb3JtYWwpOwogICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEEudmFkZChjLnJqLCBhdmVyYWdlQ29udGFjdFBvaW50QSk7CiAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi52YWRkKGMucmksIGF2ZXJhZ2VDb250YWN0UG9pbnRCKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGNvbnN0IGludk51bUNvbnRhY3RzID0gMSAvIG51bUNvbnRhY3RzOwogICAgICBhdmVyYWdlQ29udGFjdFBvaW50QS5zY2FsZShpbnZOdW1Db250YWN0cywgZjEucmkpOwogICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi5zY2FsZShpbnZOdW1Db250YWN0cywgZjEucmopOwogICAgICBmMi5yaS5jb3B5KGYxLnJpKTsgLy8gU2hvdWxkIGJlIHRoZSBzYW1lCgogICAgICBmMi5yai5jb3B5KGYxLnJqKTsKICAgICAgYXZlcmFnZU5vcm1hbC5ub3JtYWxpemUoKTsKICAgICAgYXZlcmFnZU5vcm1hbC50YW5nZW50cyhmMS50LCBmMi50KTsgLy8gcmV0dXJuIGVxOwogICAgfQogICAgLyoqCiAgICAgKiBHZW5lcmF0ZSBhbGwgY29udGFjdHMgYmV0d2VlbiBhIGxpc3Qgb2YgYm9keSBwYWlycwogICAgICogQHBhcmFtIHAxIEFycmF5IG9mIGJvZHkgaW5kaWNlcwogICAgICogQHBhcmFtIHAyIEFycmF5IG9mIGJvZHkgaW5kaWNlcwogICAgICogQHBhcmFtIHJlc3VsdCBBcnJheSB0byBzdG9yZSBnZW5lcmF0ZWQgY29udGFjdHMKICAgICAqIEBwYXJhbSBvbGRjb250YWN0cyBPcHRpb25hbC4gQXJyYXkgb2YgcmV1c2FibGUgY29udGFjdCBvYmplY3RzCiAgICAgKi8KCgogICAgZ2V0Q29udGFjdHMocDEsIHAyLCB3b3JsZCwgcmVzdWx0LCBvbGRjb250YWN0cywgZnJpY3Rpb25SZXN1bHQsIGZyaWN0aW9uUG9vbCkgewogICAgICAvLyBTYXZlIG9sZCBjb250YWN0IG9iamVjdHMKICAgICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gb2xkY29udGFjdHM7CiAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBmcmljdGlvblBvb2w7CiAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0OwogICAgICB0aGlzLmZyaWN0aW9uUmVzdWx0ID0gZnJpY3Rpb25SZXN1bHQ7CiAgICAgIGNvbnN0IHFpID0gdG1wUXVhdDE7CiAgICAgIGNvbnN0IHFqID0gdG1wUXVhdDI7CiAgICAgIGNvbnN0IHhpID0gdG1wVmVjMTsKICAgICAgY29uc3QgeGogPSB0bXBWZWMyOwoKICAgICAgZm9yIChsZXQgayA9IDAsIE4gPSBwMS5sZW5ndGg7IGsgIT09IE47IGsrKykgewogICAgICAgIC8vIEdldCBjdXJyZW50IGNvbGxpc2lvbiBib2RpZXMKICAgICAgICBjb25zdCBiaSA9IHAxW2tdOwogICAgICAgIGNvbnN0IGJqID0gcDJba107IC8vIEdldCBjb250YWN0IG1hdGVyaWFsCgogICAgICAgIGxldCBib2R5Q29udGFjdE1hdGVyaWFsID0gbnVsbDsKCiAgICAgICAgaWYgKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKSB7CiAgICAgICAgICBib2R5Q29udGFjdE1hdGVyaWFsID0gd29ybGQuZ2V0Q29udGFjdE1hdGVyaWFsKGJpLm1hdGVyaWFsLCBiai5tYXRlcmlhbCkgfHwgbnVsbDsKICAgICAgICB9CgogICAgICAgIGNvbnN0IGp1c3RUZXN0ID0gYmkudHlwZSAmIEJvZHkuS0lORU1BVElDICYmIGJqLnR5cGUgJiBCb2R5LlNUQVRJQyB8fCBiaS50eXBlICYgQm9keS5TVEFUSUMgJiYgYmoudHlwZSAmIEJvZHkuS0lORU1BVElDIHx8IGJpLnR5cGUgJiBCb2R5LktJTkVNQVRJQyAmJiBiai50eXBlICYgQm9keS5LSU5FTUFUSUM7CgogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmkuc2hhcGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBiaS5xdWF0ZXJuaW9uLm11bHQoYmkuc2hhcGVPcmllbnRhdGlvbnNbaV0sIHFpKTsKICAgICAgICAgIGJpLnF1YXRlcm5pb24udm11bHQoYmkuc2hhcGVPZmZzZXRzW2ldLCB4aSk7CiAgICAgICAgICB4aS52YWRkKGJpLnBvc2l0aW9uLCB4aSk7CiAgICAgICAgICBjb25zdCBzaSA9IGJpLnNoYXBlc1tpXTsKCiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJqLnNoYXBlcy5sZW5ndGg7IGorKykgewogICAgICAgICAgICAvLyBDb21wdXRlIHdvcmxkIHRyYW5zZm9ybSBvZiBzaGFwZXMKICAgICAgICAgICAgYmoucXVhdGVybmlvbi5tdWx0KGJqLnNoYXBlT3JpZW50YXRpb25zW2pdLCBxaik7CiAgICAgICAgICAgIGJqLnF1YXRlcm5pb24udm11bHQoYmouc2hhcGVPZmZzZXRzW2pdLCB4aik7CiAgICAgICAgICAgIHhqLnZhZGQoYmoucG9zaXRpb24sIHhqKTsKICAgICAgICAgICAgY29uc3Qgc2ogPSBiai5zaGFwZXNbal07CgogICAgICAgICAgICBpZiAoIShzaS5jb2xsaXNpb25GaWx0ZXJNYXNrICYgc2ouY29sbGlzaW9uRmlsdGVyR3JvdXAgJiYgc2ouY29sbGlzaW9uRmlsdGVyTWFzayAmIHNpLmNvbGxpc2lvbkZpbHRlckdyb3VwKSkgewogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0gLy8gR2V0IGNvbGxpc2lvbiBtYXRlcmlhbAoKCiAgICAgICAgICAgIGxldCBzaGFwZUNvbnRhY3RNYXRlcmlhbCA9IG51bGw7CgogICAgICAgICAgICBpZiAoc2kubWF0ZXJpYWwgJiYgc2oubWF0ZXJpYWwpIHsKICAgICAgICAgICAgICBzaGFwZUNvbnRhY3RNYXRlcmlhbCA9IHdvcmxkLmdldENvbnRhY3RNYXRlcmlhbChzaS5tYXRlcmlhbCwgc2oubWF0ZXJpYWwpIHx8IG51bGw7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHNoYXBlQ29udGFjdE1hdGVyaWFsIHx8IGJvZHlDb250YWN0TWF0ZXJpYWwgfHwgd29ybGQuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDsgLy8gR2V0IGNvbnRhY3RzCgogICAgICAgICAgICBjb25zdCByZXNvbHZlckluZGV4ID0gc2kudHlwZSB8IHNqLnR5cGU7CiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gdGhpc1tyZXNvbHZlckluZGV4XTsKCiAgICAgICAgICAgIGlmIChyZXNvbHZlcikgewogICAgICAgICAgICAgIGxldCByZXR2YWwgPSBmYWxzZTsgLy8gVE8gRE86IGludmVzdGlnYXRlIHdoeSBzcGhlcmVQYXJ0aWNsZSBhbmQgY29udmV4UGFydGljbGUKICAgICAgICAgICAgICAvLyByZXNvbHZlcnMgZXhwZWN0IHNpIGFuZCBzaiBzaGFwZXMgdG8gYmUgaW4gcmV2ZXJzZSBvcmRlcgogICAgICAgICAgICAgIC8vIChpLmUuIGxhcmdlciBpbnRlZ2VyIHZhbHVlIHR5cGUgZmlyc3QgaW5zdGVhZCBvZiBzbWFsbGVyIGZpcnN0KQoKICAgICAgICAgICAgICBpZiAoc2kudHlwZSA8IHNqLnR5cGUpIHsKICAgICAgICAgICAgICAgIHJldHZhbCA9IHJlc29sdmVyLmNhbGwodGhpcywgc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmV0dmFsID0gcmVzb2x2ZXIuY2FsbCh0aGlzLCBzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHNpLCBzaiwganVzdFRlc3QpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgaWYgKHJldHZhbCAmJiBqdXN0VGVzdCkgewogICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgb3ZlcmxhcAogICAgICAgICAgICAgICAgd29ybGQuc2hhcGVPdmVybGFwS2VlcGVyLnNldChzaS5pZCwgc2ouaWQpOwogICAgICAgICAgICAgICAgd29ybGQuYm9keU92ZXJsYXBLZWVwZXIuc2V0KGJpLmlkLCBiai5pZCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgc3BoZXJlU3BoZXJlKHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgIHJldHVybiB4aS5kaXN0YW5jZVNxdWFyZWQoeGopIDwgKHNpLnJhZGl1cyArIHNqLnJhZGl1cykgKiogMjsKICAgICAgfSAvLyBXZSB3aWxsIGhhdmUgb25seSBvbmUgY29udGFjdCBpbiB0aGlzIGNhc2UKCgogICAgICBjb25zdCBjb250YWN0RXEgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOyAvLyBDb250YWN0IG5vcm1hbAoKICAgICAgeGoudnN1Yih4aSwgY29udGFjdEVxLm5pKTsKICAgICAgY29udGFjdEVxLm5pLm5vcm1hbGl6ZSgpOyAvLyBDb250YWN0IHBvaW50IGxvY2F0aW9ucwoKICAgICAgY29udGFjdEVxLnJpLmNvcHkoY29udGFjdEVxLm5pKTsKICAgICAgY29udGFjdEVxLnJqLmNvcHkoY29udGFjdEVxLm5pKTsKICAgICAgY29udGFjdEVxLnJpLnNjYWxlKHNpLnJhZGl1cywgY29udGFjdEVxLnJpKTsKICAgICAgY29udGFjdEVxLnJqLnNjYWxlKC1zai5yYWRpdXMsIGNvbnRhY3RFcS5yaik7CiAgICAgIGNvbnRhY3RFcS5yaS52YWRkKHhpLCBjb250YWN0RXEucmkpOwogICAgICBjb250YWN0RXEucmkudnN1YihiaS5wb3NpdGlvbiwgY29udGFjdEVxLnJpKTsKICAgICAgY29udGFjdEVxLnJqLnZhZGQoeGosIGNvbnRhY3RFcS5yaik7CiAgICAgIGNvbnRhY3RFcS5yai52c3ViKGJqLnBvc2l0aW9uLCBjb250YWN0RXEucmopOwogICAgICB0aGlzLnJlc3VsdC5wdXNoKGNvbnRhY3RFcSk7CiAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChjb250YWN0RXEsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgfQoKICAgIHNwaGVyZVBsYW5lKHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIC8vIFdlIHdpbGwgaGF2ZSBvbmUgY29udGFjdCBpbiB0aGlzIGNhc2UKICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7IC8vIENvbnRhY3Qgbm9ybWFsCgogICAgICByLm5pLnNldCgwLCAwLCAxKTsKICAgICAgcWoudm11bHQoci5uaSwgci5uaSk7CiAgICAgIHIubmkubmVnYXRlKHIubmkpOyAvLyBib2R5IGkgaXMgdGhlIHNwaGVyZSwgZmxpcCBub3JtYWwKCiAgICAgIHIubmkubm9ybWFsaXplKCk7IC8vIE5lZWRlZD8KICAgICAgLy8gVmVjdG9yIGZyb20gc3BoZXJlIGNlbnRlciB0byBjb250YWN0IHBvaW50CgogICAgICByLm5pLnNjYWxlKHNpLnJhZGl1cywgci5yaSk7IC8vIFByb2plY3QgZG93biBzcGhlcmUgb24gcGxhbmUKCiAgICAgIHhpLnZzdWIoeGosIHBvaW50X29uX3BsYW5lX3RvX3NwaGVyZSk7CiAgICAgIHIubmkuc2NhbGUoci5uaS5kb3QocG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlKSwgcGxhbmVfdG9fc3BoZXJlX29ydGhvKTsKICAgICAgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlLnZzdWIocGxhbmVfdG9fc3BoZXJlX29ydGhvLCByLnJqKTsgLy8gVGhlIHNwaGVyZSBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gcGxhbmUKCiAgICAgIGlmICgtcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlLmRvdChyLm5pKSA8PSBzaS5yYWRpdXMpIHsKICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0gLy8gTWFrZSBpdCByZWxhdGl2ZSB0byB0aGUgYm9keQoKCiAgICAgICAgY29uc3QgcmkgPSByLnJpOwogICAgICAgIGNvbnN0IHJqID0gci5yajsKICAgICAgICByaS52YWRkKHhpLCByaSk7CiAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpOwogICAgICAgIHJqLnZhZGQoeGosIHJqKTsKICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7CiAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7CiAgICAgIH0KICAgIH0KCiAgICBib3hCb3goc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7CiAgICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNqLm1hdGVyaWFsOwogICAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTsKICAgICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2ouY29sbGlzaW9uUmVzcG9uc2U7CiAgICAgIHJldHVybiB0aGlzLmNvbnZleENvbnZleChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqLCBqdXN0VGVzdCk7CiAgICB9CgogICAgc3BoZXJlQm94KHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIGNvbnN0IHYzcG9vbCA9IHRoaXMudjNwb29sOyAvLyB3ZSByZWZlciB0byB0aGUgYm94IGFzIGJvZHkgagoKICAgICAgY29uc3Qgc2lkZXMgPSBzcGhlcmVCb3hfc2lkZXM7CiAgICAgIHhpLnZzdWIoeGosIGJveF90b19zcGhlcmUpOwogICAgICBzai5nZXRTaWRlTm9ybWFscyhzaWRlcywgcWopOwogICAgICBjb25zdCBSID0gc2kucmFkaXVzOwoKICAgICAgbGV0IGZvdW5kID0gZmFsc2U7IC8vIFN0b3JlIHRoZSByZXN1bHRpbmcgc2lkZSBwZW5ldHJhdGlvbiBpbmZvCgogICAgICBjb25zdCBzaWRlX25zID0gc3BoZXJlQm94X3NpZGVfbnM7CiAgICAgIGNvbnN0IHNpZGVfbnMxID0gc3BoZXJlQm94X3NpZGVfbnMxOwogICAgICBjb25zdCBzaWRlX25zMiA9IHNwaGVyZUJveF9zaWRlX25zMjsKICAgICAgbGV0IHNpZGVfaCA9IG51bGw7CiAgICAgIGxldCBzaWRlX3BlbmV0cmF0aW9ucyA9IDA7CiAgICAgIGxldCBzaWRlX2RvdDEgPSAwOwogICAgICBsZXQgc2lkZV9kb3QyID0gMDsKICAgICAgbGV0IHNpZGVfZGlzdGFuY2UgPSBudWxsOwoKICAgICAgZm9yIChsZXQgaWR4ID0gMCwgbnNpZGVzID0gc2lkZXMubGVuZ3RoOyBpZHggIT09IG5zaWRlcyAmJiBmb3VuZCA9PT0gZmFsc2U7IGlkeCsrKSB7CiAgICAgICAgLy8gR2V0IHRoZSBwbGFuZSBzaWRlIG5vcm1hbCAobnMpCiAgICAgICAgY29uc3QgbnMgPSBzcGhlcmVCb3hfbnM7CiAgICAgICAgbnMuY29weShzaWRlc1tpZHhdKTsKICAgICAgICBjb25zdCBoID0gbnMubGVuZ3RoKCk7CiAgICAgICAgbnMubm9ybWFsaXplKCk7IC8vIFRoZSBub3JtYWwvZGlzdGFuY2UgZG90IHByb2R1Y3QgdGVsbHMgd2hpY2ggc2lkZSBvZiB0aGUgcGxhbmUgd2UgYXJlCgogICAgICAgIGNvbnN0IGRvdCA9IGJveF90b19zcGhlcmUuZG90KG5zKTsKCiAgICAgICAgaWYgKGRvdCA8IGggKyBSICYmIGRvdCA+IDApIHsKICAgICAgICAgIC8vIEludGVyc2VjdHMgcGxhbmUuIE5vdyBjaGVjayB0aGUgb3RoZXIgdHdvIGRpbWVuc2lvbnMKICAgICAgICAgIGNvbnN0IG5zMSA9IHNwaGVyZUJveF9uczE7CiAgICAgICAgICBjb25zdCBuczIgPSBzcGhlcmVCb3hfbnMyOwogICAgICAgICAgbnMxLmNvcHkoc2lkZXNbKGlkeCArIDEpICUgM10pOwogICAgICAgICAgbnMyLmNvcHkoc2lkZXNbKGlkeCArIDIpICUgM10pOwogICAgICAgICAgY29uc3QgaDEgPSBuczEubGVuZ3RoKCk7CiAgICAgICAgICBjb25zdCBoMiA9IG5zMi5sZW5ndGgoKTsKICAgICAgICAgIG5zMS5ub3JtYWxpemUoKTsKICAgICAgICAgIG5zMi5ub3JtYWxpemUoKTsKICAgICAgICAgIGNvbnN0IGRvdDEgPSBib3hfdG9fc3BoZXJlLmRvdChuczEpOwogICAgICAgICAgY29uc3QgZG90MiA9IGJveF90b19zcGhlcmUuZG90KG5zMik7CgogICAgICAgICAgaWYgKGRvdDEgPCBoMSAmJiBkb3QxID4gLWgxICYmIGRvdDIgPCBoMiAmJiBkb3QyID4gLWgyKSB7CiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLmFicyhkb3QgLSBoIC0gUik7CgogICAgICAgICAgICBpZiAoc2lkZV9kaXN0YW5jZSA9PT0gbnVsbCB8fCBkaXN0IDwgc2lkZV9kaXN0YW5jZSkgewogICAgICAgICAgICAgIHNpZGVfZGlzdGFuY2UgPSBkaXN0OwogICAgICAgICAgICAgIHNpZGVfZG90MSA9IGRvdDE7CiAgICAgICAgICAgICAgc2lkZV9kb3QyID0gZG90MjsKICAgICAgICAgICAgICBzaWRlX2ggPSBoOwogICAgICAgICAgICAgIHNpZGVfbnMuY29weShucyk7CiAgICAgICAgICAgICAgc2lkZV9uczEuY29weShuczEpOwogICAgICAgICAgICAgIHNpZGVfbnMyLmNvcHkobnMyKTsKICAgICAgICAgICAgICBzaWRlX3BlbmV0cmF0aW9ucysrOwoKICAgICAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHNpZGVfcGVuZXRyYXRpb25zKSB7CiAgICAgICAgZm91bmQgPSB0cnVlOwogICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOwogICAgICAgIHNpZGVfbnMuc2NhbGUoLVIsIHIucmkpOyAvLyBTcGhlcmUgcgoKICAgICAgICByLm5pLmNvcHkoc2lkZV9ucyk7CiAgICAgICAgci5uaS5uZWdhdGUoci5uaSk7IC8vIE5vcm1hbCBzaG91bGQgYmUgb3V0IG9mIHNwaGVyZQoKICAgICAgICBzaWRlX25zLnNjYWxlKHNpZGVfaCwgc2lkZV9ucyk7CiAgICAgICAgc2lkZV9uczEuc2NhbGUoc2lkZV9kb3QxLCBzaWRlX25zMSk7CiAgICAgICAgc2lkZV9ucy52YWRkKHNpZGVfbnMxLCBzaWRlX25zKTsKICAgICAgICBzaWRlX25zMi5zY2FsZShzaWRlX2RvdDIsIHNpZGVfbnMyKTsKICAgICAgICBzaWRlX25zLnZhZGQoc2lkZV9uczIsIHIucmopOyAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllcwoKICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpOwogICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgci5yai52YWRkKHhqLCByLnJqKTsKICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopOwogICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICB9IC8vIENoZWNrIGNvcm5lcnMKCgogICAgICBsZXQgcmogPSB2M3Bvb2wuZ2V0KCk7CiAgICAgIGNvbnN0IHNwaGVyZV90b19jb3JuZXIgPSBzcGhlcmVCb3hfc3BoZXJlX3RvX2Nvcm5lcjsKCiAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSAyICYmICFmb3VuZDsgaisrKSB7CiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgIT09IDIgJiYgIWZvdW5kOyBrKyspIHsKICAgICAgICAgIGZvciAobGV0IGwgPSAwOyBsICE9PSAyICYmICFmb3VuZDsgbCsrKSB7CiAgICAgICAgICAgIHJqLnNldCgwLCAwLCAwKTsKCiAgICAgICAgICAgIGlmIChqKSB7CiAgICAgICAgICAgICAgcmoudmFkZChzaWRlc1swXSwgcmopOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJqLnZzdWIoc2lkZXNbMF0sIHJqKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKGspIHsKICAgICAgICAgICAgICByai52YWRkKHNpZGVzWzFdLCByaik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmoudnN1YihzaWRlc1sxXSwgcmopOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAobCkgewogICAgICAgICAgICAgIHJqLnZhZGQoc2lkZXNbMl0sIHJqKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByai52c3ViKHNpZGVzWzJdLCByaik7CiAgICAgICAgICAgIH0gLy8gV29ybGQgcG9zaXRpb24gb2YgY29ybmVyCgoKICAgICAgICAgICAgeGoudmFkZChyaiwgc3BoZXJlX3RvX2Nvcm5lcik7CiAgICAgICAgICAgIHNwaGVyZV90b19jb3JuZXIudnN1Yih4aSwgc3BoZXJlX3RvX2Nvcm5lcik7CgogICAgICAgICAgICBpZiAoc3BoZXJlX3RvX2Nvcm5lci5sZW5ndGhTcXVhcmVkKCkgPCBSICogUikgewogICAgICAgICAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7CiAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7CiAgICAgICAgICAgICAgci5yaS5jb3B5KHNwaGVyZV90b19jb3JuZXIpOwogICAgICAgICAgICAgIHIucmkubm9ybWFsaXplKCk7CiAgICAgICAgICAgICAgci5uaS5jb3B5KHIucmkpOwogICAgICAgICAgICAgIHIucmkuc2NhbGUoUiwgci5yaSk7CiAgICAgICAgICAgICAgci5yai5jb3B5KHJqKTsgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXMKCiAgICAgICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTsKICAgICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpOwogICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7CiAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTsKICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpOwogICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgdjNwb29sLnJlbGVhc2UocmopOwogICAgICByaiA9IG51bGw7IC8vIENoZWNrIGVkZ2VzCgogICAgICBjb25zdCBlZGdlVGFuZ2VudCA9IHYzcG9vbC5nZXQoKTsKICAgICAgY29uc3QgZWRnZUNlbnRlciA9IHYzcG9vbC5nZXQoKTsKICAgICAgY29uc3QgciA9IHYzcG9vbC5nZXQoKTsgLy8gciA9IGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBjZW50ZXIKCiAgICAgIGNvbnN0IG9ydGhvZ29uYWwgPSB2M3Bvb2wuZ2V0KCk7CiAgICAgIGNvbnN0IGRpc3QgPSB2M3Bvb2wuZ2V0KCk7CiAgICAgIGNvbnN0IE5zaWRlcyA9IHNpZGVzLmxlbmd0aDsKCiAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBOc2lkZXMgJiYgIWZvdW5kOyBqKyspIHsKICAgICAgICBmb3IgKGxldCBrID0gMDsgayAhPT0gTnNpZGVzICYmICFmb3VuZDsgaysrKSB7CiAgICAgICAgICBpZiAoaiAlIDMgIT09IGsgJSAzKSB7CiAgICAgICAgICAgIC8vIEdldCBlZGdlIHRhbmdlbnQKICAgICAgICAgICAgc2lkZXNba10uY3Jvc3Moc2lkZXNbal0sIGVkZ2VUYW5nZW50KTsKICAgICAgICAgICAgZWRnZVRhbmdlbnQubm9ybWFsaXplKCk7CiAgICAgICAgICAgIHNpZGVzW2pdLnZhZGQoc2lkZXNba10sIGVkZ2VDZW50ZXIpOwogICAgICAgICAgICByLmNvcHkoeGkpOwogICAgICAgICAgICByLnZzdWIoZWRnZUNlbnRlciwgcik7CiAgICAgICAgICAgIHIudnN1Yih4aiwgcik7CiAgICAgICAgICAgIGNvbnN0IG9ydGhvbm9ybSA9IHIuZG90KGVkZ2VUYW5nZW50KTsgLy8gZGlzdGFuY2UgZnJvbSBlZGdlIGNlbnRlciB0byBzcGhlcmUgY2VudGVyIGluIHRoZSB0YW5nZW50IGRpcmVjdGlvbgoKICAgICAgICAgICAgZWRnZVRhbmdlbnQuc2NhbGUob3J0aG9ub3JtLCBvcnRob2dvbmFsKTsgLy8gVmVjdG9yIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIGNlbnRlciBpbiB0aGUgdGFuZ2VudCBkaXJlY3Rpb24KICAgICAgICAgICAgLy8gRmluZCB0aGUgdGhpcmQgc2lkZSBvcnRob2dvbmFsIHRvIHRoaXMgb25lCgogICAgICAgICAgICBsZXQgbCA9IDA7CgogICAgICAgICAgICB3aGlsZSAobCA9PT0gaiAlIDMgfHwgbCA9PT0gayAlIDMpIHsKICAgICAgICAgICAgICBsKys7CiAgICAgICAgICAgIH0gLy8gdmVjIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIHByb2plY3RlZCB0byB0aGUgcGxhbmUgb3J0aG9nb25hbCB0byB0aGUgZWRnZSB0YW5nZW50CgoKICAgICAgICAgICAgZGlzdC5jb3B5KHhpKTsKICAgICAgICAgICAgZGlzdC52c3ViKG9ydGhvZ29uYWwsIGRpc3QpOwogICAgICAgICAgICBkaXN0LnZzdWIoZWRnZUNlbnRlciwgZGlzdCk7CiAgICAgICAgICAgIGRpc3QudnN1Yih4aiwgZGlzdCk7IC8vIERpc3RhbmNlcyBpbiB0YW5nZW50IGRpcmVjdGlvbiBhbmQgZGlzdGFuY2UgaW4gdGhlIHBsYW5lIG9ydGhvZ29uYWwgdG8gaXQKCiAgICAgICAgICAgIGNvbnN0IHRkaXN0ID0gTWF0aC5hYnMob3J0aG9ub3JtKTsKICAgICAgICAgICAgY29uc3QgbmRpc3QgPSBkaXN0Lmxlbmd0aCgpOwoKICAgICAgICAgICAgaWYgKHRkaXN0IDwgc2lkZXNbbF0ubGVuZ3RoKCkgJiYgbmRpc3QgPCBSKSB7CiAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTsKICAgICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOwogICAgICAgICAgICAgIGVkZ2VDZW50ZXIudmFkZChvcnRob2dvbmFsLCByZXMucmopOyAvLyBib3ggcmoKCiAgICAgICAgICAgICAgcmVzLnJqLmNvcHkocmVzLnJqKTsKICAgICAgICAgICAgICBkaXN0Lm5lZ2F0ZShyZXMubmkpOwogICAgICAgICAgICAgIHJlcy5uaS5ub3JtYWxpemUoKTsKICAgICAgICAgICAgICByZXMucmkuY29weShyZXMucmopOwogICAgICAgICAgICAgIHJlcy5yaS52YWRkKHhqLCByZXMucmkpOwogICAgICAgICAgICAgIHJlcy5yaS52c3ViKHhpLCByZXMucmkpOwogICAgICAgICAgICAgIHJlcy5yaS5ub3JtYWxpemUoKTsKICAgICAgICAgICAgICByZXMucmkuc2NhbGUoUiwgcmVzLnJpKTsgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXMKCiAgICAgICAgICAgICAgcmVzLnJpLnZhZGQoeGksIHJlcy5yaSk7CiAgICAgICAgICAgICAgcmVzLnJpLnZzdWIoYmkucG9zaXRpb24sIHJlcy5yaSk7CiAgICAgICAgICAgICAgcmVzLnJqLnZhZGQoeGosIHJlcy5yaik7CiAgICAgICAgICAgICAgcmVzLnJqLnZzdWIoYmoucG9zaXRpb24sIHJlcy5yaik7CiAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyZXMpOwogICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyZXMsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB2M3Bvb2wucmVsZWFzZShlZGdlVGFuZ2VudCwgZWRnZUNlbnRlciwgciwgb3J0aG9nb25hbCwgZGlzdCk7CiAgICB9CgogICAgcGxhbmVCb3goc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2oubWF0ZXJpYWw7CiAgICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNqLmNvbGxpc2lvblJlc3BvbnNlOwogICAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uaWQgPSBzai5pZDsKICAgICAgcmV0dXJuIHRoaXMucGxhbmVDb252ZXgoc2ksIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqLCBqdXN0VGVzdCk7CiAgICB9CgogICAgY29udmV4Q29udmV4KHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0LCBmYWNlTGlzdEEsIGZhY2VMaXN0QikgewogICAgICBjb25zdCBzZXBBeGlzID0gY29udmV4Q29udmV4X3NlcEF4aXM7CgogICAgICBpZiAoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBpZiAoc2kuZmluZFNlcGFyYXRpbmdBeGlzKHNqLCB4aSwgcWksIHhqLCBxaiwgc2VwQXhpcywgZmFjZUxpc3RBLCBmYWNlTGlzdEIpKSB7CiAgICAgICAgY29uc3QgcmVzID0gW107CiAgICAgICAgY29uc3QgcSA9IGNvbnZleENvbnZleF9xOwogICAgICAgIHNpLmNsaXBBZ2FpbnN0SHVsbCh4aSwgcWksIHNqLCB4aiwgcWosIHNlcEF4aXMsIC0xMDAsIDEwMCwgcmVzKTsKICAgICAgICBsZXQgbnVtQ29udGFjdHMgPSAwOwoKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiAhPT0gcmVzLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CgogICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7CiAgICAgICAgICBjb25zdCByaSA9IHIucmk7CiAgICAgICAgICBjb25zdCByaiA9IHIucmo7CiAgICAgICAgICBzZXBBeGlzLm5lZ2F0ZShyLm5pKTsKICAgICAgICAgIHJlc1tqXS5ub3JtYWwubmVnYXRlKHEpOwogICAgICAgICAgcS5zY2FsZShyZXNbal0uZGVwdGgsIHEpOwogICAgICAgICAgcmVzW2pdLnBvaW50LnZhZGQocSwgcmkpOwogICAgICAgICAgcmouY29weShyZXNbal0ucG9pbnQpOyAvLyBDb250YWN0IHBvaW50cyBhcmUgaW4gd29ybGQgY29vcmRpbmF0ZXMuIFRyYW5zZm9ybSBiYWNrIHRvIHJlbGF0aXZlCgogICAgICAgICAgcmkudnN1Yih4aSwgcmkpOwogICAgICAgICAgcmoudnN1Yih4aiwgcmopOyAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllcwoKICAgICAgICAgIHJpLnZhZGQoeGksIHJpKTsKICAgICAgICAgIHJpLnZzdWIoYmkucG9zaXRpb24sIHJpKTsKICAgICAgICAgIHJqLnZhZGQoeGosIHJqKTsKICAgICAgICAgIHJqLnZzdWIoYmoucG9zaXRpb24sIHJqKTsKICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgICBudW1Db250YWN0cysrOwoKICAgICAgICAgIGlmICghdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikgewogICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiAmJiBudW1Db250YWN0cykgewogICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBzcGhlcmVDb252ZXgoc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgY29uc3QgdjNwb29sID0gdGhpcy52M3Bvb2w7CiAgICAgIHhpLnZzdWIoeGosIGNvbnZleF90b19zcGhlcmUpOwogICAgICBjb25zdCBub3JtYWxzID0gc2ouZmFjZU5vcm1hbHM7CiAgICAgIGNvbnN0IGZhY2VzID0gc2ouZmFjZXM7CiAgICAgIGNvbnN0IHZlcnRzID0gc2oudmVydGljZXM7CiAgICAgIGNvbnN0IFIgPSBzaS5yYWRpdXM7CiAgICAgIC8vICAgICByZXR1cm47CiAgICAgIC8vIH0KCiAgICAgIGxldCBmb3VuZCA9IGZhbHNlOyAvLyBDaGVjayBjb3JuZXJzCgogICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gdmVydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCB2ID0gdmVydHNbaV07IC8vIFdvcmxkIHBvc2l0aW9uIG9mIGNvcm5lcgoKICAgICAgICBjb25zdCB3b3JsZENvcm5lciA9IHNwaGVyZUNvbnZleF93b3JsZENvcm5lcjsKICAgICAgICBxai52bXVsdCh2LCB3b3JsZENvcm5lcik7CiAgICAgICAgeGoudmFkZCh3b3JsZENvcm5lciwgd29ybGRDb3JuZXIpOwogICAgICAgIGNvbnN0IHNwaGVyZV90b19jb3JuZXIgPSBzcGhlcmVDb252ZXhfc3BoZXJlVG9Db3JuZXI7CiAgICAgICAgd29ybGRDb3JuZXIudnN1Yih4aSwgc3BoZXJlX3RvX2Nvcm5lcik7CgogICAgICAgIGlmIChzcGhlcmVfdG9fY29ybmVyLmxlbmd0aFNxdWFyZWQoKSA8IFIgKiBSKSB7CiAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CgogICAgICAgICAgZm91bmQgPSB0cnVlOwogICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7CiAgICAgICAgICByLnJpLmNvcHkoc3BoZXJlX3RvX2Nvcm5lcik7CiAgICAgICAgICByLnJpLm5vcm1hbGl6ZSgpOwogICAgICAgICAgci5uaS5jb3B5KHIucmkpOwogICAgICAgICAgci5yaS5zY2FsZShSLCByLnJpKTsKICAgICAgICAgIHdvcmxkQ29ybmVyLnZzdWIoeGosIHIucmopOyAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuCgogICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTsKICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7IC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS4KCiAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopOwogICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTsKICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICB9IC8vIENoZWNrIHNpZGUgKHBsYW5lKSBpbnRlcnNlY3Rpb25zCgoKICAgICAgZm9yIChsZXQgaSA9IDAsIG5mYWNlcyA9IGZhY2VzLmxlbmd0aDsgaSAhPT0gbmZhY2VzICYmIGZvdW5kID09PSBmYWxzZTsgaSsrKSB7CiAgICAgICAgY29uc3Qgbm9ybWFsID0gbm9ybWFsc1tpXTsKICAgICAgICBjb25zdCBmYWNlID0gZmFjZXNbaV07IC8vIEdldCB3b3JsZC10cmFuc2Zvcm1lZCBub3JtYWwgb2YgdGhlIGZhY2UKCiAgICAgICAgY29uc3Qgd29ybGROb3JtYWwgPSBzcGhlcmVDb252ZXhfd29ybGROb3JtYWw7CiAgICAgICAgcWoudm11bHQobm9ybWFsLCB3b3JsZE5vcm1hbCk7IC8vIEdldCBhIHdvcmxkIHZlcnRleCBmcm9tIHRoZSBmYWNlCgogICAgICAgIGNvbnN0IHdvcmxkUG9pbnQgPSBzcGhlcmVDb252ZXhfd29ybGRQb2ludDsKICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWzBdXSwgd29ybGRQb2ludCk7CiAgICAgICAgd29ybGRQb2ludC52YWRkKHhqLCB3b3JsZFBvaW50KTsgLy8gR2V0IGEgcG9pbnQgb24gdGhlIHNwaGVyZSwgY2xvc2VzdCB0byB0aGUgZmFjZSBub3JtYWwKCiAgICAgICAgY29uc3Qgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lID0gc3BoZXJlQ29udmV4X3dvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZTsKICAgICAgICB3b3JsZE5vcm1hbC5zY2FsZSgtUiwgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lKTsKICAgICAgICB4aS52YWRkKHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSwgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lKTsgLy8gVmVjdG9yIGZyb20gYSBmYWNlIHBvaW50IHRvIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzcGhlcmUKCiAgICAgICAgY29uc3QgcGVuZXRyYXRpb25WZWMgPSBzcGhlcmVDb252ZXhfcGVuZXRyYXRpb25WZWM7CiAgICAgICAgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lLnZzdWIod29ybGRQb2ludCwgcGVuZXRyYXRpb25WZWMpOyAvLyBUaGUgcGVuZXRyYXRpb24uIE5lZ2F0aXZlIHZhbHVlIG1lYW5zIG92ZXJsYXAuCgogICAgICAgIGNvbnN0IHBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb25WZWMuZG90KHdvcmxkTm9ybWFsKTsKICAgICAgICBjb25zdCB3b3JsZFBvaW50VG9TcGhlcmUgPSBzcGhlcmVDb252ZXhfc3BoZXJlVG9Xb3JsZFBvaW50OwogICAgICAgIHhpLnZzdWIod29ybGRQb2ludCwgd29ybGRQb2ludFRvU3BoZXJlKTsKCiAgICAgICAgaWYgKHBlbmV0cmF0aW9uIDwgMCAmJiB3b3JsZFBvaW50VG9TcGhlcmUuZG90KHdvcmxkTm9ybWFsKSA+IDApIHsKICAgICAgICAgIC8vIEludGVyc2VjdHMgcGxhbmUuIE5vdyBjaGVjayBpZiB0aGUgc3BoZXJlIGlzIGluc2lkZSB0aGUgZmFjZSBwb2x5Z29uCiAgICAgICAgICBjb25zdCBmYWNlVmVydHMgPSBbXTsgLy8gRmFjZSB2ZXJ0aWNlcywgaW4gd29ybGQgY29vcmRzCgogICAgICAgICAgZm9yIChsZXQgaiA9IDAsIE52ZXJ0cyA9IGZhY2UubGVuZ3RoOyBqICE9PSBOdmVydHM7IGorKykgewogICAgICAgICAgICBjb25zdCB3b3JsZFZlcnRleCA9IHYzcG9vbC5nZXQoKTsKICAgICAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVtqXV0sIHdvcmxkVmVydGV4KTsKICAgICAgICAgICAgeGoudmFkZCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgpOwogICAgICAgICAgICBmYWNlVmVydHMucHVzaCh3b3JsZFZlcnRleCk7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKHBvaW50SW5Qb2x5Z29uKGZhY2VWZXJ0cywgd29ybGROb3JtYWwsIHhpKSkgewogICAgICAgICAgICAvLyBJcyB0aGUgc3BoZXJlIGNlbnRlciBpbiB0aGUgZmFjZSBwb2x5Z29uPwogICAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZm91bmQgPSB0cnVlOwogICAgICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKTsKICAgICAgICAgICAgd29ybGROb3JtYWwuc2NhbGUoLVIsIHIucmkpOyAvLyBDb250YWN0IG9mZnNldCwgZnJvbSBzcGhlcmUgY2VudGVyIHRvIGNvbnRhY3QKCiAgICAgICAgICAgIHdvcmxkTm9ybWFsLm5lZ2F0ZShyLm5pKTsgLy8gTm9ybWFsIHBvaW50aW5nIG91dCBvZiBzcGhlcmUKCiAgICAgICAgICAgIGNvbnN0IHBlbmV0cmF0aW9uVmVjMiA9IHYzcG9vbC5nZXQoKTsKICAgICAgICAgICAgd29ybGROb3JtYWwuc2NhbGUoLXBlbmV0cmF0aW9uLCBwZW5ldHJhdGlvblZlYzIpOwogICAgICAgICAgICBjb25zdCBwZW5ldHJhdGlvblNwaGVyZVBvaW50ID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICB3b3JsZE5vcm1hbC5zY2FsZSgtUiwgcGVuZXRyYXRpb25TcGhlcmVQb2ludCk7IC8veGkudnN1Yih4aikudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50KS52YWRkKHBlbmV0cmF0aW9uVmVjMiAsIHIucmopOwoKICAgICAgICAgICAgeGkudnN1Yih4aiwgci5yaik7CiAgICAgICAgICAgIHIucmoudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50LCByLnJqKTsKICAgICAgICAgICAgci5yai52YWRkKHBlbmV0cmF0aW9uVmVjMiwgci5yaik7IC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS4KCiAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7CiAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7IC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS4KCiAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7CiAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHBlbmV0cmF0aW9uVmVjMik7CiAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQpOwogICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpOwogICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7IC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXMKCiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBOZmFjZXZlcnRzID0gZmFjZVZlcnRzLmxlbmd0aDsgaiAhPT0gTmZhY2V2ZXJ0czsgaisrKSB7CiAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoZmFjZVZlcnRzW2pdKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBvbmx5IGV4cGVjdCAqb25lKiBmYWNlIGNvbnRhY3QKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIEVkZ2U/CiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBmYWNlLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICAgICAgLy8gR2V0IHR3byB3b3JsZCB0cmFuc2Zvcm1lZCB2ZXJ0aWNlcwogICAgICAgICAgICAgIGNvbnN0IHYxID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICAgIGNvbnN0IHYyID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICAgIHFqLnZtdWx0KHZlcnRzW2ZhY2VbKGogKyAxKSAlIGZhY2UubGVuZ3RoXV0sIHYxKTsKICAgICAgICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWyhqICsgMikgJSBmYWNlLmxlbmd0aF1dLCB2Mik7CiAgICAgICAgICAgICAgeGoudmFkZCh2MSwgdjEpOwogICAgICAgICAgICAgIHhqLnZhZGQodjIsIHYyKTsgLy8gQ29uc3RydWN0IGVkZ2UgdmVjdG9yCgogICAgICAgICAgICAgIGNvbnN0IGVkZ2UgPSBzcGhlcmVDb252ZXhfZWRnZTsKICAgICAgICAgICAgICB2Mi52c3ViKHYxLCBlZGdlKTsgLy8gQ29uc3RydWN0IHRoZSBzYW1lIHZlY3RvciwgYnV0IG5vcm1hbGl6ZWQKCiAgICAgICAgICAgICAgY29uc3QgZWRnZVVuaXQgPSBzcGhlcmVDb252ZXhfZWRnZVVuaXQ7CiAgICAgICAgICAgICAgZWRnZS51bml0KGVkZ2VVbml0KTsgLy8gcCBpcyB4aSBwcm9qZWN0ZWQgb250byB0aGUgZWRnZQoKICAgICAgICAgICAgICBjb25zdCBwID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICAgIGNvbnN0IHYxX3RvX3hpID0gdjNwb29sLmdldCgpOwogICAgICAgICAgICAgIHhpLnZzdWIodjEsIHYxX3RvX3hpKTsKICAgICAgICAgICAgICBjb25zdCBkb3QgPSB2MV90b194aS5kb3QoZWRnZVVuaXQpOwogICAgICAgICAgICAgIGVkZ2VVbml0LnNjYWxlKGRvdCwgcCk7CiAgICAgICAgICAgICAgcC52YWRkKHYxLCBwKTsgLy8gQ29tcHV0ZSBhIHZlY3RvciBmcm9tIHAgdG8gdGhlIGNlbnRlciBvZiB0aGUgc3BoZXJlCgogICAgICAgICAgICAgIGNvbnN0IHhpX3RvX3AgPSB2M3Bvb2wuZ2V0KCk7CiAgICAgICAgICAgICAgcC52c3ViKHhpLCB4aV90b19wKTsgLy8gQ29sbGlzaW9uIGlmIHRoZSBlZGdlLXNwaGVyZSBkaXN0YW5jZSBpcyBsZXNzIHRoYW4gdGhlIHJhZGl1cwogICAgICAgICAgICAgIC8vIEFORCBpZiBwIGlzIGluIGJldHdlZW4gdjEgYW5kIHYyCgogICAgICAgICAgICAgIGlmIChkb3QgPiAwICYmIGRvdCAqIGRvdCA8IGVkZ2UubGVuZ3RoU3F1YXJlZCgpICYmIHhpX3RvX3AubGVuZ3RoU3F1YXJlZCgpIDwgUiAqIFIpIHsKICAgICAgICAgICAgICAgIC8vIENvbGxpc2lvbiBpZiB0aGUgZWRnZS1zcGhlcmUgZGlzdGFuY2UgaXMgbGVzcyB0aGFuIHRoZSByYWRpdXMKICAgICAgICAgICAgICAgIC8vIEVkZ2UgY29udGFjdCEKICAgICAgICAgICAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKTsKICAgICAgICAgICAgICAgIHAudnN1Yih4aiwgci5yaik7CiAgICAgICAgICAgICAgICBwLnZzdWIoeGksIHIubmkpOwogICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTsKICAgICAgICAgICAgICAgIHIubmkuc2NhbGUoUiwgci5yaSk7IC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS4KCiAgICAgICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopOwogICAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTsgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LgoKICAgICAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7CiAgICAgICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpOwogICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsgLy8gUmVsZWFzZSB3b3JsZCB2ZXJ0aWNlcwoKICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBOZmFjZXZlcnRzID0gZmFjZVZlcnRzLmxlbmd0aDsgaiAhPT0gTmZhY2V2ZXJ0czsgaisrKSB7CiAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjEpOwogICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjIpOwogICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UocCk7CiAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh4aV90b19wKTsKICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxX3RvX3hpKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxKTsKICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2Mik7CiAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UocCk7CiAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoeGlfdG9fcCk7CiAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjFfdG9feGkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXMKCgogICAgICAgICAgZm9yIChsZXQgaiA9IDAsIE5mYWNldmVydHMgPSBmYWNlVmVydHMubGVuZ3RoOyBqICE9PSBOZmFjZXZlcnRzOyBqKyspIHsKICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoZmFjZVZlcnRzW2pdKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBwbGFuZUNvbnZleChwbGFuZVNoYXBlLCBjb252ZXhTaGFwZSwgcGxhbmVQb3NpdGlvbiwgY29udmV4UG9zaXRpb24sIHBsYW5lUXVhdCwgY29udmV4UXVhdCwgcGxhbmVCb2R5LCBjb252ZXhCb2R5LCBzaSwgc2osIGp1c3RUZXN0KSB7CiAgICAgIC8vIFNpbXBseSByZXR1cm4gdGhlIHBvaW50cyBiZWhpbmQgdGhlIHBsYW5lLgogICAgICBjb25zdCB3b3JsZFZlcnRleCA9IHBsYW5lQ29udmV4X3Y7CiAgICAgIGNvbnN0IHdvcmxkTm9ybWFsID0gcGxhbmVDb252ZXhfbm9ybWFsOwogICAgICB3b3JsZE5vcm1hbC5zZXQoMCwgMCwgMSk7CiAgICAgIHBsYW5lUXVhdC52bXVsdCh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwpOyAvLyBUdXJuIG5vcm1hbCBhY2NvcmRpbmcgdG8gcGxhbmUgb3JpZW50YXRpb24KCiAgICAgIGxldCBudW1Db250YWN0cyA9IDA7CiAgICAgIGNvbnN0IHJlbHBvcyA9IHBsYW5lQ29udmV4X3JlbHBvczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBjb252ZXhTaGFwZS52ZXJ0aWNlcy5sZW5ndGg7IGkrKykgewogICAgICAgIC8vIEdldCB3b3JsZCBjb252ZXggdmVydGV4CiAgICAgICAgd29ybGRWZXJ0ZXguY29weShjb252ZXhTaGFwZS52ZXJ0aWNlc1tpXSk7CiAgICAgICAgY29udmV4UXVhdC52bXVsdCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgpOwogICAgICAgIGNvbnZleFBvc2l0aW9uLnZhZGQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4KTsKICAgICAgICB3b3JsZFZlcnRleC52c3ViKHBsYW5lUG9zaXRpb24sIHJlbHBvcyk7CiAgICAgICAgY29uc3QgZG90ID0gd29ybGROb3JtYWwuZG90KHJlbHBvcyk7CgogICAgICAgIGlmIChkb3QgPD0gMC4wKSB7CiAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CgogICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSwgY29udmV4Qm9keSwgcGxhbmVTaGFwZSwgY29udmV4U2hhcGUsIHNpLCBzaik7IC8vIEdldCB2ZXJ0ZXggcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lCgogICAgICAgICAgY29uc3QgcHJvamVjdGVkID0gcGxhbmVDb252ZXhfcHJvamVjdGVkOwogICAgICAgICAgd29ybGROb3JtYWwuc2NhbGUod29ybGROb3JtYWwuZG90KHJlbHBvcyksIHByb2plY3RlZCk7CiAgICAgICAgICB3b3JsZFZlcnRleC52c3ViKHByb2plY3RlZCwgcHJvamVjdGVkKTsKICAgICAgICAgIHByb2plY3RlZC52c3ViKHBsYW5lUG9zaXRpb24sIHIucmkpOyAvLyBGcm9tIHBsYW5lIHRvIHZlcnRleCBwcm9qZWN0ZWQgb24gcGxhbmUKCiAgICAgICAgICByLm5pLmNvcHkod29ybGROb3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbCBpcyB0aGUgcGxhbmUgbm9ybWFsIG91dCBmcm9tIHBsYW5lCiAgICAgICAgICAvLyByaiBpcyBub3cganVzdCB0aGUgdmVjdG9yIGZyb20gdGhlIGNvbnZleCBjZW50ZXIgdG8gdGhlIHZlcnRleAoKICAgICAgICAgIHdvcmxkVmVydGV4LnZzdWIoY29udmV4UG9zaXRpb24sIHIucmopOyAvLyBNYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSBib2R5CgogICAgICAgICAgci5yaS52YWRkKHBsYW5lUG9zaXRpb24sIHIucmkpOwogICAgICAgICAgci5yaS52c3ViKHBsYW5lQm9keS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgICByLnJqLnZhZGQoY29udmV4UG9zaXRpb24sIHIucmopOwogICAgICAgICAgci5yai52c3ViKGNvbnZleEJvZHkucG9zaXRpb24sIHIucmopOwogICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgIG51bUNvbnRhY3RzKys7CgogICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7CiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uICYmIG51bUNvbnRhY3RzKSB7CiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKTsKICAgICAgfQogICAgfQoKICAgIGJveENvbnZleChzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDsKICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7CiAgICAgIHJldHVybiB0aGlzLmNvbnZleENvbnZleChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTsKICAgIH0KCiAgICBzcGhlcmVIZWlnaHRmaWVsZChzcGhlcmVTaGFwZSwgaGZTaGFwZSwgc3BoZXJlUG9zLCBoZlBvcywgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBjb25zdCBkYXRhID0gaGZTaGFwZS5kYXRhOwogICAgICBjb25zdCByYWRpdXMgPSBzcGhlcmVTaGFwZS5yYWRpdXM7CiAgICAgIGNvbnN0IHcgPSBoZlNoYXBlLmVsZW1lbnRTaXplOwogICAgICBjb25zdCB3b3JsZFBpbGxhck9mZnNldCA9IHNwaGVyZUhlaWdodGZpZWxkX3RtcDI7IC8vIEdldCBzcGhlcmUgcG9zaXRpb24gdG8gaGVpZ2h0ZmllbGQgbG9jYWwhCgogICAgICBjb25zdCBsb2NhbFNwaGVyZVBvcyA9IHNwaGVyZUhlaWdodGZpZWxkX3RtcDE7CiAgICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShoZlBvcywgaGZRdWF0LCBzcGhlcmVQb3MsIGxvY2FsU3BoZXJlUG9zKTsgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0CgogICAgICBsZXQgaU1pblggPSBNYXRoLmZsb29yKChsb2NhbFNwaGVyZVBvcy54IC0gcmFkaXVzKSAvIHcpIC0gMTsKICAgICAgbGV0IGlNYXhYID0gTWF0aC5jZWlsKChsb2NhbFNwaGVyZVBvcy54ICsgcmFkaXVzKSAvIHcpICsgMTsKICAgICAgbGV0IGlNaW5ZID0gTWF0aC5mbG9vcigobG9jYWxTcGhlcmVQb3MueSAtIHJhZGl1cykgLyB3KSAtIDE7CiAgICAgIGxldCBpTWF4WSA9IE1hdGguY2VpbCgobG9jYWxTcGhlcmVQb3MueSArIHJhZGl1cykgLyB3KSArIDE7IC8vIEJhaWwgb3V0IGlmIHdlIGFyZSBvdXQgb2YgdGhlIHRlcnJhaW4KCiAgICAgIGlmIChpTWF4WCA8IDAgfHwgaU1heFkgPCAwIHx8IGlNaW5YID4gZGF0YS5sZW5ndGggfHwgaU1pblkgPiBkYXRhWzBdLmxlbmd0aCkgewogICAgICAgIHJldHVybjsKICAgICAgfSAvLyBDbGFtcCBpbmRleCB0byBlZGdlcwoKCiAgICAgIGlmIChpTWluWCA8IDApIHsKICAgICAgICBpTWluWCA9IDA7CiAgICAgIH0KCiAgICAgIGlmIChpTWF4WCA8IDApIHsKICAgICAgICBpTWF4WCA9IDA7CiAgICAgIH0KCiAgICAgIGlmIChpTWluWSA8IDApIHsKICAgICAgICBpTWluWSA9IDA7CiAgICAgIH0KCiAgICAgIGlmIChpTWF4WSA8IDApIHsKICAgICAgICBpTWF4WSA9IDA7CiAgICAgIH0KCiAgICAgIGlmIChpTWluWCA+PSBkYXRhLmxlbmd0aCkgewogICAgICAgIGlNaW5YID0gZGF0YS5sZW5ndGggLSAxOwogICAgICB9CgogICAgICBpZiAoaU1heFggPj0gZGF0YS5sZW5ndGgpIHsKICAgICAgICBpTWF4WCA9IGRhdGEubGVuZ3RoIC0gMTsKICAgICAgfQoKICAgICAgaWYgKGlNYXhZID49IGRhdGFbMF0ubGVuZ3RoKSB7CiAgICAgICAgaU1heFkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7CiAgICAgIH0KCiAgICAgIGlmIChpTWluWSA+PSBkYXRhWzBdLmxlbmd0aCkgewogICAgICAgIGlNaW5ZID0gZGF0YVswXS5sZW5ndGggLSAxOwogICAgICB9CgogICAgICBjb25zdCBtaW5NYXggPSBbXTsKICAgICAgaGZTaGFwZS5nZXRSZWN0TWluTWF4KGlNaW5YLCBpTWluWSwgaU1heFgsIGlNYXhZLCBtaW5NYXgpOwogICAgICBjb25zdCBtaW4gPSBtaW5NYXhbMF07CiAgICAgIGNvbnN0IG1heCA9IG1pbk1heFsxXTsgLy8gQmFpbCBvdXQgaWYgd2UgY2FuJ3QgdG91Y2ggdGhlIGJvdW5kaW5nIGhlaWdodCBib3gKCiAgICAgIGlmIChsb2NhbFNwaGVyZVBvcy56IC0gcmFkaXVzID4gbWF4IHx8IGxvY2FsU3BoZXJlUG9zLnogKyByYWRpdXMgPCBtaW4pIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0OwoKICAgICAgZm9yIChsZXQgaSA9IGlNaW5YOyBpIDwgaU1heFg7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSBpTWluWTsgaiA8IGlNYXhZOyBqKyspIHsKICAgICAgICAgIGNvbnN0IG51bUNvbnRhY3RzQmVmb3JlID0gcmVzdWx0Lmxlbmd0aDsKICAgICAgICAgIGxldCBpbnRlcnNlY3RpbmcgPSBmYWxzZTsgLy8gTG93ZXIgdHJpYW5nbGUKCiAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTsKICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpOwoKICAgICAgICAgIGlmIChzcGhlcmVQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNwaGVyZVNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgICAgIGludGVyc2VjdGluZyA9IHRoaXMuc3BoZXJlQ29udmV4KHNwaGVyZVNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgc3BoZXJlUG9zLCB3b3JsZFBpbGxhck9mZnNldCwgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHksIHNwaGVyZVNoYXBlLCBoZlNoYXBlLCBqdXN0VGVzdCk7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGp1c3RUZXN0ICYmIGludGVyc2VjdGluZykgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0gLy8gVXBwZXIgdHJpYW5nbGUKCgogICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCB0cnVlKTsKICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpOwoKICAgICAgICAgIGlmIChzcGhlcmVQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNwaGVyZVNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7CiAgICAgICAgICAgIGludGVyc2VjdGluZyA9IHRoaXMuc3BoZXJlQ29udmV4KHNwaGVyZVNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgc3BoZXJlUG9zLCB3b3JsZFBpbGxhck9mZnNldCwgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHksIHNwaGVyZVNoYXBlLCBoZlNoYXBlLCBqdXN0VGVzdCk7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGp1c3RUZXN0ICYmIGludGVyc2VjdGluZykgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KCiAgICAgICAgICBjb25zdCBudW1Db250YWN0cyA9IHJlc3VsdC5sZW5ndGggLSBudW1Db250YWN0c0JlZm9yZTsKCiAgICAgICAgICBpZiAobnVtQ29udGFjdHMgPiAyKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIC8qCiAgICAgICAgICAgIC8vIFNraXAgYWxsIGJ1dCAxCiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbnVtQ29udGFjdHMgLSAxOyBrKyspIHsKICAgICAgICAgICAgICAgIHJlc3VsdC5wb3AoKTsKICAgICAgICAgICAgfQogICAgICAgICAgKi8KCiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgYm94SGVpZ2h0ZmllbGQoc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7CiAgICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlOwogICAgICByZXR1cm4gdGhpcy5jb252ZXhIZWlnaHRmaWVsZChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTsKICAgIH0KCiAgICBjb252ZXhIZWlnaHRmaWVsZChjb252ZXhTaGFwZSwgaGZTaGFwZSwgY29udmV4UG9zLCBoZlBvcywgY29udmV4UXVhdCwgaGZRdWF0LCBjb252ZXhCb2R5LCBoZkJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBjb25zdCBkYXRhID0gaGZTaGFwZS5kYXRhOwogICAgICBjb25zdCB3ID0gaGZTaGFwZS5lbGVtZW50U2l6ZTsKICAgICAgY29uc3QgcmFkaXVzID0gY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXM7CiAgICAgIGNvbnN0IHdvcmxkUGlsbGFyT2Zmc2V0ID0gY29udmV4SGVpZ2h0ZmllbGRfdG1wMjsKICAgICAgY29uc3QgZmFjZUxpc3QgPSBjb252ZXhIZWlnaHRmaWVsZF9mYWNlTGlzdDsgLy8gR2V0IHNwaGVyZSBwb3NpdGlvbiB0byBoZWlnaHRmaWVsZCBsb2NhbCEKCiAgICAgIGNvbnN0IGxvY2FsQ29udmV4UG9zID0gY29udmV4SGVpZ2h0ZmllbGRfdG1wMTsKICAgICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKGhmUG9zLCBoZlF1YXQsIGNvbnZleFBvcywgbG9jYWxDb252ZXhQb3MpOyAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3QKCiAgICAgIGxldCBpTWluWCA9IE1hdGguZmxvb3IoKGxvY2FsQ29udmV4UG9zLnggLSByYWRpdXMpIC8gdykgLSAxOwogICAgICBsZXQgaU1heFggPSBNYXRoLmNlaWwoKGxvY2FsQ29udmV4UG9zLnggKyByYWRpdXMpIC8gdykgKyAxOwogICAgICBsZXQgaU1pblkgPSBNYXRoLmZsb29yKChsb2NhbENvbnZleFBvcy55IC0gcmFkaXVzKSAvIHcpIC0gMTsKICAgICAgbGV0IGlNYXhZID0gTWF0aC5jZWlsKChsb2NhbENvbnZleFBvcy55ICsgcmFkaXVzKSAvIHcpICsgMTsgLy8gQmFpbCBvdXQgaWYgd2UgYXJlIG91dCBvZiB0aGUgdGVycmFpbgoKICAgICAgaWYgKGlNYXhYIDwgMCB8fCBpTWF4WSA8IDAgfHwgaU1pblggPiBkYXRhLmxlbmd0aCB8fCBpTWluWSA+IGRhdGFbMF0ubGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9IC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzCgoKICAgICAgaWYgKGlNaW5YIDwgMCkgewogICAgICAgIGlNaW5YID0gMDsKICAgICAgfQoKICAgICAgaWYgKGlNYXhYIDwgMCkgewogICAgICAgIGlNYXhYID0gMDsKICAgICAgfQoKICAgICAgaWYgKGlNaW5ZIDwgMCkgewogICAgICAgIGlNaW5ZID0gMDsKICAgICAgfQoKICAgICAgaWYgKGlNYXhZIDwgMCkgewogICAgICAgIGlNYXhZID0gMDsKICAgICAgfQoKICAgICAgaWYgKGlNaW5YID49IGRhdGEubGVuZ3RoKSB7CiAgICAgICAgaU1pblggPSBkYXRhLmxlbmd0aCAtIDE7CiAgICAgIH0KCiAgICAgIGlmIChpTWF4WCA+PSBkYXRhLmxlbmd0aCkgewogICAgICAgIGlNYXhYID0gZGF0YS5sZW5ndGggLSAxOwogICAgICB9CgogICAgICBpZiAoaU1heFkgPj0gZGF0YVswXS5sZW5ndGgpIHsKICAgICAgICBpTWF4WSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsKICAgICAgfQoKICAgICAgaWYgKGlNaW5ZID49IGRhdGFbMF0ubGVuZ3RoKSB7CiAgICAgICAgaU1pblkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7CiAgICAgIH0KCiAgICAgIGNvbnN0IG1pbk1heCA9IFtdOwogICAgICBoZlNoYXBlLmdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIG1pbk1heCk7CiAgICAgIGNvbnN0IG1pbiA9IG1pbk1heFswXTsKICAgICAgY29uc3QgbWF4ID0gbWluTWF4WzFdOyAvLyBCYWlsIG91dCBpZiB3ZSdyZSBjYW50IHRvdWNoIHRoZSBib3VuZGluZyBoZWlnaHQgYm94CgogICAgICBpZiAobG9jYWxDb252ZXhQb3MueiAtIHJhZGl1cyA+IG1heCB8fCBsb2NhbENvbnZleFBvcy56ICsgcmFkaXVzIDwgbWluKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBmb3IgKGxldCBpID0gaU1pblg7IGkgPCBpTWF4WDsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IGlNaW5ZOyBqIDwgaU1heFk7IGorKykgewogICAgICAgICAgbGV0IGludGVyc2VjdGluZyA9IGZhbHNlOyAvLyBMb3dlciB0cmlhbmdsZQoKICAgICAgICAgIGhmU2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgZmFsc2UpOwogICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7CgogICAgICAgICAgaWYgKGNvbnZleFBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHsKICAgICAgICAgICAgaW50ZXJzZWN0aW5nID0gdGhpcy5jb252ZXhDb252ZXgoY29udmV4U2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBjb252ZXhQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBjb252ZXhRdWF0LCBoZlF1YXQsIGNvbnZleEJvZHksIGhmQm9keSwgbnVsbCwgbnVsbCwganVzdFRlc3QsIGZhY2VMaXN0LCBudWxsKTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoanVzdFRlc3QgJiYgaW50ZXJzZWN0aW5nKSB7CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfSAvLyBVcHBlciB0cmlhbmdsZQoKCiAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIHRydWUpOwogICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7CgogICAgICAgICAgaWYgKGNvbnZleFBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHsKICAgICAgICAgICAgaW50ZXJzZWN0aW5nID0gdGhpcy5jb252ZXhDb252ZXgoY29udmV4U2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBjb252ZXhQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBjb252ZXhRdWF0LCBoZlF1YXQsIGNvbnZleEJvZHksIGhmQm9keSwgbnVsbCwgbnVsbCwganVzdFRlc3QsIGZhY2VMaXN0LCBudWxsKTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoanVzdFRlc3QgJiYgaW50ZXJzZWN0aW5nKSB7CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQoKICAgIHNwaGVyZVBhcnRpY2xlKHNqLCBzaSwgeGosIHhpLCBxaiwgcWksIGJqLCBiaSwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIC8vIFRoZSBub3JtYWwgaXMgdGhlIHVuaXQgdmVjdG9yIGZyb20gc3BoZXJlIGNlbnRlciB0byBwYXJ0aWNsZSBjZW50ZXIKICAgICAgY29uc3Qgbm9ybWFsID0gcGFydGljbGVTcGhlcmVfbm9ybWFsOwogICAgICBub3JtYWwuc2V0KDAsIDAsIDEpOwogICAgICB4aS52c3ViKHhqLCBub3JtYWwpOwogICAgICBjb25zdCBsZW5ndGhTcXVhcmVkID0gbm9ybWFsLmxlbmd0aFNxdWFyZWQoKTsKCiAgICAgIGlmIChsZW5ndGhTcXVhcmVkIDw9IHNqLnJhZGl1cyAqIHNqLnJhZGl1cykgewogICAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQoKICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKTsKICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7CiAgICAgICAgci5yai5jb3B5KG5vcm1hbCk7CiAgICAgICAgci5yai5zY2FsZShzai5yYWRpdXMsIHIucmopOwogICAgICAgIHIubmkuY29weShub3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbAoKICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTsKICAgICAgICByLnJpLnNldCgwLCAwLCAwKTsgLy8gQ2VudGVyIG9mIHBhcnRpY2xlCgogICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICB9CiAgICB9CgogICAgcGxhbmVQYXJ0aWNsZShzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBjb25zdCBub3JtYWwgPSBwYXJ0aWNsZVBsYW5lX25vcm1hbDsKICAgICAgbm9ybWFsLnNldCgwLCAwLCAxKTsKICAgICAgYmoucXVhdGVybmlvbi52bXVsdChub3JtYWwsIG5vcm1hbCk7IC8vIFR1cm4gbm9ybWFsIGFjY29yZGluZyB0byBwbGFuZSBvcmllbnRhdGlvbgoKICAgICAgY29uc3QgcmVscG9zID0gcGFydGljbGVQbGFuZV9yZWxwb3M7CiAgICAgIHhpLnZzdWIoYmoucG9zaXRpb24sIHJlbHBvcyk7CiAgICAgIGNvbnN0IGRvdCA9IG5vcm1hbC5kb3QocmVscG9zKTsKCiAgICAgIGlmIChkb3QgPD0gMC4wKSB7CiAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CgogICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOwogICAgICAgIHIubmkuY29weShub3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbCBpcyB0aGUgcGxhbmUgbm9ybWFsCgogICAgICAgIHIubmkubmVnYXRlKHIubmkpOwogICAgICAgIHIucmkuc2V0KDAsIDAsIDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGUKICAgICAgICAvLyBHZXQgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lCgogICAgICAgIGNvbnN0IHByb2plY3RlZCA9IHBhcnRpY2xlUGxhbmVfcHJvamVjdGVkOwogICAgICAgIG5vcm1hbC5zY2FsZShub3JtYWwuZG90KHhpKSwgcHJvamVjdGVkKTsKICAgICAgICB4aS52c3ViKHByb2plY3RlZCwgcHJvamVjdGVkKTsgLy9wcm9qZWN0ZWQudmFkZChiai5wb3NpdGlvbixwcm9qZWN0ZWQpOwogICAgICAgIC8vIHJqIGlzIG5vdyB0aGUgcHJvamVjdGVkIHdvcmxkIHBvc2l0aW9uIG1pbnVzIHBsYW5lIHBvc2l0aW9uCgogICAgICAgIHIucmouY29weShwcm9qZWN0ZWQpOwogICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICB9CiAgICB9CgogICAgYm94UGFydGljbGUoc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7CiAgICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlOwogICAgICByZXR1cm4gdGhpcy5jb252ZXhQYXJ0aWNsZShzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTsKICAgIH0KCiAgICBjb252ZXhQYXJ0aWNsZShzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICBsZXQgcGVuZXRyYXRlZEZhY2VJbmRleCA9IC0xOwogICAgICBjb25zdCBwZW5ldHJhdGVkRmFjZU5vcm1hbCA9IGNvbnZleFBhcnRpY2xlX3BlbmV0cmF0ZWRGYWNlTm9ybWFsOwogICAgICBjb25zdCB3b3JsZFBlbmV0cmF0aW9uVmVjID0gY29udmV4UGFydGljbGVfd29ybGRQZW5ldHJhdGlvblZlYzsKICAgICAgbGV0IG1pblBlbmV0cmF0aW9uID0gbnVsbDsKCiAgICAgIGNvbnN0IGxvY2FsID0gY29udmV4UGFydGljbGVfbG9jYWw7CiAgICAgIGxvY2FsLmNvcHkoeGkpOwogICAgICBsb2NhbC52c3ViKHhqLCBsb2NhbCk7IC8vIENvbnZlcnQgcG9zaXRpb24gdG8gcmVsYXRpdmUgdGhlIGNvbnZleCBvcmlnaW4KCiAgICAgIHFqLmNvbmp1Z2F0ZShjcWopOwogICAgICBjcWoudm11bHQobG9jYWwsIGxvY2FsKTsKCiAgICAgIGlmIChzai5wb2ludElzSW5zaWRlKGxvY2FsKSkgewogICAgICAgIGlmIChzai53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUpIHsKICAgICAgICAgIHNqLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHhqLCBxaik7CiAgICAgICAgfQoKICAgICAgICBpZiAoc2oud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlKSB7CiAgICAgICAgICBzai5jb21wdXRlV29ybGRGYWNlTm9ybWFscyhxaik7CiAgICAgICAgfSAvLyBGb3IgZWFjaCB3b3JsZCBwb2x5Z29uIGluIHRoZSBwb2x5aGVkcmEKCgogICAgICAgIGZvciAobGV0IGkgPSAwLCBuZmFjZXMgPSBzai5mYWNlcy5sZW5ndGg7IGkgIT09IG5mYWNlczsgaSsrKSB7CiAgICAgICAgICAvLyBDb25zdHJ1Y3Qgd29ybGQgZmFjZSB2ZXJ0aWNlcwogICAgICAgICAgY29uc3QgdmVydHMgPSBbc2oud29ybGRWZXJ0aWNlc1tzai5mYWNlc1tpXVswXV1dOwogICAgICAgICAgY29uc3Qgbm9ybWFsID0gc2oud29ybGRGYWNlTm9ybWFsc1tpXTsgLy8gQ2hlY2sgaG93IG11Y2ggdGhlIHBhcnRpY2xlIHBlbmV0cmF0ZXMgdGhlIHBvbHlnb24gcGxhbmUuCgogICAgICAgICAgeGkudnN1Yih2ZXJ0c1swXSwgY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSk7CiAgICAgICAgICBjb25zdCBwZW5ldHJhdGlvbiA9IC1ub3JtYWwuZG90KGNvbnZleFBhcnRpY2xlX3ZlcnRleFRvUGFydGljbGUpOwoKICAgICAgICAgIGlmIChtaW5QZW5ldHJhdGlvbiA9PT0gbnVsbCB8fCBNYXRoLmFicyhwZW5ldHJhdGlvbikgPCBNYXRoLmFicyhtaW5QZW5ldHJhdGlvbikpIHsKICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIG1pblBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb247CiAgICAgICAgICAgIHBlbmV0cmF0ZWRGYWNlSW5kZXggPSBpOwogICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5jb3B5KG5vcm1hbCk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAocGVuZXRyYXRlZEZhY2VJbmRleCAhPT0gLTEpIHsKICAgICAgICAgIC8vIFNldHVwIGNvbnRhY3QKICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOwogICAgICAgICAgcGVuZXRyYXRlZEZhY2VOb3JtYWwuc2NhbGUobWluUGVuZXRyYXRpb24sIHdvcmxkUGVuZXRyYXRpb25WZWMpOyAvLyByaiBpcyB0aGUgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIHRvIHRoZSBmYWNlCgogICAgICAgICAgd29ybGRQZW5ldHJhdGlvblZlYy52YWRkKHhpLCB3b3JsZFBlbmV0cmF0aW9uVmVjKTsKICAgICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudnN1Yih4aiwgd29ybGRQZW5ldHJhdGlvblZlYyk7CiAgICAgICAgICByLnJqLmNvcHkod29ybGRQZW5ldHJhdGlvblZlYyk7IC8vY29uc3QgcHJvamVjdGVkVG9GYWNlID0geGkudnN1Yih4aikudmFkZCh3b3JsZFBlbmV0cmF0aW9uVmVjKTsKICAgICAgICAgIC8vcHJvamVjdGVkVG9GYWNlLmNvcHkoci5yaik7CiAgICAgICAgICAvL3FqLnZtdWx0KHIucmosci5yaik7CgogICAgICAgICAgcGVuZXRyYXRlZEZhY2VOb3JtYWwubmVnYXRlKHIubmkpOyAvLyBDb250YWN0IG5vcm1hbAoKICAgICAgICAgIHIucmkuc2V0KDAsIDAsIDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGUKCiAgICAgICAgICBjb25zdCByaSA9IHIucmk7CiAgICAgICAgICBjb25zdCByaiA9IHIucmo7IC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzCgogICAgICAgICAgcmkudmFkZCh4aSwgcmkpOwogICAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpOwogICAgICAgICAgcmoudmFkZCh4aiwgcmopOwogICAgICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopOwogICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29uc29sZS53YXJuKCdQb2ludCBmb3VuZCBpbnNpZGUgY29udmV4LCBidXQgZGlkIG5vdCBmaW5kIHBlbmV0cmF0aW5nIGZhY2UhJyk7CiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgaGVpZ2h0ZmllbGRDeWxpbmRlcihoZlNoYXBlLCBjb252ZXhTaGFwZSwgaGZQb3MsIGNvbnZleFBvcywgaGZRdWF0LCBjb252ZXhRdWF0LCBoZkJvZHksIGNvbnZleEJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICByZXR1cm4gdGhpcy5jb252ZXhIZWlnaHRmaWVsZChjb252ZXhTaGFwZSwgaGZTaGFwZSwgY29udmV4UG9zLCBoZlBvcywgY29udmV4UXVhdCwgaGZRdWF0LCBjb252ZXhCb2R5LCBoZkJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCk7CiAgICB9CgogICAgcGFydGljbGVDeWxpbmRlcihzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHJzaSwgcnNqLCBqdXN0VGVzdCkgewogICAgICByZXR1cm4gdGhpcy5jb252ZXhQYXJ0aWNsZShzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHJzaSwgcnNqLCBqdXN0VGVzdCk7CiAgICB9CgogICAgc3BoZXJlVHJpbWVzaChzcGhlcmVTaGFwZSwgdHJpbWVzaFNoYXBlLCBzcGhlcmVQb3MsIHRyaW1lc2hQb3MsIHNwaGVyZVF1YXQsIHRyaW1lc2hRdWF0LCBzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgcnNpLCByc2osIGp1c3RUZXN0KSB7CiAgICAgIGNvbnN0IGVkZ2VWZXJ0ZXhBID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QTsKICAgICAgY29uc3QgZWRnZVZlcnRleEIgPSBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhCOwogICAgICBjb25zdCBlZGdlVmVjdG9yID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVjdG9yOwogICAgICBjb25zdCBlZGdlVmVjdG9yVW5pdCA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvclVuaXQ7CiAgICAgIGNvbnN0IGxvY2FsU3BoZXJlUG9zID0gc3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZVBvczsKICAgICAgY29uc3QgdG1wID0gc3BoZXJlVHJpbWVzaF90bXA7CiAgICAgIGNvbnN0IGxvY2FsU3BoZXJlQUFCQiA9IHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVBQUJCOwogICAgICBjb25zdCB2MiA9IHNwaGVyZVRyaW1lc2hfdjI7CiAgICAgIGNvbnN0IHJlbHBvcyA9IHNwaGVyZVRyaW1lc2hfcmVscG9zOwogICAgICBjb25zdCB0cmlhbmdsZXMgPSBzcGhlcmVUcmltZXNoX3RyaWFuZ2xlczsgLy8gQ29udmVydCBzcGhlcmUgcG9zaXRpb24gdG8gbG9jYWwgaW4gdGhlIHRyaW1lc2gKCiAgICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgc3BoZXJlUG9zLCBsb2NhbFNwaGVyZVBvcyk7IC8vIEdldCB0aGUgYWFiYiBvZiB0aGUgc3BoZXJlIGxvY2FsbHkgaW4gdGhlIHRyaW1lc2gKCiAgICAgIGNvbnN0IHNwaGVyZVJhZGl1cyA9IHNwaGVyZVNoYXBlLnJhZGl1czsKICAgICAgbG9jYWxTcGhlcmVBQUJCLmxvd2VyQm91bmQuc2V0KGxvY2FsU3BoZXJlUG9zLnggLSBzcGhlcmVSYWRpdXMsIGxvY2FsU3BoZXJlUG9zLnkgLSBzcGhlcmVSYWRpdXMsIGxvY2FsU3BoZXJlUG9zLnogLSBzcGhlcmVSYWRpdXMpOwogICAgICBsb2NhbFNwaGVyZUFBQkIudXBwZXJCb3VuZC5zZXQobG9jYWxTcGhlcmVQb3MueCArIHNwaGVyZVJhZGl1cywgbG9jYWxTcGhlcmVQb3MueSArIHNwaGVyZVJhZGl1cywgbG9jYWxTcGhlcmVQb3MueiArIHNwaGVyZVJhZGl1cyk7CiAgICAgIHRyaW1lc2hTaGFwZS5nZXRUcmlhbmdsZXNJbkFBQkIobG9jYWxTcGhlcmVBQUJCLCB0cmlhbmdsZXMpOyAvL2ZvciAobGV0IGkgPSAwOyBpIDwgdHJpbWVzaFNoYXBlLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB0cmlhbmdsZXMucHVzaChpKTsgLy8gQWxsCiAgICAgIC8vIFZlcnRpY2VzCgogICAgICBjb25zdCB2ID0gc3BoZXJlVHJpbWVzaF92OwogICAgICBjb25zdCByYWRpdXNTcXVhcmVkID0gc3BoZXJlU2hhcGUucmFkaXVzICogc3BoZXJlU2hhcGUucmFkaXVzOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykgewogICAgICAgICAgdHJpbWVzaFNoYXBlLmdldFZlcnRleCh0cmltZXNoU2hhcGUuaW5kaWNlc1t0cmlhbmdsZXNbaV0gKiAzICsgal0sIHYpOyAvLyBDaGVjayB2ZXJ0ZXggb3ZlcmxhcCBpbiBzcGhlcmUKCiAgICAgICAgICB2LnZzdWIobG9jYWxTcGhlcmVQb3MsIHJlbHBvcyk7CgogICAgICAgICAgaWYgKHJlbHBvcy5sZW5ndGhTcXVhcmVkKCkgPD0gcmFkaXVzU3F1YXJlZCkgewogICAgICAgICAgICAvLyBTYWZlIHVwCiAgICAgICAgICAgIHYyLmNvcHkodik7CiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdjIsIHYpOwogICAgICAgICAgICB2LnZzdWIoc3BoZXJlUG9zLCByZWxwb3MpOwoKICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGxldCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSwgdHJpbWVzaEJvZHksIHNwaGVyZVNoYXBlLCB0cmltZXNoU2hhcGUsIHJzaSwgcnNqKTsKICAgICAgICAgICAgci5uaS5jb3B5KHJlbHBvcyk7CiAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7IC8vIHJpIGlzIHRoZSB2ZWN0b3IgZnJvbSBzcGhlcmUgY2VudGVyIHRvIHRoZSBzcGhlcmUgc3VyZmFjZQoKICAgICAgICAgICAgci5yaS5jb3B5KHIubmkpOwogICAgICAgICAgICByLnJpLnNjYWxlKHNwaGVyZVNoYXBlLnJhZGl1cywgci5yaSk7CiAgICAgICAgICAgIHIucmkudmFkZChzcGhlcmVQb3MsIHIucmkpOwogICAgICAgICAgICByLnJpLnZzdWIoc3BoZXJlQm9keS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgICAgIHIucmouY29weSh2KTsKICAgICAgICAgICAgci5yai52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTsgLy8gU3RvcmUgcmVzdWx0CgogICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpOwogICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIENoZWNrIGFsbCBlZGdlcwoKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHsKICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgodHJpbWVzaFNoYXBlLmluZGljZXNbdHJpYW5nbGVzW2ldICogMyArIGpdLCBlZGdlVmVydGV4QSk7CiAgICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KHRyaW1lc2hTaGFwZS5pbmRpY2VzW3RyaWFuZ2xlc1tpXSAqIDMgKyAoaiArIDEpICUgM10sIGVkZ2VWZXJ0ZXhCKTsKICAgICAgICAgIGVkZ2VWZXJ0ZXhCLnZzdWIoZWRnZVZlcnRleEEsIGVkZ2VWZWN0b3IpOyAvLyBQcm9qZWN0IHNwaGVyZSBwb3NpdGlvbiB0byB0aGUgZWRnZQoKICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEIsIHRtcCk7CiAgICAgICAgICBjb25zdCBwb3NpdGlvbkFsb25nRWRnZUIgPSB0bXAuZG90KGVkZ2VWZWN0b3IpOwogICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTsKICAgICAgICAgIGxldCBwb3NpdGlvbkFsb25nRWRnZUEgPSB0bXAuZG90KGVkZ2VWZWN0b3IpOwoKICAgICAgICAgIGlmIChwb3NpdGlvbkFsb25nRWRnZUEgPiAwICYmIHBvc2l0aW9uQWxvbmdFZGdlQiA8IDApIHsKICAgICAgICAgICAgLy8gTm93IGNoZWNrIHRoZSBvcnRob2dvbmFsIGRpc3RhbmNlIGZyb20gZWRnZSB0byBzcGhlcmUgY2VudGVyCiAgICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEEsIHRtcCk7CiAgICAgICAgICAgIGVkZ2VWZWN0b3JVbml0LmNvcHkoZWRnZVZlY3Rvcik7CiAgICAgICAgICAgIGVkZ2VWZWN0b3JVbml0Lm5vcm1hbGl6ZSgpOwogICAgICAgICAgICBwb3NpdGlvbkFsb25nRWRnZUEgPSB0bXAuZG90KGVkZ2VWZWN0b3JVbml0KTsKICAgICAgICAgICAgZWRnZVZlY3RvclVuaXQuc2NhbGUocG9zaXRpb25BbG9uZ0VkZ2VBLCB0bXApOwogICAgICAgICAgICB0bXAudmFkZChlZGdlVmVydGV4QSwgdG1wKTsgLy8gdG1wIGlzIG5vdyB0aGUgc3BoZXJlIGNlbnRlciBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIGVkZ2UsIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgdHJpbWVzaCBmcmFtZQoKICAgICAgICAgICAgY29uc3QgZGlzdCA9IHRtcC5kaXN0YW5jZVRvKGxvY2FsU3BoZXJlUG9zKTsKCiAgICAgICAgICAgIGlmIChkaXN0IDwgc3BoZXJlU2hhcGUucmFkaXVzKSB7CiAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgc3BoZXJlU2hhcGUsIHRyaW1lc2hTaGFwZSwgcnNpLCByc2opOwogICAgICAgICAgICAgIHRtcC52c3ViKGxvY2FsU3BoZXJlUG9zLCByLm5pKTsKICAgICAgICAgICAgICByLm5pLm5vcm1hbGl6ZSgpOwogICAgICAgICAgICAgIHIubmkuc2NhbGUoc3BoZXJlU2hhcGUucmFkaXVzLCByLnJpKTsKICAgICAgICAgICAgICByLnJpLnZhZGQoc3BoZXJlUG9zLCByLnJpKTsKICAgICAgICAgICAgICByLnJpLnZzdWIoc3BoZXJlQm9keS5wb3NpdGlvbiwgci5yaSk7CiAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB0bXAsIHRtcCk7CiAgICAgICAgICAgICAgdG1wLnZzdWIodHJpbWVzaEJvZHkucG9zaXRpb24sIHIucmopOwogICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIubmksIHIubmkpOwogICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpOwogICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7CiAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIFRyaWFuZ2xlIGZhY2VzCgoKICAgICAgY29uc3QgdmEgPSBzcGhlcmVUcmltZXNoX3ZhOwogICAgICBjb25zdCB2YiA9IHNwaGVyZVRyaW1lc2hfdmI7CiAgICAgIGNvbnN0IHZjID0gc3BoZXJlVHJpbWVzaF92YzsKICAgICAgY29uc3Qgbm9ybWFsID0gc3BoZXJlVHJpbWVzaF9ub3JtYWw7CgogICAgICBmb3IgKGxldCBpID0gMCwgTiA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgIT09IE47IGkrKykgewogICAgICAgIHRyaW1lc2hTaGFwZS5nZXRUcmlhbmdsZVZlcnRpY2VzKHRyaWFuZ2xlc1tpXSwgdmEsIHZiLCB2Yyk7CiAgICAgICAgdHJpbWVzaFNoYXBlLmdldE5vcm1hbCh0cmlhbmdsZXNbaV0sIG5vcm1hbCk7CiAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1Yih2YSwgdG1wKTsKICAgICAgICBsZXQgZGlzdCA9IHRtcC5kb3Qobm9ybWFsKTsKICAgICAgICBub3JtYWwuc2NhbGUoZGlzdCwgdG1wKTsKICAgICAgICBsb2NhbFNwaGVyZVBvcy52c3ViKHRtcCwgdG1wKTsgLy8gdG1wIGlzIG5vdyB0aGUgc3BoZXJlIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgdHJpYW5nbGUgcGxhbmUKCiAgICAgICAgZGlzdCA9IHRtcC5kaXN0YW5jZVRvKGxvY2FsU3BoZXJlUG9zKTsKCiAgICAgICAgaWYgKFJheS5wb2ludEluVHJpYW5nbGUodG1wLCB2YSwgdmIsIHZjKSAmJiBkaXN0IDwgc3BoZXJlU2hhcGUucmFkaXVzKSB7CiAgICAgICAgICBpZiAoanVzdFRlc3QpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CgogICAgICAgICAgbGV0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgc3BoZXJlU2hhcGUsIHRyaW1lc2hTaGFwZSwgcnNpLCByc2opOwogICAgICAgICAgdG1wLnZzdWIobG9jYWxTcGhlcmVQb3MsIHIubmkpOwogICAgICAgICAgci5uaS5ub3JtYWxpemUoKTsKICAgICAgICAgIHIubmkuc2NhbGUoc3BoZXJlU2hhcGUucmFkaXVzLCByLnJpKTsKICAgICAgICAgIHIucmkudmFkZChzcGhlcmVQb3MsIHIucmkpOwogICAgICAgICAgci5yaS52c3ViKHNwaGVyZUJvZHkucG9zaXRpb24sIHIucmkpOwogICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB0bXAsIHRtcCk7CiAgICAgICAgICB0bXAudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7CiAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHRyaW1lc2hRdWF0LCByLm5pLCByLm5pKTsKICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpOwogICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRyaWFuZ2xlcy5sZW5ndGggPSAwOwogICAgfQoKICAgIHBsYW5lVHJpbWVzaChwbGFuZVNoYXBlLCB0cmltZXNoU2hhcGUsIHBsYW5lUG9zLCB0cmltZXNoUG9zLCBwbGFuZVF1YXQsIHRyaW1lc2hRdWF0LCBwbGFuZUJvZHksIHRyaW1lc2hCb2R5LCByc2ksIHJzaiwganVzdFRlc3QpIHsKICAgICAgLy8gTWFrZSBjb250YWN0cyEKICAgICAgY29uc3QgdiA9IG5ldyBWZWMzKCk7CiAgICAgIGNvbnN0IG5vcm1hbCA9IHBsYW5lVHJpbWVzaF9ub3JtYWw7CiAgICAgIG5vcm1hbC5zZXQoMCwgMCwgMSk7CiAgICAgIHBsYW5lUXVhdC52bXVsdChub3JtYWwsIG5vcm1hbCk7IC8vIFR1cm4gbm9ybWFsIGFjY29yZGluZyB0byBwbGFuZQoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmltZXNoU2hhcGUudmVydGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAgICAgLy8gR2V0IHdvcmxkIHZlcnRleCBmcm9tIHRyaW1lc2gKICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KGksIHYpOyAvLyBTYWZlIHVwCgogICAgICAgIGNvbnN0IHYyID0gbmV3IFZlYzMoKTsKICAgICAgICB2Mi5jb3B5KHYpOwogICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdjIsIHYpOyAvLyBDaGVjayBwbGFuZSBzaWRlCgogICAgICAgIGNvbnN0IHJlbHBvcyA9IHBsYW5lVHJpbWVzaF9yZWxwb3M7CiAgICAgICAgdi52c3ViKHBsYW5lUG9zLCByZWxwb3MpOwogICAgICAgIGNvbnN0IGRvdCA9IG5vcm1hbC5kb3QocmVscG9zKTsKCiAgICAgICAgaWYgKGRvdCA8PSAwLjApIHsKICAgICAgICAgIGlmIChqdXN0VGVzdCkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KCiAgICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LCB0cmltZXNoQm9keSwgcGxhbmVTaGFwZSwgdHJpbWVzaFNoYXBlLCByc2ksIHJzaik7CiAgICAgICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWwgaXMgdGhlIHBsYW5lIG5vcm1hbAogICAgICAgICAgLy8gR2V0IHZlcnRleCBwb3NpdGlvbiBwcm9qZWN0ZWQgb24gcGxhbmUKCiAgICAgICAgICBjb25zdCBwcm9qZWN0ZWQgPSBwbGFuZVRyaW1lc2hfcHJvamVjdGVkOwogICAgICAgICAgbm9ybWFsLnNjYWxlKHJlbHBvcy5kb3Qobm9ybWFsKSwgcHJvamVjdGVkKTsKICAgICAgICAgIHYudnN1Yihwcm9qZWN0ZWQsIHByb2plY3RlZCk7IC8vIHJpIGlzIHRoZSBwcm9qZWN0ZWQgd29ybGQgcG9zaXRpb24gbWludXMgcGxhbmUgcG9zaXRpb24KCiAgICAgICAgICByLnJpLmNvcHkocHJvamVjdGVkKTsKICAgICAgICAgIHIucmkudnN1YihwbGFuZUJvZHkucG9zaXRpb24sIHIucmkpOwogICAgICAgICAgci5yai5jb3B5KHYpOwogICAgICAgICAgci5yai52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTsgLy8gU3RvcmUgcmVzdWx0CgogICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTsKICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsKICAgICAgICB9CiAgICAgIH0KICAgIH0gLy8gY29udmV4VHJpbWVzaCgKICAgIC8vICAgc2k6IENvbnZleFBvbHloZWRyb24sIHNqOiBUcmltZXNoLCB4aTogVmVjMywgeGo6IFZlYzMsIHFpOiBRdWF0ZXJuaW9uLCBxajogUXVhdGVybmlvbiwKICAgIC8vICAgYmk6IEJvZHksIGJqOiBCb2R5LCByc2k/OiBTaGFwZSB8IG51bGwsIHJzaj86IFNoYXBlIHwgbnVsbCwKICAgIC8vICAgZmFjZUxpc3RBPzogbnVtYmVyW10gfCBudWxsLCBmYWNlTGlzdEI/OiBudW1iZXJbXSB8IG51bGwsCiAgICAvLyApIHsKICAgIC8vICAgY29uc3Qgc2VwQXhpcyA9IGNvbnZleENvbnZleF9zZXBBeGlzOwogICAgLy8gICBpZih4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpewogICAgLy8gICAgICAgcmV0dXJuOwogICAgLy8gICB9CiAgICAvLyAgIC8vIENvbnN0cnVjdCBhIHRlbXAgaHVsbCBmb3IgZWFjaCB0cmlhbmdsZQogICAgLy8gICBjb25zdCBodWxsQiA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7CiAgICAvLyAgIGh1bGxCLmZhY2VzID0gW1swLDEsMl1dOwogICAgLy8gICBjb25zdCB2YSA9IG5ldyBWZWMzKCk7CiAgICAvLyAgIGNvbnN0IHZiID0gbmV3IFZlYzMoKTsKICAgIC8vICAgY29uc3QgdmMgPSBuZXcgVmVjMygpOwogICAgLy8gICBodWxsQi52ZXJ0aWNlcyA9IFsKICAgIC8vICAgICAgIHZhLAogICAgLy8gICAgICAgdmIsCiAgICAvLyAgICAgICB2YwogICAgLy8gICBdOwogICAgLy8gICBmb3IgKGxldCBpID0gMDsgaSA8IHNqLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7CiAgICAvLyAgICAgICBjb25zdCB0cmlhbmdsZU5vcm1hbCA9IG5ldyBWZWMzKCk7CiAgICAvLyAgICAgICBzai5nZXROb3JtYWwoaSwgdHJpYW5nbGVOb3JtYWwpOwogICAgLy8gICAgICAgaHVsbEIuZmFjZU5vcm1hbHMgPSBbdHJpYW5nbGVOb3JtYWxdOwogICAgLy8gICAgICAgc2ouZ2V0VHJpYW5nbGVWZXJ0aWNlcyhpLCB2YSwgdmIsIHZjKTsKICAgIC8vICAgICAgIGxldCBkID0gc2kudGVzdFNlcEF4aXModHJpYW5nbGVOb3JtYWwsIGh1bGxCLCB4aSwgcWksIHhqLCBxaik7CiAgICAvLyAgICAgICBpZighZCl7CiAgICAvLyAgICAgICAgICAgdHJpYW5nbGVOb3JtYWwuc2NhbGUoLTEsIHRyaWFuZ2xlTm9ybWFsKTsKICAgIC8vICAgICAgICAgICBkID0gc2kudGVzdFNlcEF4aXModHJpYW5nbGVOb3JtYWwsIGh1bGxCLCB4aSwgcWksIHhqLCBxaik7CiAgICAvLyAgICAgICAgICAgaWYoIWQpewogICAgLy8gICAgICAgICAgICAgICBjb250aW51ZTsKICAgIC8vICAgICAgICAgICB9CiAgICAvLyAgICAgICB9CiAgICAvLyAgICAgICBjb25zdCByZXM6IENvbnZleFBvbHloZWRyb25Db250YWN0UG9pbnRbXSA9IFtdOwogICAgLy8gICAgICAgY29uc3QgcSA9IGNvbnZleENvbnZleF9xOwogICAgLy8gICAgICAgc2kuY2xpcEFnYWluc3RIdWxsKHhpLHFpLGh1bGxCLHhqLHFqLHRyaWFuZ2xlTm9ybWFsLC0xMDAsMTAwLHJlcyk7CiAgICAvLyAgICAgICBmb3IobGV0IGogPSAwOyBqICE9PSByZXMubGVuZ3RoOyBqKyspewogICAgLy8gICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKSwKICAgIC8vICAgICAgICAgICAgICAgcmkgPSByLnJpLAogICAgLy8gICAgICAgICAgICAgICByaiA9IHIucmo7CiAgICAvLyAgICAgICAgICAgci5uaS5jb3B5KHRyaWFuZ2xlTm9ybWFsKTsKICAgIC8vICAgICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTsKICAgIC8vICAgICAgICAgICByZXNbal0ubm9ybWFsLm5lZ2F0ZShxKTsKICAgIC8vICAgICAgICAgICBxLm11bHQocmVzW2pdLmRlcHRoLCBxKTsKICAgIC8vICAgICAgICAgICByZXNbal0ucG9pbnQudmFkZChxLCByaSk7CiAgICAvLyAgICAgICAgICAgcmouY29weShyZXNbal0ucG9pbnQpOwogICAgLy8gICAgICAgICAgIC8vIENvbnRhY3QgcG9pbnRzIGFyZSBpbiB3b3JsZCBjb29yZGluYXRlcy4gVHJhbnNmb3JtIGJhY2sgdG8gcmVsYXRpdmUKICAgIC8vICAgICAgICAgICByaS52c3ViKHhpLHJpKTsKICAgIC8vICAgICAgICAgICByai52c3ViKHhqLHJqKTsKICAgIC8vICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllcwogICAgLy8gICAgICAgICAgIHJpLnZhZGQoeGksIHJpKTsKICAgIC8vICAgICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7CiAgICAvLyAgICAgICAgICAgcmoudmFkZCh4aiwgcmopOwogICAgLy8gICAgICAgICAgIHJqLnZzdWIoYmoucG9zaXRpb24sIHJqKTsKICAgIC8vICAgICAgICAgICByZXN1bHQucHVzaChyKTsKICAgIC8vICAgICAgIH0KICAgIC8vICAgfQogICAgLy8gfQoKCiAgfQogIGNvbnN0IGF2ZXJhZ2VOb3JtYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IGF2ZXJhZ2VDb250YWN0UG9pbnRBID0gbmV3IFZlYzMoKTsKICBjb25zdCBhdmVyYWdlQ29udGFjdFBvaW50QiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wVmVjMSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wVmVjMiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgdG1wUXVhdDEgPSBuZXcgUXVhdGVybmlvbigpOwogIGNvbnN0IHRtcFF1YXQyID0gbmV3IFF1YXRlcm5pb24oKTsKCiAgY29uc3QgcGxhbmVUcmltZXNoX25vcm1hbCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGxhbmVUcmltZXNoX3JlbHBvcyA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGxhbmVUcmltZXNoX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9ub3JtYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZVRyaW1lc2hfcmVscG9zID0gbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZVRyaW1lc2hfdiA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF92MiA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QSA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QiA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9lZGdlVmVjdG9yID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3JVbml0ID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlUG9zID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVUcmltZXNoX3RtcCA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF92YSA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF92YiA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF92YyA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZUFBQkIgPSBuZXcgQUFCQigpOwogIGNvbnN0IHNwaGVyZVRyaW1lc2hfdHJpYW5nbGVzID0gW107CiAgY29uc3QgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlID0gbmV3IFZlYzMoKTsKICBjb25zdCBwbGFuZV90b19zcGhlcmVfb3J0aG8gPSBuZXcgVmVjMygpOyAvLyBTZWUgaHR0cDovL2J1bGxldHBoeXNpY3MuY29tL0J1bGxldC9CdWxsZXRGdWxsL1NwaGVyZVRyaWFuZ2xlRGV0ZWN0b3JfOGNwcF9zb3VyY2UuaHRtbAoKICBjb25zdCBwb2ludEluUG9seWdvbl9lZGdlID0gbmV3IFZlYzMoKTsKICBjb25zdCBwb2ludEluUG9seWdvbl9lZGdlX3hfbm9ybWFsID0gbmV3IFZlYzMoKTsKICBjb25zdCBwb2ludEluUG9seWdvbl92dHAgPSBuZXcgVmVjMygpOwoKICBmdW5jdGlvbiBwb2ludEluUG9seWdvbih2ZXJ0cywgbm9ybWFsLCBwKSB7CiAgICBsZXQgcG9zaXRpdmVSZXN1bHQgPSBudWxsOwogICAgY29uc3QgTiA9IHZlcnRzLmxlbmd0aDsKCiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgIGNvbnN0IHYgPSB2ZXJ0c1tpXTsgLy8gR2V0IGVkZ2UgdG8gdGhlIG5leHQgdmVydGV4CgogICAgICBjb25zdCBlZGdlID0gcG9pbnRJblBvbHlnb25fZWRnZTsKICAgICAgdmVydHNbKGkgKyAxKSAlIE5dLnZzdWIodiwgZWRnZSk7IC8vIEdldCBjcm9zcyBwcm9kdWN0IGJldHdlZW4gcG9seWdvbiBub3JtYWwgYW5kIHRoZSBlZGdlCgogICAgICBjb25zdCBlZGdlX3hfbm9ybWFsID0gcG9pbnRJblBvbHlnb25fZWRnZV94X25vcm1hbDsgLy9jb25zdCBlZGdlX3hfbm9ybWFsID0gbmV3IFZlYzMoKTsKCiAgICAgIGVkZ2UuY3Jvc3Mobm9ybWFsLCBlZGdlX3hfbm9ybWFsKTsgLy8gR2V0IHZlY3RvciBiZXR3ZWVuIHBvaW50IGFuZCBjdXJyZW50IHZlcnRleAoKICAgICAgY29uc3QgdmVydGV4X3RvX3AgPSBwb2ludEluUG9seWdvbl92dHA7CiAgICAgIHAudnN1Yih2LCB2ZXJ0ZXhfdG9fcCk7IC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpcwoKICAgICAgY29uc3QgciA9IGVkZ2VfeF9ub3JtYWwuZG90KHZlcnRleF90b19wKTsgLy8gSWYgYWxsIHN1Y2ggZG90IHByb2R1Y3RzIGhhdmUgc2FtZSBzaWduLCB3ZSBhcmUgaW5zaWRlIHRoZSBwb2x5Z29uLgoKICAgICAgaWYgKHBvc2l0aXZlUmVzdWx0ID09PSBudWxsIHx8IHIgPiAwICYmIHBvc2l0aXZlUmVzdWx0ID09PSB0cnVlIHx8IHIgPD0gMCAmJiBwb3NpdGl2ZVJlc3VsdCA9PT0gZmFsc2UpIHsKICAgICAgICBpZiAocG9zaXRpdmVSZXN1bHQgPT09IG51bGwpIHsKICAgICAgICAgIHBvc2l0aXZlUmVzdWx0ID0gciA+IDA7CiAgICAgICAgfQoKICAgICAgICBjb250aW51ZTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEVuY291bnRlcmVkIHNvbWUgb3RoZXIgc2lnbi4gRXhpdC4KICAgICAgfQogICAgfSAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIGRvdCBwcm9kdWN0cyB3ZXJlIG9mIHRoZSBzYW1lIHNpZ24uCgoKICAgIHJldHVybiB0cnVlOwogIH0KCiAgY29uc3QgYm94X3RvX3NwaGVyZSA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQm94X25zID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVCb3hfbnMxID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVCb3hfbnMyID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVCb3hfc2lkZXMgPSBbbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKV07CiAgY29uc3Qgc3BoZXJlQm94X3NwaGVyZV90b19jb3JuZXIgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUJveF9zaWRlX25zID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVCb3hfc2lkZV9uczEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUJveF9zaWRlX25zMiA9IG5ldyBWZWMzKCk7CiAgY29uc3QgY29udmV4X3RvX3NwaGVyZSA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQ29udmV4X2VkZ2UgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUNvbnZleF9lZGdlVW5pdCA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQ29udmV4X3NwaGVyZVRvQ29ybmVyID0gbmV3IFZlYzMoKTsKICBjb25zdCBzcGhlcmVDb252ZXhfd29ybGRDb3JuZXIgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUNvbnZleF93b3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQ29udmV4X3dvcmxkUG9pbnQgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUNvbnZleF93b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUNvbnZleF9wZW5ldHJhdGlvblZlYyA9IG5ldyBWZWMzKCk7CiAgY29uc3Qgc3BoZXJlQ29udmV4X3NwaGVyZVRvV29ybGRQb2ludCA9IG5ldyBWZWMzKCk7CiAgbmV3IFZlYzMoKTsKICBuZXcgVmVjMygpOwogIGNvbnN0IHBsYW5lQ29udmV4X3YgPSBuZXcgVmVjMygpOwogIGNvbnN0IHBsYW5lQ29udmV4X25vcm1hbCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGxhbmVDb252ZXhfcmVscG9zID0gbmV3IFZlYzMoKTsKICBjb25zdCBwbGFuZUNvbnZleF9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleENvbnZleF9zZXBBeGlzID0gbmV3IFZlYzMoKTsKICBjb25zdCBjb252ZXhDb252ZXhfcSA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGFydGljbGVQbGFuZV9ub3JtYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IHBhcnRpY2xlUGxhbmVfcmVscG9zID0gbmV3IFZlYzMoKTsKICBjb25zdCBwYXJ0aWNsZVBsYW5lX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7CiAgY29uc3QgcGFydGljbGVTcGhlcmVfbm9ybWFsID0gbmV3IFZlYzMoKTsgLy8gV0lQCgogIGNvbnN0IGNxaiA9IG5ldyBRdWF0ZXJuaW9uKCk7CiAgY29uc3QgY29udmV4UGFydGljbGVfbG9jYWwgPSBuZXcgVmVjMygpOwogIG5ldyBWZWMzKCk7CiAgY29uc3QgY29udmV4UGFydGljbGVfcGVuZXRyYXRlZEZhY2VOb3JtYWwgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleFBhcnRpY2xlX3ZlcnRleFRvUGFydGljbGUgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleFBhcnRpY2xlX3dvcmxkUGVuZXRyYXRpb25WZWMgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleEhlaWdodGZpZWxkX3RtcDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleEhlaWdodGZpZWxkX3RtcDIgPSBuZXcgVmVjMygpOwogIGNvbnN0IGNvbnZleEhlaWdodGZpZWxkX2ZhY2VMaXN0ID0gWzBdOwogIGNvbnN0IHNwaGVyZUhlaWdodGZpZWxkX3RtcDEgPSBuZXcgVmVjMygpOwogIGNvbnN0IHNwaGVyZUhlaWdodGZpZWxkX3RtcDIgPSBuZXcgVmVjMygpOwoKICBjbGFzcyBPdmVybGFwS2VlcGVyIHsKICAgIC8qKgogICAgICogQHRvZG8gUmVtb3ZlIHVzZWxlc3MgY29uc3RydWN0b3IKICAgICAqLwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHRoaXMuY3VycmVudCA9IFtdOwogICAgICB0aGlzLnByZXZpb3VzID0gW107CiAgICB9CiAgICAvKioKICAgICAqIGdldEtleQogICAgICovCgoKICAgIGdldEtleShpLCBqKSB7CiAgICAgIGlmIChqIDwgaSkgewogICAgICAgIGNvbnN0IHRlbXAgPSBqOwogICAgICAgIGogPSBpOwogICAgICAgIGkgPSB0ZW1wOwogICAgICB9CgogICAgICByZXR1cm4gaSA8PCAxNiB8IGo7CiAgICB9CiAgICAvKioKICAgICAqIHNldAogICAgICovCgoKICAgIHNldChpLCBqKSB7CiAgICAgIC8vIEluc2VydGlvbiBzb3J0LiBUaGlzIHdheSB0aGUgZGlmZiB3aWxsIGhhdmUgbGluZWFyIGNvbXBsZXhpdHkuCiAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KGksIGopOwogICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50OwogICAgICBsZXQgaW5kZXggPSAwOwoKICAgICAgd2hpbGUgKGtleSA+IGN1cnJlbnRbaW5kZXhdKSB7CiAgICAgICAgaW5kZXgrKzsKICAgICAgfQoKICAgICAgaWYgKGtleSA9PT0gY3VycmVudFtpbmRleF0pIHsKICAgICAgICByZXR1cm47IC8vIFBhaXIgd2FzIGFscmVhZHkgYWRkZWQKICAgICAgfQoKICAgICAgZm9yIChsZXQgaiA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgaiA+PSBpbmRleDsgai0tKSB7CiAgICAgICAgY3VycmVudFtqICsgMV0gPSBjdXJyZW50W2pdOwogICAgICB9CgogICAgICBjdXJyZW50W2luZGV4XSA9IGtleTsKICAgIH0KICAgIC8qKgogICAgICogdGljawogICAgICovCgoKICAgIHRpY2soKSB7CiAgICAgIGNvbnN0IHRtcCA9IHRoaXMuY3VycmVudDsKICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5wcmV2aW91czsKICAgICAgdGhpcy5wcmV2aW91cyA9IHRtcDsKICAgICAgdGhpcy5jdXJyZW50Lmxlbmd0aCA9IDA7CiAgICB9CiAgICAvKioKICAgICAqIGdldERpZmYKICAgICAqLwoKCiAgICBnZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpIHsKICAgICAgY29uc3QgYSA9IHRoaXMuY3VycmVudDsKICAgICAgY29uc3QgYiA9IHRoaXMucHJldmlvdXM7CiAgICAgIGNvbnN0IGFsID0gYS5sZW5ndGg7CiAgICAgIGNvbnN0IGJsID0gYi5sZW5ndGg7CiAgICAgIGxldCBqID0gMDsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWw7IGkrKykgewogICAgICAgIGxldCBmb3VuZCA9IGZhbHNlOwogICAgICAgIGNvbnN0IGtleUEgPSBhW2ldOwoKICAgICAgICB3aGlsZSAoa2V5QSA+IGJbal0pIHsKICAgICAgICAgIGorKzsKICAgICAgICB9CgogICAgICAgIGZvdW5kID0ga2V5QSA9PT0gYltqXTsKCiAgICAgICAgaWYgKCFmb3VuZCkgewogICAgICAgICAgdW5wYWNrQW5kUHVzaChhZGRpdGlvbnMsIGtleUEpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaiA9IDA7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsOyBpKyspIHsKICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTsKICAgICAgICBjb25zdCBrZXlCID0gYltpXTsKCiAgICAgICAgd2hpbGUgKGtleUIgPiBhW2pdKSB7CiAgICAgICAgICBqKys7CiAgICAgICAgfQoKICAgICAgICBmb3VuZCA9IGFbal0gPT09IGtleUI7CgogICAgICAgIGlmICghZm91bmQpIHsKICAgICAgICAgIHVucGFja0FuZFB1c2gocmVtb3ZhbHMsIGtleUIpOwogICAgICAgIH0KICAgICAgfQogICAgfQoKICB9CgogIGZ1bmN0aW9uIHVucGFja0FuZFB1c2goYXJyYXksIGtleSkgewogICAgYXJyYXkucHVzaCgoa2V5ICYgMHhmZmZmMDAwMCkgPj4gMTYsIGtleSAmIDB4MDAwMGZmZmYpOwogIH0KCiAgY29uc3QgZ2V0S2V5ID0gKGksIGopID0+IGkgPCBqID8gYCR7aX0tJHtqfWAgOiBgJHtqfS0ke2l9YDsKICAvKioKICAgKiBUdXBsZURpY3Rpb25hcnkKICAgKi8KCgogIGNsYXNzIFR1cGxlRGljdGlvbmFyeSB7CiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgdGhpcy5kYXRhID0gewogICAgICAgIGtleXM6IFtdCiAgICAgIH07CiAgICB9CgogICAgLyoqIGdldCAqLwogICAgZ2V0KGksIGopIHsKICAgICAgY29uc3Qga2V5ID0gZ2V0S2V5KGksIGopOwogICAgICByZXR1cm4gdGhpcy5kYXRhW2tleV07CiAgICB9CiAgICAvKiogc2V0ICovCgoKICAgIHNldChpLCBqLCB2YWx1ZSkgewogICAgICBjb25zdCBrZXkgPSBnZXRLZXkoaSwgaik7IC8vIENoZWNrIGlmIGtleSBhbHJlYWR5IGV4aXN0cwoKICAgICAgaWYgKCF0aGlzLmdldChpLCBqKSkgewogICAgICAgIHRoaXMuZGF0YS5rZXlzLnB1c2goa2V5KTsKICAgICAgfQoKICAgICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTsKICAgIH0KICAgIC8qKiBkZWxldGUgKi8KCgogICAgZGVsZXRlKGksIGopIHsKICAgICAgY29uc3Qga2V5ID0gZ2V0S2V5KGksIGopOwogICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGF0YS5rZXlzLmluZGV4T2Yoa2V5KTsKCiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHsKICAgICAgICB0aGlzLmRhdGEua2V5cy5zcGxpY2UoaW5kZXgsIDEpOwogICAgICB9CgogICAgICBkZWxldGUgdGhpcy5kYXRhW2tleV07CiAgICB9CiAgICAvKiogcmVzZXQgKi8KCgogICAgcmVzZXQoKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7CiAgICAgIGNvbnN0IGtleXMgPSBkYXRhLmtleXM7CgogICAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiAwKSB7CiAgICAgICAgY29uc3Qga2V5ID0ga2V5cy5wb3AoKTsKICAgICAgICBkZWxldGUgZGF0YVtrZXldOwogICAgICB9CiAgICB9CgogIH0KCiAgLyoqCiAgICogVGhlIHBoeXNpY3Mgd29ybGQKICAgKi8KICBjbGFzcyBXb3JsZCBleHRlbmRzIEV2ZW50VGFyZ2V0IHsKICAgIC8qKgogICAgICogQ3VycmVudGx5IC8gbGFzdCB1c2VkIHRpbWVzdGVwLiBJcyBzZXQgdG8gLTEgaWYgbm90IGF2YWlsYWJsZS4gVGhpcyB2YWx1ZSBpcyB1cGRhdGVkIGJlZm9yZSBlYWNoIGludGVybmFsIHN0ZXAsIHdoaWNoIG1lYW5zIHRoYXQgaXQgaXMgImZyZXNoIiBpbnNpZGUgZXZlbnQgY2FsbGJhY2tzLgogICAgICovCgogICAgLyoqCiAgICAgKiBNYWtlcyBib2RpZXMgZ28gdG8gc2xlZXAgd2hlbiB0aGV5J3ZlIGJlZW4gaW5hY3RpdmUuCiAgICAgKiBAZGVmYXVsdCBmYWxzZQogICAgICovCgogICAgLyoqCiAgICAgKiBBbGwgdGhlIGN1cnJlbnQgY29udGFjdHMgKGluc3RhbmNlcyBvZiBDb250YWN0RXF1YXRpb24pIGluIHRoZSB3b3JsZC4KICAgICAqLwoKICAgIC8qKgogICAgICogSG93IG9mdGVuIHRvIG5vcm1hbGl6ZSBxdWF0ZXJuaW9ucy4gU2V0IHRvIDAgZm9yIGV2ZXJ5IHN0ZXAsIDEgZm9yIGV2ZXJ5IHNlY29uZCBldGMuLiBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgcGVyZm9ybWFuY2UuIElmIGJvZGllcyB0ZW5kIHRvIGV4cGxvZGUsIHNldCB0byBhIHNtYWxsZXIgdmFsdWUgKHplcm8gdG8gYmUgc3VyZSBub3RoaW5nIGNhbiBnbyB3cm9uZykuCiAgICAgKiBAZGVmYXVsdCAwCiAgICAgKi8KCiAgICAvKioKICAgICAqIFNldCB0byB0cnVlIHRvIHVzZSBmYXN0IHF1YXRlcm5pb24gbm9ybWFsaXphdGlvbi4gSXQgaXMgb2Z0ZW4gZW5vdWdoIGFjY3VyYXRlIHRvIHVzZS4KICAgICAqIElmIGJvZGllcyB0ZW5kIHRvIGV4cGxvZGUsIHNldCB0byBmYWxzZS4KICAgICAqIEBkZWZhdWx0IGZhbHNlCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSB3YWxsLWNsb2NrIHRpbWUgc2luY2Ugc2ltdWxhdGlvbiBzdGFydC4KICAgICAqLwoKICAgIC8qKgogICAgICogTnVtYmVyIG9mIHRpbWVzdGVwcyB0YWtlbiBzaW5jZSBzdGFydC4KICAgICAqLwoKICAgIC8qKgogICAgICogRGVmYXVsdCBhbmQgbGFzdCB0aW1lc3RlcCBzaXplcy4KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGdyYXZpdHkgb2YgdGhlIHdvcmxkLgogICAgICovCgogICAgLyoqCiAgICAgKiBHcmF2aXR5IHRvIHVzZSB3aGVuIGFwcHJveGltYXRpbmcgdGhlIGZyaWN0aW9uIG1heCBmb3JjZSAobXUqbWFzcypncmF2aXR5KS4KICAgICAqIElmIHVuZGVmaW5lZCwgZ2xvYmFsIGdyYXZpdHkgd2lsbCBiZSB1c2VkLgogICAgICogVXNlIHRvIGVuYWJsZSBmcmljdGlvbiBpbiBhIFdvcmxkIHdpdGggYSBudWxsIGdyYXZpdHkgdmVjdG9yIChubyBncmF2aXR5KS4KICAgICAqLwoKICAgIC8qKgogICAgICogVGhlIGJyb2FkcGhhc2UgYWxnb3JpdGhtIHRvIHVzZS4KICAgICAqIEBkZWZhdWx0IE5haXZlQnJvYWRwaGFzZQogICAgICovCgogICAgLyoqCiAgICAgKiBBbGwgYm9kaWVzIGluIHRoaXMgd29ybGQKICAgICAqLwoKICAgIC8qKgogICAgICogVHJ1ZSBpZiBhbnkgYm9kaWVzIGFyZSBub3Qgc2xlZXBpbmcsIGZhbHNlIGlmIGV2ZXJ5IGJvZHkgaXMgc2xlZXBpbmcuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFRoZSBzb2x2ZXIgYWxnb3JpdGhtIHRvIHVzZS4KICAgICAqIEBkZWZhdWx0IEdTU29sdmVyCiAgICAgKi8KCiAgICAvKioKICAgICAqIGNvbGxpc2lvbk1hdHJpeAogICAgICovCgogICAgLyoqCiAgICAgKiBDb2xsaXNpb25NYXRyaXggZnJvbSB0aGUgcHJldmlvdXMgc3RlcC4KICAgICAqLwoKICAgIC8qKgogICAgICogQWxsIGFkZGVkIGNvbnRhY3RtYXRlcmlhbHMuCiAgICAgKi8KCiAgICAvKioKICAgICAqIFVzZWQgdG8gbG9vayB1cCBhIENvbnRhY3RNYXRlcmlhbCBnaXZlbiB0d28gaW5zdGFuY2VzIG9mIE1hdGVyaWFsLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGUgZGVmYXVsdCBtYXRlcmlhbCBvZiB0aGUgYm9kaWVzLgogICAgICovCgogICAgLyoqCiAgICAgKiBUaGlzIGNvbnRhY3QgbWF0ZXJpYWwgaXMgdXNlZCBpZiBubyBzdWl0YWJsZSBjb250YWN0bWF0ZXJpYWwgaXMgZm91bmQgZm9yIGEgY29udGFjdC4KICAgICAqLwoKICAgIC8qKgogICAgICogVGltZSBhY2N1bXVsYXRvciBmb3IgaW50ZXJwb2xhdGlvbi4KICAgICAqIEBzZWUgaHR0cHM6Ly9nYWZmZXJvbmdhbWVzLmNvbS9nYW1lLXBoeXNpY3MvZml4LXlvdXItdGltZXN0ZXAvCiAgICAgKi8KCiAgICAvKioKICAgICAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB3b3JsZC4KICAgICAqLwoKICAgIC8qKgogICAgICogRGlzcGF0Y2hlZCBhZnRlciBhIGJvZHkgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSB3b3JsZC4KICAgICAqLwogICAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBzdXBlcigpOwogICAgICB0aGlzLmR0ID0gLTE7CiAgICAgIHRoaXMuYWxsb3dTbGVlcCA9ICEhb3B0aW9ucy5hbGxvd1NsZWVwOwogICAgICB0aGlzLmNvbnRhY3RzID0gW107CiAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMgPSBbXTsKICAgICAgdGhpcy5xdWF0Tm9ybWFsaXplU2tpcCA9IG9wdGlvbnMucXVhdE5vcm1hbGl6ZVNraXAgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucXVhdE5vcm1hbGl6ZVNraXAgOiAwOwogICAgICB0aGlzLnF1YXROb3JtYWxpemVGYXN0ID0gb3B0aW9ucy5xdWF0Tm9ybWFsaXplRmFzdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5xdWF0Tm9ybWFsaXplRmFzdCA6IGZhbHNlOwogICAgICB0aGlzLnRpbWUgPSAwLjA7CiAgICAgIHRoaXMuc3RlcG51bWJlciA9IDA7CiAgICAgIHRoaXMuZGVmYXVsdF9kdCA9IDEgLyA2MDsKICAgICAgdGhpcy5uZXh0SWQgPSAwOwogICAgICB0aGlzLmdyYXZpdHkgPSBuZXcgVmVjMygpOwoKICAgICAgaWYgKG9wdGlvbnMuZ3Jhdml0eSkgewogICAgICAgIHRoaXMuZ3Jhdml0eS5jb3B5KG9wdGlvbnMuZ3Jhdml0eSk7CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLmZyaWN0aW9uR3Jhdml0eSkgewogICAgICAgIHRoaXMuZnJpY3Rpb25HcmF2aXR5ID0gbmV3IFZlYzMoKTsKICAgICAgICB0aGlzLmZyaWN0aW9uR3Jhdml0eS5jb3B5KG9wdGlvbnMuZnJpY3Rpb25HcmF2aXR5KTsKICAgICAgfQoKICAgICAgdGhpcy5icm9hZHBoYXNlID0gb3B0aW9ucy5icm9hZHBoYXNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJyb2FkcGhhc2UgOiBuZXcgTmFpdmVCcm9hZHBoYXNlKCk7CiAgICAgIHRoaXMuYm9kaWVzID0gW107CiAgICAgIHRoaXMuaGFzQWN0aXZlQm9kaWVzID0gZmFsc2U7CiAgICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc29sdmVyIDogbmV3IEdTU29sdmVyKCk7CiAgICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTsKICAgICAgdGhpcy5uYXJyb3dwaGFzZSA9IG5ldyBOYXJyb3dwaGFzZSh0aGlzKTsKICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXggPSBuZXcgQXJyYXlDb2xsaXNpb25NYXRyaXgoKTsKICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cyA9IG5ldyBBcnJheUNvbGxpc2lvbk1hdHJpeCgpOwogICAgICB0aGlzLmJvZHlPdmVybGFwS2VlcGVyID0gbmV3IE92ZXJsYXBLZWVwZXIoKTsKICAgICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXIgPSBuZXcgT3ZlcmxhcEtlZXBlcigpOwogICAgICB0aGlzLmNvbnRhY3RtYXRlcmlhbHMgPSBbXTsKICAgICAgdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZSA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTsKICAgICAgdGhpcy5kZWZhdWx0TWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoJ2RlZmF1bHQnKTsKICAgICAgdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsID0gbmV3IENvbnRhY3RNYXRlcmlhbCh0aGlzLmRlZmF1bHRNYXRlcmlhbCwgdGhpcy5kZWZhdWx0TWF0ZXJpYWwsIHsKICAgICAgICBmcmljdGlvbjogMC4zLAogICAgICAgIHJlc3RpdHV0aW9uOiAwLjAKICAgICAgfSk7CiAgICAgIHRoaXMuZG9Qcm9maWxpbmcgPSBmYWxzZTsKICAgICAgdGhpcy5wcm9maWxlID0gewogICAgICAgIHNvbHZlOiAwLAogICAgICAgIG1ha2VDb250YWN0Q29uc3RyYWludHM6IDAsCiAgICAgICAgYnJvYWRwaGFzZTogMCwKICAgICAgICBpbnRlZ3JhdGU6IDAsCiAgICAgICAgbmFycm93cGhhc2U6IDAKICAgICAgfTsKICAgICAgdGhpcy5hY2N1bXVsYXRvciA9IDA7CiAgICAgIHRoaXMuc3Vic3lzdGVtcyA9IFtdOwogICAgICB0aGlzLmFkZEJvZHlFdmVudCA9IHsKICAgICAgICB0eXBlOiAnYWRkQm9keScsCiAgICAgICAgYm9keTogbnVsbAogICAgICB9OwogICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudCA9IHsKICAgICAgICB0eXBlOiAncmVtb3ZlQm9keScsCiAgICAgICAgYm9keTogbnVsbAogICAgICB9OwogICAgICB0aGlzLmlkVG9Cb2R5TWFwID0ge307CiAgICAgIHRoaXMuYnJvYWRwaGFzZS5zZXRXb3JsZCh0aGlzKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0IHRoZSBjb250YWN0IG1hdGVyaWFsIGJldHdlZW4gbWF0ZXJpYWxzIG0xIGFuZCBtMgogICAgICogQHJldHVybiBUaGUgY29udGFjdCBtYXRlcmlhbCBpZiBpdCB3YXMgZm91bmQuCiAgICAgKi8KCgogICAgZ2V0Q29udGFjdE1hdGVyaWFsKG0xLCBtMikgewogICAgICByZXR1cm4gdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5nZXQobTEuaWQsIG0yLmlkKTsKICAgIH0KICAgIC8qKgogICAgICogU3RvcmUgb2xkIGNvbGxpc2lvbiBzdGF0ZSBpbmZvCiAgICAgKi8KCgogICAgY29sbGlzaW9uTWF0cml4VGljaygpIHsKICAgICAgY29uc3QgdGVtcCA9IHRoaXMuY29sbGlzaW9uTWF0cml4UHJldmlvdXM7CiAgICAgIHRoaXMuY29sbGlzaW9uTWF0cml4UHJldmlvdXMgPSB0aGlzLmNvbGxpc2lvbk1hdHJpeDsKICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXggPSB0ZW1wOwogICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5yZXNldCgpOwogICAgICB0aGlzLmJvZHlPdmVybGFwS2VlcGVyLnRpY2soKTsKICAgICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXIudGljaygpOwogICAgfQogICAgLyoqCiAgICAgKiBBZGQgYSBjb25zdHJhaW50IHRvIHRoZSBzaW11bGF0aW9uLgogICAgICovCgoKICAgIGFkZENvbnN0cmFpbnQoYykgewogICAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goYyk7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYSBjb25zdHJhaW50CiAgICAgKi8KCgogICAgcmVtb3ZlQ29uc3RyYWludChjKSB7CiAgICAgIGNvbnN0IGlkeCA9IHRoaXMuY29uc3RyYWludHMuaW5kZXhPZihjKTsKCiAgICAgIGlmIChpZHggIT09IC0xKSB7CiAgICAgICAgdGhpcy5jb25zdHJhaW50cy5zcGxpY2UoaWR4LCAxKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSYXljYXN0IHRlc3QKICAgICAqIEBkZXByZWNhdGVkIFVzZSAucmF5Y2FzdEFsbCwgLnJheWNhc3RDbG9zZXN0IG9yIC5yYXljYXN0QW55IGluc3RlYWQuCiAgICAgKi8KCgogICAgcmF5VGVzdChmcm9tLCB0bywgcmVzdWx0KSB7CiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSYXljYXN0UmVzdWx0KSB7CiAgICAgICAgLy8gRG8gcmF5Y2FzdENsb3Nlc3QKICAgICAgICB0aGlzLnJheWNhc3RDbG9zZXN0KGZyb20sIHRvLCB7CiAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlCiAgICAgICAgfSwgcmVzdWx0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBEbyByYXljYXN0QWxsCiAgICAgICAgdGhpcy5yYXljYXN0QWxsKGZyb20sIHRvLCB7CiAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlCiAgICAgICAgfSwgcmVzdWx0KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSYXkgY2FzdCBhZ2FpbnN0IGFsbCBib2RpZXMuIFRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGhpdCB3aXRoIGEgUmF5Y2FzdFJlc3VsdCBhcyBzaW5nbGUgYXJndW1lbnQuCiAgICAgKiBAcmV0dXJuIFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC4KICAgICAqLwoKCiAgICByYXljYXN0QWxsKGZyb20sIHRvLCBvcHRpb25zLCBjYWxsYmFjaykgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBvcHRpb25zLm1vZGUgPSBSYXkuQUxMOwogICAgICBvcHRpb25zLmZyb20gPSBmcm9tOwogICAgICBvcHRpb25zLnRvID0gdG87CiAgICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBjYWxsYmFjazsKICAgICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTsKICAgIH0KICAgIC8qKgogICAgICogUmF5IGNhc3QsIGFuZCBzdG9wIGF0IHRoZSBmaXJzdCByZXN1bHQuIE5vdGUgdGhhdCB0aGUgb3JkZXIgaXMgcmFuZG9tIC0gYnV0IHRoZSBtZXRob2QgaXMgZmFzdC4KICAgICAqIEByZXR1cm4gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LgogICAgICovCgoKICAgIHJheWNhc3RBbnkoZnJvbSwgdG8sIG9wdGlvbnMsIHJlc3VsdCkgewogICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7CiAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICB9CgogICAgICBvcHRpb25zLm1vZGUgPSBSYXkuQU5ZOwogICAgICBvcHRpb25zLmZyb20gPSBmcm9tOwogICAgICBvcHRpb25zLnRvID0gdG87CiAgICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0OwogICAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpOwogICAgfQogICAgLyoqCiAgICAgKiBSYXkgY2FzdCwgYW5kIHJldHVybiBpbmZvcm1hdGlvbiBvZiB0aGUgY2xvc2VzdCBoaXQuCiAgICAgKiBAcmV0dXJuIFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC4KICAgICAqLwoKCiAgICByYXljYXN0Q2xvc2VzdChmcm9tLCB0bywgb3B0aW9ucywgcmVzdWx0KSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KCiAgICAgIG9wdGlvbnMubW9kZSA9IFJheS5DTE9TRVNUOwogICAgICBvcHRpb25zLmZyb20gPSBmcm9tOwogICAgICBvcHRpb25zLnRvID0gdG87CiAgICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0OwogICAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpOwogICAgfQogICAgLyoqCiAgICAgKiBBZGQgYSByaWdpZCBib2R5IHRvIHRoZSBzaW11bGF0aW9uLgogICAgICogQHRvZG8gSWYgdGhlIHNpbXVsYXRpb24gaGFzIG5vdCB5ZXQgc3RhcnRlZCwgd2h5IHJlY3JldGUgYW5kIGNvcHkgYXJyYXlzIGZvciBlYWNoIGJvZHk/IEFjY3VtdWxhdGUgaW4gZHluYW1pYyBhcnJheXMgaW4gdGhpcyBjYXNlLgogICAgICogQHRvZG8gQWRkaW5nIGFuIGFycmF5IG9mIGJvZGllcyBzaG91bGQgYmUgcG9zc2libGUuIFRoaXMgd291bGQgc2F2ZSBzb21lIGxvb3BzIHRvbwogICAgICovCgoKICAgIGFkZEJvZHkoYm9keSkgewogICAgICBpZiAodGhpcy5ib2RpZXMuaW5jbHVkZXMoYm9keSkpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGJvZHkuaW5kZXggPSB0aGlzLmJvZGllcy5sZW5ndGg7CiAgICAgIHRoaXMuYm9kaWVzLnB1c2goYm9keSk7CiAgICAgIGJvZHkud29ybGQgPSB0aGlzOwogICAgICBib2R5LmluaXRQb3NpdGlvbi5jb3B5KGJvZHkucG9zaXRpb24pOwogICAgICBib2R5LmluaXRWZWxvY2l0eS5jb3B5KGJvZHkudmVsb2NpdHkpOwogICAgICBib2R5LnRpbWVMYXN0U2xlZXB5ID0gdGhpcy50aW1lOwoKICAgICAgaWYgKGJvZHkgaW5zdGFuY2VvZiBCb2R5KSB7CiAgICAgICAgYm9keS5pbml0QW5ndWxhclZlbG9jaXR5LmNvcHkoYm9keS5hbmd1bGFyVmVsb2NpdHkpOwogICAgICAgIGJvZHkuaW5pdFF1YXRlcm5pb24uY29weShib2R5LnF1YXRlcm5pb24pOwogICAgICB9CgogICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXROdW1PYmplY3RzKHRoaXMuYm9kaWVzLmxlbmd0aCk7CiAgICAgIHRoaXMuYWRkQm9keUV2ZW50LmJvZHkgPSBib2R5OwogICAgICB0aGlzLmlkVG9Cb2R5TWFwW2JvZHkuaWRdID0gYm9keTsKICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuYWRkQm9keUV2ZW50KTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlIGEgcmlnaWQgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLgogICAgICovCgoKICAgIHJlbW92ZUJvZHkoYm9keSkgewogICAgICBib2R5LndvcmxkID0gbnVsbDsKICAgICAgY29uc3QgbiA9IHRoaXMuYm9kaWVzLmxlbmd0aCAtIDE7CiAgICAgIGNvbnN0IGJvZGllcyA9IHRoaXMuYm9kaWVzOwogICAgICBjb25zdCBpZHggPSBib2RpZXMuaW5kZXhPZihib2R5KTsKCiAgICAgIGlmIChpZHggIT09IC0xKSB7CiAgICAgICAgYm9kaWVzLnNwbGljZShpZHgsIDEpOyAvLyBUb2RvOiBzaG91bGQgdXNlIGEgZ2FyYmFnZSBmcmVlIG1ldGhvZAogICAgICAgIC8vIFJlY29tcHV0ZSBpbmRleAoKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gYm9kaWVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBib2RpZXNbaV0uaW5kZXggPSBpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXguc2V0TnVtT2JqZWN0cyhuKTsKICAgICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudC5ib2R5ID0gYm9keTsKICAgICAgICBkZWxldGUgdGhpcy5pZFRvQm9keU1hcFtib2R5LmlkXTsKICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5yZW1vdmVCb2R5RXZlbnQpOwogICAgICB9CiAgICB9CgogICAgZ2V0Qm9keUJ5SWQoaWQpIHsKICAgICAgcmV0dXJuIHRoaXMuaWRUb0JvZHlNYXBbaWRdOwogICAgfQogICAgLyoqCiAgICAgKiBAdG9kbyBNYWtlIGEgZmFzdGVyIG1hcAogICAgICovCgoKICAgIGdldFNoYXBlQnlJZChpZCkgewogICAgICBjb25zdCBib2RpZXMgPSB0aGlzLmJvZGllczsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3Qgc2hhcGVzID0gYm9kaWVzW2ldLnNoYXBlczsKCiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaGFwZXMubGVuZ3RoOyBqKyspIHsKICAgICAgICAgIGNvbnN0IHNoYXBlID0gc2hhcGVzW2pdOwoKICAgICAgICAgIGlmIChzaGFwZS5pZCA9PT0gaWQpIHsKICAgICAgICAgICAgcmV0dXJuIHNoYXBlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIEFkZHMgYSBjb250YWN0IG1hdGVyaWFsIHRvIHRoZSBXb3JsZAogICAgICovCgoKICAgIGFkZENvbnRhY3RNYXRlcmlhbChjbWF0KSB7CiAgICAgIC8vIEFkZCBjb250YWN0IG1hdGVyaWFsCiAgICAgIHRoaXMuY29udGFjdG1hdGVyaWFscy5wdXNoKGNtYXQpOyAvLyBBZGQgY3VycmVudCBjb250YWN0IG1hdGVyaWFsIHRvIHRoZSBtYXRlcmlhbCB0YWJsZQoKICAgICAgdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5zZXQoY21hdC5tYXRlcmlhbHNbMF0uaWQsIGNtYXQubWF0ZXJpYWxzWzFdLmlkLCBjbWF0KTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBhIGNvbnRhY3QgbWF0ZXJpYWwgZnJvbSB0aGUgV29ybGQuCiAgICAgKi8KCgogICAgcmVtb3ZlQ29udGFjdE1hdGVyaWFsKGNtYXQpIHsKICAgICAgY29uc3QgaWR4ID0gdGhpcy5jb250YWN0bWF0ZXJpYWxzLmluZGV4T2YoY21hdCk7CgogICAgICBpZiAoaWR4ID09PSAtMSkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdGhpcy5jb250YWN0bWF0ZXJpYWxzLnNwbGljZShpZHgsIDEpOwogICAgICB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlLmRlbGV0ZShjbWF0Lm1hdGVyaWFsc1swXS5pZCwgY21hdC5tYXRlcmlhbHNbMV0uaWQpOwogICAgfQogICAgLyoqCiAgICAgKiBTdGVwIHRoZSBzaW11bGF0aW9uIGZvcndhcmQga2VlcGluZyB0cmFjayBvZiBsYXN0IGNhbGxlZCB0aW1lCiAgICAgKiB0byBiZSBhYmxlIHRvIHN0ZXAgdGhlIHdvcmxkIGF0IGEgZml4ZWQgcmF0ZSwgaW5kZXBlbmRlbnRseSBvZiBmcmFtZXJhdGUuCiAgICAgKgogICAgICogQHBhcmFtIGR0IFRoZSBmaXhlZCB0aW1lIHN0ZXAgc2l6ZSB0byB1c2UgKGRlZmF1bHQ6IDEgLyA2MCkuCiAgICAgKiBAcGFyYW0gbWF4U3ViU3RlcHMgTWF4aW11bSBudW1iZXIgb2YgZml4ZWQgc3RlcHMgdG8gdGFrZSBwZXIgZnVuY3Rpb24gY2FsbCAoZGVmYXVsdDogMTApLgogICAgICogQHNlZSBodHRwczovL2dhZmZlcm9uZ2FtZXMuY29tL3Bvc3QvZml4X3lvdXJfdGltZXN0ZXAvCiAgICAgKiBAZXhhbXBsZQogICAgICogICAgIC8vIFJ1biB0aGUgc2ltdWxhdGlvbiBpbmRlcGVuZGVudGx5IG9mIGZyYW1lcmF0ZSBldmVyeSAxIC8gNjAgbXMKICAgICAqICAgICB3b3JsZC5maXhlZFN0ZXAoKQogICAgICovCgoKICAgIGZpeGVkU3RlcChkdCwgbWF4U3ViU3RlcHMpIHsKICAgICAgaWYgKGR0ID09PSB2b2lkIDApIHsKICAgICAgICBkdCA9IDEgLyA2MDsKICAgICAgfQoKICAgICAgaWYgKG1heFN1YlN0ZXBzID09PSB2b2lkIDApIHsKICAgICAgICBtYXhTdWJTdGVwcyA9IDEwOwogICAgICB9CgogICAgICBjb25zdCB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLyAxMDAwOyAvLyBzZWNvbmRzCgogICAgICBpZiAoIXRoaXMubGFzdENhbGxUaW1lKSB7CiAgICAgICAgdGhpcy5zdGVwKGR0LCB1bmRlZmluZWQsIG1heFN1YlN0ZXBzKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0Q2FsbGVkID0gdGltZSAtIHRoaXMubGFzdENhbGxUaW1lOwogICAgICAgIHRoaXMuc3RlcChkdCwgdGltZVNpbmNlTGFzdENhbGxlZCwgbWF4U3ViU3RlcHMpOwogICAgICB9CgogICAgICB0aGlzLmxhc3RDYWxsVGltZSA9IHRpbWU7CiAgICB9CiAgICAvKioKICAgICAqIFN0ZXAgdGhlIHBoeXNpY3Mgd29ybGQgZm9yd2FyZCBpbiB0aW1lLgogICAgICoKICAgICAqIFRoZXJlIGFyZSB0d28gbW9kZXMuIFRoZSBzaW1wbGUgbW9kZSBpcyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uLiBJbiB0aGlzIGNhc2UgeW91IG9ubHkgdXNlIHRoZSBmaXJzdCBhcmd1bWVudC4gVGhlIHNlY29uZCBjYXNlIHVzZXMgaW50ZXJwb2xhdGlvbi4gSW4gdGhhdCB5b3UgYWxzbyBwcm92aWRlIHRoZSB0aW1lIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCB1c2VkLCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIGZpeGVkIHRpbWVzdGVwcyB0byB0YWtlLgogICAgICoKICAgICAqIEBwYXJhbSBkdCBUaGUgZml4ZWQgdGltZSBzdGVwIHNpemUgdG8gdXNlLgogICAgICogQHBhcmFtIHRpbWVTaW5jZUxhc3RDYWxsZWQgVGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgZnVuY3Rpb24gd2FzIGxhc3QgY2FsbGVkLgogICAgICogQHBhcmFtIG1heFN1YlN0ZXBzIE1heGltdW0gbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHRvIHRha2UgcGVyIGZ1bmN0aW9uIGNhbGwgKGRlZmF1bHQ6IDEwKS4KICAgICAqIEBzZWUgaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTgwNDI2MTU0NTMxL2h0dHA6Ly9idWxsZXRwaHlzaWNzLm9yZy9tZWRpYXdpa2ktMS41LjgvaW5kZXgucGhwL1N0ZXBwaW5nX1RoZV9Xb3JsZCNXaGF0X2RvX3RoZV9wYXJhbWV0ZXJzX3RvX2J0RHluYW1pY3NXb3JsZDo6c3RlcFNpbXVsYXRpb25fbWVhbi4zRgogICAgICogQGV4YW1wbGUKICAgICAqICAgICAvLyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uCiAgICAgKiAgICAgd29ybGQuc3RlcCgxIC8gNjApCiAgICAgKi8KCgogICAgc3RlcChkdCwgdGltZVNpbmNlTGFzdENhbGxlZCwgbWF4U3ViU3RlcHMpIHsKICAgICAgaWYgKG1heFN1YlN0ZXBzID09PSB2b2lkIDApIHsKICAgICAgICBtYXhTdWJTdGVwcyA9IDEwOwogICAgICB9CgogICAgICBpZiAodGltZVNpbmNlTGFzdENhbGxlZCA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgLy8gRml4ZWQsIHNpbXBsZSBzdGVwcGluZwogICAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGR0KTsgLy8gSW5jcmVtZW50IHRpbWUKCiAgICAgICAgdGhpcy50aW1lICs9IGR0OwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuYWNjdW11bGF0b3IgKz0gdGltZVNpbmNlTGFzdENhbGxlZDsKICAgICAgICBjb25zdCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpOwogICAgICAgIGxldCBzdWJzdGVwcyA9IDA7CgogICAgICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IGR0ICYmIHN1YnN0ZXBzIDwgbWF4U3ViU3RlcHMpIHsKICAgICAgICAgIC8vIERvIGZpeGVkIHN0ZXBzIHRvIGNhdGNoIHVwCiAgICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7CiAgICAgICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IGR0OwogICAgICAgICAgc3Vic3RlcHMrKzsKCiAgICAgICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSB0MCA+IGR0ICogMTAwMCkgewogICAgICAgICAgICAvLyBUaGUgZnJhbWVyYXRlIGlzIG5vdCBpbnRlcmFjdGl2ZSBhbnltb3JlLgogICAgICAgICAgICAvLyBXZSBhcmUgYmVsb3cgdGhlIHRhcmdldCBmcmFtZXJhdGUuCiAgICAgICAgICAgIC8vIEJldHRlciBiYWlsIG91dC4KICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBSZW1vdmUgdGhlIGV4Y2VzcyBhY2N1bXVsYXRvciwgc2luY2Ugd2UgbWF5IG5vdAogICAgICAgIC8vIGhhdmUgaGFkIGVub3VnaCBzdWJzdGVwcyBhdmFpbGFibGUgdG8gY2F0Y2ggdXAKCgogICAgICAgIHRoaXMuYWNjdW11bGF0b3IgPSB0aGlzLmFjY3VtdWxhdG9yICUgZHQ7CiAgICAgICAgY29uc3QgdCA9IHRoaXMuYWNjdW11bGF0b3IgLyBkdDsKCiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogIT09IHRoaXMuYm9kaWVzLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBjb25zdCBiID0gdGhpcy5ib2RpZXNbal07CiAgICAgICAgICBiLnByZXZpb3VzUG9zaXRpb24ubGVycChiLnBvc2l0aW9uLCB0LCBiLmludGVycG9sYXRlZFBvc2l0aW9uKTsKICAgICAgICAgIGIucHJldmlvdXNRdWF0ZXJuaW9uLnNsZXJwKGIucXVhdGVybmlvbiwgdCwgYi5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uKTsKICAgICAgICAgIGIucHJldmlvdXNRdWF0ZXJuaW9uLm5vcm1hbGl6ZSgpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy50aW1lICs9IHRpbWVTaW5jZUxhc3RDYWxsZWQ7CiAgICAgIH0KICAgIH0KCiAgICBpbnRlcm5hbFN0ZXAoZHQpIHsKICAgICAgdGhpcy5kdCA9IGR0OwogICAgICBjb25zdCBjb250YWN0cyA9IHRoaXMuY29udGFjdHM7CiAgICAgIGNvbnN0IHAxID0gV29ybGRfc3RlcF9wMTsKICAgICAgY29uc3QgcDIgPSBXb3JsZF9zdGVwX3AyOwogICAgICBjb25zdCBOID0gdGhpcy5ib2RpZXMubGVuZ3RoOwogICAgICBjb25zdCBib2RpZXMgPSB0aGlzLmJvZGllczsKICAgICAgY29uc3Qgc29sdmVyID0gdGhpcy5zb2x2ZXI7CiAgICAgIGNvbnN0IGdyYXZpdHkgPSB0aGlzLmdyYXZpdHk7CiAgICAgIGNvbnN0IGRvUHJvZmlsaW5nID0gdGhpcy5kb1Byb2ZpbGluZzsKICAgICAgY29uc3QgcHJvZmlsZSA9IHRoaXMucHJvZmlsZTsKICAgICAgY29uc3QgRFlOQU1JQyA9IEJvZHkuRFlOQU1JQzsKICAgICAgbGV0IHByb2ZpbGluZ1N0YXJ0ID0gLUluZmluaXR5OwogICAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7CiAgICAgIGNvbnN0IGZyaWN0aW9uRXF1YXRpb25Qb29sID0gV29ybGRfc3RlcF9mcmljdGlvbkVxdWF0aW9uUG9vbDsKICAgICAgZ3Jhdml0eS5sZW5ndGgoKTsKICAgICAgY29uc3QgZ3ggPSBncmF2aXR5Lng7CiAgICAgIGNvbnN0IGd5ID0gZ3Jhdml0eS55OwogICAgICBjb25zdCBneiA9IGdyYXZpdHkuejsKICAgICAgbGV0IGkgPSAwOwoKICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7CiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTsKICAgICAgfSAvLyBBZGQgZ3Jhdml0eSB0byBhbGwgb2JqZWN0cwoKCiAgICAgIGZvciAoaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIGNvbnN0IGJpID0gYm9kaWVzW2ldOwoKICAgICAgICBpZiAoYmkudHlwZSA9PT0gRFlOQU1JQykgewogICAgICAgICAgLy8gT25seSBmb3IgZHluYW1pYyBib2RpZXMKICAgICAgICAgIGNvbnN0IGYgPSBiaS5mb3JjZTsKICAgICAgICAgIGNvbnN0IG0gPSBiaS5tYXNzOwogICAgICAgICAgZi54ICs9IG0gKiBneDsKICAgICAgICAgIGYueSArPSBtICogZ3k7CiAgICAgICAgICBmLnogKz0gbSAqIGd6OwogICAgICAgIH0KICAgICAgfSAvLyBVcGRhdGUgc3Vic3lzdGVtcwoKCiAgICAgIGZvciAobGV0IGkgPSAwLCBOc3Vic3lzdGVtcyA9IHRoaXMuc3Vic3lzdGVtcy5sZW5ndGg7IGkgIT09IE5zdWJzeXN0ZW1zOyBpKyspIHsKICAgICAgICB0aGlzLnN1YnN5c3RlbXNbaV0udXBkYXRlKCk7CiAgICAgIH0gLy8gQ29sbGlzaW9uIGRldGVjdGlvbgoKCiAgICAgIGlmIChkb1Byb2ZpbGluZykgewogICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7CiAgICAgIH0KCiAgICAgIHAxLmxlbmd0aCA9IDA7IC8vIENsZWFuIHVwIHBhaXIgYXJyYXlzIGZyb20gbGFzdCBzdGVwCgogICAgICBwMi5sZW5ndGggPSAwOwogICAgICB0aGlzLmJyb2FkcGhhc2UuY29sbGlzaW9uUGFpcnModGhpcywgcDEsIHAyKTsKCiAgICAgIGlmIChkb1Byb2ZpbGluZykgewogICAgICAgIHByb2ZpbGUuYnJvYWRwaGFzZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7CiAgICAgIH0gLy8gUmVtb3ZlIGNvbnN0cmFpbmVkIHBhaXJzIHdpdGggY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZQoKCiAgICAgIGxldCBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7CgogICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykgewogICAgICAgIGNvbnN0IGMgPSBjb25zdHJhaW50c1tpXTsKCiAgICAgICAgaWYgKCFjLmNvbGxpZGVDb25uZWN0ZWQpIHsKICAgICAgICAgIGZvciAobGV0IGogPSBwMS5sZW5ndGggLSAxOyBqID49IDA7IGogLT0gMSkgewogICAgICAgICAgICBpZiAoYy5ib2R5QSA9PT0gcDFbal0gJiYgYy5ib2R5QiA9PT0gcDJbal0gfHwgYy5ib2R5QiA9PT0gcDFbal0gJiYgYy5ib2R5QSA9PT0gcDJbal0pIHsKICAgICAgICAgICAgICBwMS5zcGxpY2UoaiwgMSk7CiAgICAgICAgICAgICAgcDIuc3BsaWNlKGosIDEpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeFRpY2soKTsgLy8gR2VuZXJhdGUgY29udGFjdHMKCiAgICAgIGlmIChkb1Byb2ZpbGluZykgewogICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IG9sZGNvbnRhY3RzID0gV29ybGRfc3RlcF9vbGRDb250YWN0czsKICAgICAgY29uc3QgTm9sZENvbnRhY3RzID0gY29udGFjdHMubGVuZ3RoOwoKICAgICAgZm9yIChpID0gMDsgaSAhPT0gTm9sZENvbnRhY3RzOyBpKyspIHsKICAgICAgICBvbGRjb250YWN0cy5wdXNoKGNvbnRhY3RzW2ldKTsKICAgICAgfQoKICAgICAgY29udGFjdHMubGVuZ3RoID0gMDsgLy8gVHJhbnNmZXIgRnJpY3Rpb25FcXVhdGlvbiBmcm9tIGN1cnJlbnQgbGlzdCB0byB0aGUgcG9vbCBmb3IgcmV1c2UKCiAgICAgIGNvbnN0IE5vbGRGcmljdGlvbkVxdWF0aW9ucyA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoOwoKICAgICAgZm9yIChpID0gMDsgaSAhPT0gTm9sZEZyaWN0aW9uRXF1YXRpb25zOyBpKyspIHsKICAgICAgICBmcmljdGlvbkVxdWF0aW9uUG9vbC5wdXNoKHRoaXMuZnJpY3Rpb25FcXVhdGlvbnNbaV0pOwogICAgICB9CgogICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCA9IDA7CiAgICAgIHRoaXMubmFycm93cGhhc2UuZ2V0Q29udGFjdHMocDEsIHAyLCB0aGlzLCBjb250YWN0cywgb2xkY29udGFjdHMsIC8vIFRvIGJlIHJldXNlZAogICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLCBmcmljdGlvbkVxdWF0aW9uUG9vbCk7CgogICAgICBpZiAoZG9Qcm9maWxpbmcpIHsKICAgICAgICBwcm9maWxlLm5hcnJvd3BoYXNlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDsKICAgICAgfSAvLyBMb29wIG92ZXIgYWxsIGNvbGxpc2lvbnMKCgogICAgICBpZiAoZG9Qcm9maWxpbmcpIHsKICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpOwogICAgICB9IC8vIEFkZCBhbGwgZnJpY3Rpb24gZXFzCgoKICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoOyBpKyspIHsKICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb24odGhpcy5mcmljdGlvbkVxdWF0aW9uc1tpXSk7CiAgICAgIH0KCiAgICAgIGNvbnN0IG5jb250YWN0cyA9IGNvbnRhY3RzLmxlbmd0aDsKCiAgICAgIGZvciAobGV0IGsgPSAwOyBrICE9PSBuY29udGFjdHM7IGsrKykgewogICAgICAgIC8vIEN1cnJlbnQgY29udGFjdAogICAgICAgIGNvbnN0IGMgPSBjb250YWN0c1trXTsgLy8gR2V0IGN1cnJlbnQgY29sbGlzaW9uIGluZGVjZXMKCiAgICAgICAgY29uc3QgYmkgPSBjLmJpOwogICAgICAgIGNvbnN0IGJqID0gYy5iajsKICAgICAgICBjb25zdCBzaSA9IGMuc2k7CiAgICAgICAgY29uc3Qgc2ogPSBjLnNqOyAvLyBHZXQgY29sbGlzaW9uIHByb3BlcnRpZXMKCiAgICAgICAgbGV0IGNtOwoKICAgICAgICBpZiAoYmkubWF0ZXJpYWwgJiYgYmoubWF0ZXJpYWwpIHsKICAgICAgICAgIGNtID0gdGhpcy5nZXRDb250YWN0TWF0ZXJpYWwoYmkubWF0ZXJpYWwsIGJqLm1hdGVyaWFsKSB8fCB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNtID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsOwogICAgICAgIH0gLy8gYy5lbmFibGVkID0gYmkuY29sbGlzaW9uUmVzcG9uc2UgJiYgYmouY29sbGlzaW9uUmVzcG9uc2UgJiYgc2kuY29sbGlzaW9uUmVzcG9uc2UgJiYgc2ouY29sbGlzaW9uUmVzcG9uc2U7CgoKICAgICAgICBjbS5mcmljdGlvbjsgLy8gYy5yZXN0aXR1dGlvbiA9IGNtLnJlc3RpdHV0aW9uOwogICAgICAgIC8vIElmIGZyaWN0aW9uIG9yIHJlc3RpdHV0aW9uIHdlcmUgc3BlY2lmaWVkIGluIHRoZSBtYXRlcmlhbCwgdXNlIHRoZW0KCiAgICAgICAgaWYgKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKSB7CiAgICAgICAgICBpZiAoYmkubWF0ZXJpYWwuZnJpY3Rpb24gPj0gMCAmJiBiai5tYXRlcmlhbC5mcmljdGlvbiA+PSAwKSB7CiAgICAgICAgICAgIGJpLm1hdGVyaWFsLmZyaWN0aW9uICogYmoubWF0ZXJpYWwuZnJpY3Rpb247CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGJpLm1hdGVyaWFsLnJlc3RpdHV0aW9uID49IDAgJiYgYmoubWF0ZXJpYWwucmVzdGl0dXRpb24gPj0gMCkgewogICAgICAgICAgICBjLnJlc3RpdHV0aW9uID0gYmkubWF0ZXJpYWwucmVzdGl0dXRpb24gKiBiai5tYXRlcmlhbC5yZXN0aXR1dGlvbjsKICAgICAgICAgIH0KICAgICAgICB9IC8vIGMuc2V0U3Bvb2tQYXJhbXMoCiAgICAgICAgLy8gICAgICAgICAgIGNtLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcywKICAgICAgICAvLyAgICAgICAgICAgY20uY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbiwKICAgICAgICAvLyAgICAgICAgICAgZHQKICAgICAgICAvLyAgICAgICApOwoKCiAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9uKGMpOyAvLyAvLyBBZGQgZnJpY3Rpb24gY29uc3RyYWludCBlcXVhdGlvbgogICAgICAgIC8vIGlmKG11ID4gMCl7CiAgICAgICAgLy8gCS8vIENyZWF0ZSAyIHRhbmdlbnQgZXF1YXRpb25zCiAgICAgICAgLy8gCWNvbnN0IG11ZyA9IG11ICogZ25vcm07CiAgICAgICAgLy8gCWNvbnN0IHJlZHVjZWRNYXNzID0gKGJpLmludk1hc3MgKyBiai5pbnZNYXNzKTsKICAgICAgICAvLyAJaWYocmVkdWNlZE1hc3MgPiAwKXsKICAgICAgICAvLyAJCXJlZHVjZWRNYXNzID0gMS9yZWR1Y2VkTWFzczsKICAgICAgICAvLyAJfQogICAgICAgIC8vIAljb25zdCBwb29sID0gZnJpY3Rpb25FcXVhdGlvblBvb2w7CiAgICAgICAgLy8gCWNvbnN0IGMxID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYmksYmosbXVnKnJlZHVjZWRNYXNzKTsKICAgICAgICAvLyAJY29uc3QgYzIgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgRnJpY3Rpb25FcXVhdGlvbihiaSxiaixtdWcqcmVkdWNlZE1hc3MpOwogICAgICAgIC8vIAl0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goYzEsIGMyKTsKICAgICAgICAvLyAJYzEuYmkgPSBjMi5iaSA9IGJpOwogICAgICAgIC8vIAljMS5iaiA9IGMyLmJqID0gYmo7CiAgICAgICAgLy8gCWMxLm1pbkZvcmNlID0gYzIubWluRm9yY2UgPSAtbXVnKnJlZHVjZWRNYXNzOwogICAgICAgIC8vIAljMS5tYXhGb3JjZSA9IGMyLm1heEZvcmNlID0gbXVnKnJlZHVjZWRNYXNzOwogICAgICAgIC8vIAkvLyBDb3B5IG92ZXIgdGhlIHJlbGF0aXZlIHZlY3RvcnMKICAgICAgICAvLyAJYzEucmkuY29weShjLnJpKTsKICAgICAgICAvLyAJYzEucmouY29weShjLnJqKTsKICAgICAgICAvLyAJYzIucmkuY29weShjLnJpKTsKICAgICAgICAvLyAJYzIucmouY29weShjLnJqKTsKICAgICAgICAvLyAJLy8gQ29uc3RydWN0IHRhbmdlbnRzCiAgICAgICAgLy8gCWMubmkudGFuZ2VudHMoYzEudCwgYzIudCk7CiAgICAgICAgLy8gICAgICAgICAgIC8vIFNldCBzcG9vayBwYXJhbXMKICAgICAgICAvLyAgICAgICAgICAgYzEuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIGR0KTsKICAgICAgICAvLyAgICAgICAgICAgYzIuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIGR0KTsKICAgICAgICAvLyAgICAgICAgICAgYzEuZW5hYmxlZCA9IGMyLmVuYWJsZWQgPSBjLmVuYWJsZWQ7CiAgICAgICAgLy8gCS8vIEFkZCBlcXVhdGlvbnMgdG8gc29sdmVyCiAgICAgICAgLy8gCXNvbHZlci5hZGRFcXVhdGlvbihjMSk7CiAgICAgICAgLy8gCXNvbHZlci5hZGRFcXVhdGlvbihjMik7CiAgICAgICAgLy8gfQoKICAgICAgICBpZiAoYmkuYWxsb3dTbGVlcCAmJiBiaS50eXBlID09PSBCb2R5LkRZTkFNSUMgJiYgYmkuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBiai5zbGVlcFN0YXRlID09PSBCb2R5LkFXQUtFICYmIGJqLnR5cGUgIT09IEJvZHkuU1RBVElDKSB7CiAgICAgICAgICBjb25zdCBzcGVlZFNxdWFyZWRCID0gYmoudmVsb2NpdHkubGVuZ3RoU3F1YXJlZCgpICsgYmouYW5ndWxhclZlbG9jaXR5Lmxlbmd0aFNxdWFyZWQoKTsKICAgICAgICAgIGNvbnN0IHNwZWVkTGltaXRTcXVhcmVkQiA9IGJqLnNsZWVwU3BlZWRMaW1pdCAqKiAyOwoKICAgICAgICAgIGlmIChzcGVlZFNxdWFyZWRCID49IHNwZWVkTGltaXRTcXVhcmVkQiAqIDIpIHsKICAgICAgICAgICAgYmkud2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAoYmouYWxsb3dTbGVlcCAmJiBiai50eXBlID09PSBCb2R5LkRZTkFNSUMgJiYgYmouc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBiaS5zbGVlcFN0YXRlID09PSBCb2R5LkFXQUtFICYmIGJpLnR5cGUgIT09IEJvZHkuU1RBVElDKSB7CiAgICAgICAgICBjb25zdCBzcGVlZFNxdWFyZWRBID0gYmkudmVsb2NpdHkubGVuZ3RoU3F1YXJlZCgpICsgYmkuYW5ndWxhclZlbG9jaXR5Lmxlbmd0aFNxdWFyZWQoKTsKICAgICAgICAgIGNvbnN0IHNwZWVkTGltaXRTcXVhcmVkQSA9IGJpLnNsZWVwU3BlZWRMaW1pdCAqKiAyOwoKICAgICAgICAgIGlmIChzcGVlZFNxdWFyZWRBID49IHNwZWVkTGltaXRTcXVhcmVkQSAqIDIpIHsKICAgICAgICAgICAgYmoud2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBOb3cgd2Uga25vdyB0aGF0IGkgYW5kIGogYXJlIGluIGNvbnRhY3QuIFNldCBjb2xsaXNpb24gbWF0cml4IHN0YXRlCgoKICAgICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXQoYmksIGJqLCB0cnVlKTsKCiAgICAgICAgaWYgKCF0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzLmdldChiaSwgYmopKSB7CiAgICAgICAgICAvLyBGaXJzdCBjb250YWN0IQogICAgICAgICAgLy8gV2UgcmV1c2UgdGhlIGNvbGxpZGVFdmVudCBvYmplY3QsIG90aGVyd2lzZSB3ZSB3aWxsIGVuZCB1cCBjcmVhdGluZyBuZXcgb2JqZWN0cyBmb3IgZWFjaCBuZXcgY29udGFjdCwgZXZlbiBpZiB0aGVyZSdzIG5vIGV2ZW50IGxpc3RlbmVyIGF0dGFjaGVkLgogICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuYm9keSA9IGJqOwogICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuY29udGFjdCA9IGM7CiAgICAgICAgICBiaS5kaXNwYXRjaEV2ZW50KFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50KTsKICAgICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50LmJvZHkgPSBiaTsKICAgICAgICAgIGJqLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci5zZXQoYmkuaWQsIGJqLmlkKTsKICAgICAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5zZXQoc2kuaWQsIHNqLmlkKTsKICAgICAgfQoKICAgICAgdGhpcy5lbWl0Q29udGFjdEV2ZW50cygpOwoKICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7CiAgICAgICAgcHJvZmlsZS5tYWtlQ29udGFjdENvbnN0cmFpbnRzID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDsKICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpOwogICAgICB9IC8vIFdha2UgdXAgYm9kaWVzCgoKICAgICAgZm9yIChpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgY29uc3QgYmkgPSBib2RpZXNbaV07CgogICAgICAgIGlmIChiaS53YWtlVXBBZnRlck5hcnJvd3BoYXNlKSB7CiAgICAgICAgICBiaS53YWtlVXAoKTsKICAgICAgICAgIGJpLndha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTsKICAgICAgICB9CiAgICAgIH0gLy8gQWRkIHVzZXItYWRkZWQgY29uc3RyYWludHMKCgogICAgICBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7CgogICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykgewogICAgICAgIGNvbnN0IGMgPSBjb25zdHJhaW50c1tpXTsKICAgICAgICBjLnVwZGF0ZSgpOwoKICAgICAgICBmb3IgKGxldCBqID0gMCwgTmVxID0gYy5lcXVhdGlvbnMubGVuZ3RoOyBqICE9PSBOZXE7IGorKykgewogICAgICAgICAgY29uc3QgZXEgPSBjLmVxdWF0aW9uc1tqXTsKICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbihlcSk7CiAgICAgICAgfQogICAgICB9IC8vIFNvbHZlIHRoZSBjb25zdHJhaW5lZCBzeXN0ZW0KCgogICAgICBzb2x2ZXIuc29sdmUoZHQsIHRoaXMpOwoKICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7CiAgICAgICAgcHJvZmlsZS5zb2x2ZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7CiAgICAgIH0gLy8gUmVtb3ZlIGFsbCBjb250YWN0cyBmcm9tIHNvbHZlcgoKCiAgICAgIHNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTsgLy8gQXBwbHkgZGFtcGluZywgc2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9idWxsZXQvaXNzdWVzL2RldGFpbD9pZD03NCBmb3IgZGV0YWlscwoKICAgICAgY29uc3QgcG93ID0gTWF0aC5wb3c7CgogICAgICBmb3IgKGkgPSAwOyBpICE9PSBOOyBpKyspIHsKICAgICAgICBjb25zdCBiaSA9IGJvZGllc1tpXTsKCiAgICAgICAgaWYgKGJpLnR5cGUgJiBEWU5BTUlDKSB7CiAgICAgICAgICAvLyBPbmx5IGZvciBkeW5hbWljIGJvZGllcwogICAgICAgICAgY29uc3QgbGQgPSBwb3coMS4wIC0gYmkubGluZWFyRGFtcGluZywgZHQpOwogICAgICAgICAgY29uc3QgdiA9IGJpLnZlbG9jaXR5OwogICAgICAgICAgdi5zY2FsZShsZCwgdik7CiAgICAgICAgICBjb25zdCBhdiA9IGJpLmFuZ3VsYXJWZWxvY2l0eTsKCiAgICAgICAgICBpZiAoYXYpIHsKICAgICAgICAgICAgY29uc3QgYWQgPSBwb3coMS4wIC0gYmkuYW5ndWxhckRhbXBpbmcsIGR0KTsKICAgICAgICAgICAgYXYuc2NhbGUoYWQsIGF2KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX3ByZVN0ZXBFdmVudCk7IC8vIExlYXAgZnJvZwogICAgICAvLyB2bmV3ID0gdiArIGgqZi9tCiAgICAgIC8vIHhuZXcgPSB4ICsgaCp2bmV3CgogICAgICBpZiAoZG9Qcm9maWxpbmcpIHsKICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpOwogICAgICB9CgogICAgICBjb25zdCBzdGVwbnVtYmVyID0gdGhpcy5zdGVwbnVtYmVyOwogICAgICBjb25zdCBxdWF0Tm9ybWFsaXplID0gc3RlcG51bWJlciAlICh0aGlzLnF1YXROb3JtYWxpemVTa2lwICsgMSkgPT09IDA7CiAgICAgIGNvbnN0IHF1YXROb3JtYWxpemVGYXN0ID0gdGhpcy5xdWF0Tm9ybWFsaXplRmFzdDsKCiAgICAgIGZvciAoaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIGJvZGllc1tpXS5pbnRlZ3JhdGUoZHQsIHF1YXROb3JtYWxpemUsIHF1YXROb3JtYWxpemVGYXN0KTsKICAgICAgfQoKICAgICAgdGhpcy5jbGVhckZvcmNlcygpOwogICAgICB0aGlzLmJyb2FkcGhhc2UuZGlydHkgPSB0cnVlOwoKICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7CiAgICAgICAgcHJvZmlsZS5pbnRlZ3JhdGUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0OwogICAgICB9IC8vIFVwZGF0ZSBzdGVwIG51bWJlcgoKCiAgICAgIHRoaXMuc3RlcG51bWJlciArPSAxOwogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9wb3N0U3RlcEV2ZW50KTsgLy8gU2xlZXBpbmcgdXBkYXRlCgogICAgICBsZXQgaGFzQWN0aXZlQm9kaWVzID0gdHJ1ZTsKCiAgICAgIGlmICh0aGlzLmFsbG93U2xlZXApIHsKICAgICAgICBoYXNBY3RpdmVCb2RpZXMgPSBmYWxzZTsKCiAgICAgICAgZm9yIChpID0gMDsgaSAhPT0gTjsgaSsrKSB7CiAgICAgICAgICBjb25zdCBiaSA9IGJvZGllc1tpXTsKICAgICAgICAgIGJpLnNsZWVwVGljayh0aGlzLnRpbWUpOwoKICAgICAgICAgIGlmIChiaS5zbGVlcFN0YXRlICE9PSBCb2R5LlNMRUVQSU5HKSB7CiAgICAgICAgICAgIGhhc0FjdGl2ZUJvZGllcyA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmhhc0FjdGl2ZUJvZGllcyA9IGhhc0FjdGl2ZUJvZGllczsKICAgIH0KCiAgICBlbWl0Q29udGFjdEV2ZW50cygpIHsKICAgICAgY29uc3QgaGFzQmVnaW5Db250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdiZWdpbkNvbnRhY3QnKTsKICAgICAgY29uc3QgaGFzRW5kQ29udGFjdCA9IHRoaXMuaGFzQW55RXZlbnRMaXN0ZW5lcignZW5kQ29udGFjdCcpOwoKICAgICAgaWYgKGhhc0JlZ2luQ29udGFjdCB8fCBoYXNFbmRDb250YWN0KSB7CiAgICAgICAgdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci5nZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpOwogICAgICB9CgogICAgICBpZiAoaGFzQmVnaW5Db250YWN0KSB7CiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhZGRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7CiAgICAgICAgICBiZWdpbkNvbnRhY3RFdmVudC5ib2R5QSA9IHRoaXMuZ2V0Qm9keUJ5SWQoYWRkaXRpb25zW2ldKTsKICAgICAgICAgIGJlZ2luQ29udGFjdEV2ZW50LmJvZHlCID0gdGhpcy5nZXRCb2R5QnlJZChhZGRpdGlvbnNbaSArIDFdKTsKICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChiZWdpbkNvbnRhY3RFdmVudCk7CiAgICAgICAgfQoKICAgICAgICBiZWdpbkNvbnRhY3RFdmVudC5ib2R5QSA9IGJlZ2luQ29udGFjdEV2ZW50LmJvZHlCID0gbnVsbDsKICAgICAgfQoKICAgICAgaWYgKGhhc0VuZENvbnRhY3QpIHsKICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHJlbW92YWxzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikgewogICAgICAgICAgZW5kQ29udGFjdEV2ZW50LmJvZHlBID0gdGhpcy5nZXRCb2R5QnlJZChyZW1vdmFsc1tpXSk7CiAgICAgICAgICBlbmRDb250YWN0RXZlbnQuYm9keUIgPSB0aGlzLmdldEJvZHlCeUlkKHJlbW92YWxzW2kgKyAxXSk7CiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZW5kQ29udGFjdEV2ZW50KTsKICAgICAgICB9CgogICAgICAgIGVuZENvbnRhY3RFdmVudC5ib2R5QSA9IGVuZENvbnRhY3RFdmVudC5ib2R5QiA9IG51bGw7CiAgICAgIH0KCiAgICAgIGFkZGl0aW9ucy5sZW5ndGggPSByZW1vdmFscy5sZW5ndGggPSAwOwogICAgICBjb25zdCBoYXNCZWdpblNoYXBlQ29udGFjdCA9IHRoaXMuaGFzQW55RXZlbnRMaXN0ZW5lcignYmVnaW5TaGFwZUNvbnRhY3QnKTsKICAgICAgY29uc3QgaGFzRW5kU2hhcGVDb250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdlbmRTaGFwZUNvbnRhY3QnKTsKCiAgICAgIGlmIChoYXNCZWdpblNoYXBlQ29udGFjdCB8fCBoYXNFbmRTaGFwZUNvbnRhY3QpIHsKICAgICAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5nZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpOwogICAgICB9CgogICAgICBpZiAoaGFzQmVnaW5TaGFwZUNvbnRhY3QpIHsKICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFkZGl0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHsKICAgICAgICAgIGNvbnN0IHNoYXBlQSA9IHRoaXMuZ2V0U2hhcGVCeUlkKGFkZGl0aW9uc1tpXSk7CiAgICAgICAgICBjb25zdCBzaGFwZUIgPSB0aGlzLmdldFNoYXBlQnlJZChhZGRpdGlvbnNbaSArIDFdKTsKICAgICAgICAgIGJlZ2luU2hhcGVDb250YWN0RXZlbnQuc2hhcGVBID0gc2hhcGVBOwogICAgICAgICAgYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5zaGFwZUIgPSBzaGFwZUI7CiAgICAgICAgICBpZiAoc2hhcGVBKSBiZWdpblNoYXBlQ29udGFjdEV2ZW50LmJvZHlBID0gc2hhcGVBLmJvZHk7CiAgICAgICAgICBpZiAoc2hhcGVCKSBiZWdpblNoYXBlQ29udGFjdEV2ZW50LmJvZHlCID0gc2hhcGVCLmJvZHk7CiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoYmVnaW5TaGFwZUNvbnRhY3RFdmVudCk7CiAgICAgICAgfQoKICAgICAgICBiZWdpblNoYXBlQ29udGFjdEV2ZW50LmJvZHlBID0gYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5ib2R5QiA9IGJlZ2luU2hhcGVDb250YWN0RXZlbnQuc2hhcGVBID0gYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5zaGFwZUIgPSBudWxsOwogICAgICB9CgogICAgICBpZiAoaGFzRW5kU2hhcGVDb250YWN0KSB7CiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSByZW1vdmFscy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHsKICAgICAgICAgIGNvbnN0IHNoYXBlQSA9IHRoaXMuZ2V0U2hhcGVCeUlkKHJlbW92YWxzW2ldKTsKICAgICAgICAgIGNvbnN0IHNoYXBlQiA9IHRoaXMuZ2V0U2hhcGVCeUlkKHJlbW92YWxzW2kgKyAxXSk7CiAgICAgICAgICBlbmRTaGFwZUNvbnRhY3RFdmVudC5zaGFwZUEgPSBzaGFwZUE7CiAgICAgICAgICBlbmRTaGFwZUNvbnRhY3RFdmVudC5zaGFwZUIgPSBzaGFwZUI7CiAgICAgICAgICBpZiAoc2hhcGVBKSBlbmRTaGFwZUNvbnRhY3RFdmVudC5ib2R5QSA9IHNoYXBlQS5ib2R5OwogICAgICAgICAgaWYgKHNoYXBlQikgZW5kU2hhcGVDb250YWN0RXZlbnQuYm9keUIgPSBzaGFwZUIuYm9keTsKICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlbmRTaGFwZUNvbnRhY3RFdmVudCk7CiAgICAgICAgfQoKICAgICAgICBlbmRTaGFwZUNvbnRhY3RFdmVudC5ib2R5QSA9IGVuZFNoYXBlQ29udGFjdEV2ZW50LmJvZHlCID0gZW5kU2hhcGVDb250YWN0RXZlbnQuc2hhcGVBID0gZW5kU2hhcGVDb250YWN0RXZlbnQuc2hhcGVCID0gbnVsbDsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIGFsbCBib2R5IGZvcmNlcyBpbiB0aGUgd29ybGQgdG8gemVyby4KICAgICAqLwoKCiAgICBjbGVhckZvcmNlcygpIHsKICAgICAgY29uc3QgYm9kaWVzID0gdGhpcy5ib2RpZXM7CiAgICAgIGNvbnN0IE4gPSBib2RpZXMubGVuZ3RoOwoKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE47IGkrKykgewogICAgICAgIGNvbnN0IGIgPSBib2RpZXNbaV07CiAgICAgICAgYi5mb3JjZTsKICAgICAgICBiLnRvcnF1ZTsKICAgICAgICBiLmZvcmNlLnNldCgwLCAwLCAwKTsKICAgICAgICBiLnRvcnF1ZS5zZXQoMCwgMCwgMCk7CiAgICAgIH0KICAgIH0KCiAgfSAvLyBUZW1wIHN0dWZmCgogIG5ldyBBQUJCKCk7CiAgY29uc3QgdG1wUmF5ID0gbmV3IFJheSgpOyAvLyBwZXJmb3JtYW5jZS5ub3coKSBmYWxsYmFjayBvbiBEYXRlLm5vdygpCgogIGNvbnN0IHBlcmZvcm1hbmNlID0gZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSB8fCB7fTsKCiAgaWYgKCFwZXJmb3JtYW5jZS5ub3cpIHsKICAgIGxldCBub3dPZmZzZXQgPSBEYXRlLm5vdygpOwoKICAgIGlmIChwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCkgewogICAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0OwogICAgfQoKICAgIHBlcmZvcm1hbmNlLm5vdyA9ICgpID0+IERhdGUubm93KCkgLSBub3dPZmZzZXQ7CiAgfQoKICBuZXcgVmVjMygpOyAvLyBEaXNwYXRjaGVkIGFmdGVyIHRoZSB3b3JsZCBoYXMgc3RlcHBlZCBmb3J3YXJkIGluIHRpbWUuCiAgLy8gUmV1c2FibGUgZXZlbnQgb2JqZWN0cyB0byBzYXZlIG1lbW9yeS4KCiAgY29uc3QgV29ybGRfc3RlcF9wb3N0U3RlcEV2ZW50ID0gewogICAgdHlwZTogJ3Bvc3RTdGVwJwogIH07IC8vIERpc3BhdGNoZWQgYmVmb3JlIHRoZSB3b3JsZCBzdGVwcyBmb3J3YXJkIGluIHRpbWUuCgogIGNvbnN0IFdvcmxkX3N0ZXBfcHJlU3RlcEV2ZW50ID0gewogICAgdHlwZTogJ3ByZVN0ZXAnCiAgfTsKICBjb25zdCBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudCA9IHsKICAgIHR5cGU6IEJvZHkuQ09MTElERV9FVkVOVF9OQU1FLAogICAgYm9keTogbnVsbCwKICAgIGNvbnRhY3Q6IG51bGwKICB9OyAvLyBQb29scyBmb3IgdW51c2VkIG9iamVjdHMKCiAgY29uc3QgV29ybGRfc3RlcF9vbGRDb250YWN0cyA9IFtdOwogIGNvbnN0IFdvcmxkX3N0ZXBfZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBbXTsgLy8gUmV1c2FibGUgYXJyYXlzIGZvciBjb2xsaXNpb24gcGFpcnMKCiAgY29uc3QgV29ybGRfc3RlcF9wMSA9IFtdOwogIGNvbnN0IFdvcmxkX3N0ZXBfcDIgPSBbXTsgLy8gU3R1ZmYgZm9yIGVtaXRDb250YWN0RXZlbnRzCgogIGNvbnN0IGFkZGl0aW9ucyA9IFtdOwogIGNvbnN0IHJlbW92YWxzID0gW107CiAgY29uc3QgYmVnaW5Db250YWN0RXZlbnQgPSB7CiAgICB0eXBlOiAnYmVnaW5Db250YWN0JywKICAgIGJvZHlBOiBudWxsLAogICAgYm9keUI6IG51bGwKICB9OwogIGNvbnN0IGVuZENvbnRhY3RFdmVudCA9IHsKICAgIHR5cGU6ICdlbmRDb250YWN0JywKICAgIGJvZHlBOiBudWxsLAogICAgYm9keUI6IG51bGwKICB9OwogIGNvbnN0IGJlZ2luU2hhcGVDb250YWN0RXZlbnQgPSB7CiAgICB0eXBlOiAnYmVnaW5TaGFwZUNvbnRhY3QnLAogICAgYm9keUE6IG51bGwsCiAgICBib2R5QjogbnVsbCwKICAgIHNoYXBlQTogbnVsbCwKICAgIHNoYXBlQjogbnVsbAogIH07CiAgY29uc3QgZW5kU2hhcGVDb250YWN0RXZlbnQgPSB7CiAgICB0eXBlOiAnZW5kU2hhcGVDb250YWN0JywKICAgIGJvZHlBOiBudWxsLAogICAgYm9keUI6IG51bGwsCiAgICBzaGFwZUE6IG51bGwsCiAgICBzaGFwZUI6IG51bGwKICB9OwoKICBjb25zdCBhZGRDb250YWN0TWF0ZXJpYWwgPSAod29ybGQsIGNyZWF0ZU1hdGVyaWFsLCBfcmVmLCB1dWlkKSA9PiB7CiAgICBsZXQgW21hdGVyaWFsQSwgbWF0ZXJpYWxCLCBvcHRpb25zXSA9IF9yZWY7CiAgICBjb25zdCBtYXRBID0gY3JlYXRlTWF0ZXJpYWwobWF0ZXJpYWxBKTsKICAgIGNvbnN0IG1hdEIgPSBjcmVhdGVNYXRlcmlhbChtYXRlcmlhbEIpOwogICAgY29uc3QgY29udGFjdE1hdGVyaWFsID0gbmV3IENvbnRhY3RNYXRlcmlhbChtYXRBLCBtYXRCLCBvcHRpb25zKTsKICAgIGNvbnRhY3RNYXRlcmlhbC51dWlkID0gdXVpZDsKICAgIHdvcmxkLmFkZENvbnRhY3RNYXRlcmlhbChjb250YWN0TWF0ZXJpYWwpOwogIH07CiAgY29uc3QgcmVtb3ZlQ29udGFjdE1hdGVyaWFsID0gKHdvcmxkLCBjbVVVSUQpID0+IHsKICAgIGNvbnN0IGluZGV4ID0gd29ybGQuY29udGFjdG1hdGVyaWFscy5maW5kSW5kZXgoX3JlZjIgPT4gewogICAgICBsZXQgewogICAgICAgIHV1aWQKICAgICAgfSA9IF9yZWYyOwogICAgICByZXR1cm4gdXVpZCA9PT0gY21VVUlEOwogICAgfSk7CiAgICBjb25zdCBbewogICAgICBpZDogaQogICAgfSwgewogICAgICBpZDogagogICAgfV0gPSB3b3JsZC5jb250YWN0bWF0ZXJpYWxzW2luZGV4XS5tYXRlcmlhbHM7CiAgICB3b3JsZC5jb250YWN0bWF0ZXJpYWxzLnNwbGljZShpbmRleCwgMSk7CiAgICBkZWxldGUgd29ybGQuY29udGFjdE1hdGVyaWFsVGFibGUuZGF0YVtpIDwgaiA/IGAke2l9LSR7an1gIDogYCR7an0tJHtpfWBdOwogIH07CgogIGxldCBtYXRlcmlhbElkID0gMDsKICBjb25zdCBjcmVhdGVNYXRlcmlhbEZhY3RvcnkgPSBtYXRlcmlhbHMgPT4gZnVuY3Rpb24gKG5hbWVPck9wdGlvbnMpIHsKICAgIGlmIChuYW1lT3JPcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgbmFtZU9yT3B0aW9ucyA9IHt9OwogICAgfQogICAgY29uc3QgbWF0ZXJpYWxPcHRpb25zID0gdHlwZW9mIG5hbWVPck9wdGlvbnMgPT09ICdzdHJpbmcnID8gewogICAgICBuYW1lOiBuYW1lT3JPcHRpb25zCiAgICB9IDogewogICAgICBuYW1lOiBTeW1ib2wuZm9yKGBNYXRlcmlhbCR7bWF0ZXJpYWxJZCsrfWApLAogICAgICAuLi5uYW1lT3JPcHRpb25zCiAgICB9OwogICAgY29uc3QgewogICAgICBuYW1lCiAgICB9ID0gbWF0ZXJpYWxPcHRpb25zOwogICAgbWF0ZXJpYWxzW25hbWVdID0gbWF0ZXJpYWxzW25hbWVdIHx8IG5ldyBNYXRlcmlhbChtYXRlcmlhbE9wdGlvbnMpOwogICAgcmV0dXJuIG1hdGVyaWFsc1tuYW1lXTsKICB9OwoKICAvKioKICAgKiBAdHlwZWRlZiB7IGltcG9ydCgnY2Fubm9uLWVzJykuTWF0ZXJpYWxPcHRpb25zIH0gTWF0ZXJpYWxPcHRpb25zCiAgICovCgogIGNvbnN0IG1ha2VWZWMzID0gX3JlZiA9PiB7CiAgICBsZXQgW3gsIHksIHpdID0gX3JlZjsKICAgIHJldHVybiBuZXcgVmVjMyh4LCB5LCB6KTsKICB9OwogIGNvbnN0IHByZXBhcmVTcGhlcmUgPSBhcmdzID0+IEFycmF5LmlzQXJyYXkoYXJncykgPyBhcmdzIDogW2FyZ3NdOwogIGNvbnN0IHByZXBhcmVDb252ZXhQb2x5aGVkcm9uID0gX3JlZjIgPT4gewogICAgbGV0IFt2LCBmYWNlcywgbiwgYSwgYm91bmRpbmdTcGhlcmVSYWRpdXNdID0gX3JlZjI7CiAgICByZXR1cm4gW3sKICAgICAgYXhlczogYSA/IGEubWFwKG1ha2VWZWMzKSA6IHVuZGVmaW5lZCwKICAgICAgYm91bmRpbmdTcGhlcmVSYWRpdXMsCiAgICAgIGZhY2VzLAogICAgICBub3JtYWxzOiBuID8gbi5tYXAobWFrZVZlYzMpIDogdW5kZWZpbmVkLAogICAgICB2ZXJ0aWNlczogdiA/IHYubWFwKG1ha2VWZWMzKSA6IHVuZGVmaW5lZAogICAgfV07CiAgfTsKICBmdW5jdGlvbiBjcmVhdGVTaGFwZSh0eXBlLCBhcmdzKSB7CiAgICBzd2l0Y2ggKHR5cGUpIHsKICAgICAgY2FzZSAnQm94JzoKICAgICAgICByZXR1cm4gbmV3IEJveChuZXcgVmVjMyguLi5hcmdzLm1hcCh2ID0+IHYgLyAyKSkpOwogICAgICAvLyBleHRlbnRzID0+IGhhbGZFeHRlbnRzCiAgICAgIGNhc2UgJ0NvbnZleFBvbHloZWRyb24nOgogICAgICAgIHJldHVybiBuZXcgQ29udmV4UG9seWhlZHJvbiguLi5wcmVwYXJlQ29udmV4UG9seWhlZHJvbihhcmdzKSk7CiAgICAgIGNhc2UgJ0N5bGluZGVyJzoKICAgICAgICByZXR1cm4gbmV3IEN5bGluZGVyKC4uLmFyZ3MpOwogICAgICAvLyBbIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIG51bVNlZ21lbnRzIF0gPSBhcmdzCiAgICAgIGNhc2UgJ0hlaWdodGZpZWxkJzoKICAgICAgICByZXR1cm4gbmV3IEhlaWdodGZpZWxkKC4uLmFyZ3MpOwogICAgICAvLyBbIEFycmF5IGRhdGEsIG9wdGlvbnM6IHttaW5WYWx1ZSwgbWF4VmFsdWUsIGVsZW1lbnRTaXplfSAgXSA9IGFyZ3MKICAgICAgY2FzZSAnUGFydGljbGUnOgogICAgICAgIHJldHVybiBuZXcgUGFydGljbGUoKTsKICAgICAgLy8gbm8gYXJncwogICAgICBjYXNlICdQbGFuZSc6CiAgICAgICAgcmV0dXJuIG5ldyBQbGFuZSgpOwogICAgICAvLyBubyBhcmdzLCBpbmZpbml0ZSB4IGFuZCB5CiAgICAgIGNhc2UgJ1NwaGVyZSc6CiAgICAgICAgcmV0dXJuIG5ldyBTcGhlcmUoLi4ucHJlcGFyZVNwaGVyZShhcmdzKSk7CiAgICAgIC8vIHJhZGl1cyA9IGFyZ3MKICAgICAgY2FzZSAnVHJpbWVzaCc6CiAgICAgICAgcmV0dXJuIG5ldyBUcmltZXNoKC4uLmFyZ3MpOwogICAgICAvLyBbdmVydGljZXMsIGluZGljZXNdID0gYXJncwogICAgfQogIH0KCiAgLyoqCiAgICogQGZ1bmN0aW9uCiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMKICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51dWlkCiAgICogQHBhcmFtIHtCb2R5UHJvcHN9IG9wdGlvbnMucHJvcHMKICAgKiBAcGFyYW0ge0JvZHlTaGFwZVR5cGV9IG9wdGlvbnMudHlwZQogICAqIEBwYXJhbSB7KG1hdGVyaWFsT3B0aW9uczogTWF0ZXJpYWxPcHRpb25zKSA9PiBNYXRlcmlhbCA9fSBvcHRpb25zLmNyZWF0ZU1hdGVyaWFsCiAgICogQHJldHVybnMge0JvZHl9CiAgICovCiAgY29uc3QgcHJvcHNUb0JvZHkgPSBvcHRpb25zID0+IHsKICAgIGNvbnN0IHsKICAgICAgdXVpZCwKICAgICAgcHJvcHMsCiAgICAgIHR5cGUsCiAgICAgIGNyZWF0ZU1hdGVyaWFsID0gbWF0ZXJpYWxPcHRpb25zID0+IG5ldyBNYXRlcmlhbChtYXRlcmlhbE9wdGlvbnMpCiAgICB9ID0gb3B0aW9uczsKICAgIGNvbnN0IHsKICAgICAgYW5ndWxhckZhY3RvciA9IFsxLCAxLCAxXSwKICAgICAgYW5ndWxhclZlbG9jaXR5ID0gWzAsIDAsIDBdLAogICAgICBhcmdzID0gW10sCiAgICAgIGNvbGxpc2lvblJlc3BvbnNlLAogICAgICBsaW5lYXJGYWN0b3IgPSBbMSwgMSwgMV0sCiAgICAgIG1hc3MsCiAgICAgIG1hdGVyaWFsLAogICAgICBvbkNvbGxpZGUsCiAgICAgIHBvc2l0aW9uID0gWzAsIDAsIDBdLAogICAgICByb3RhdGlvbiA9IFswLCAwLCAwXSwKICAgICAgc2hhcGVzLAogICAgICB0eXBlOiBib2R5VHlwZSwKICAgICAgdmVsb2NpdHkgPSBbMCwgMCwgMF0sCiAgICAgIC4uLmV4dHJhCiAgICB9ID0gcHJvcHM7CiAgICBjb25zdCBib2R5ID0gbmV3IEJvZHkoewogICAgICAuLi5leHRyYSwKICAgICAgbWFzczogYm9keVR5cGUgPT09ICdTdGF0aWMnID8gMCA6IG1hc3MsCiAgICAgIG1hdGVyaWFsOiBtYXRlcmlhbCA/IGNyZWF0ZU1hdGVyaWFsKG1hdGVyaWFsKSA6IHVuZGVmaW5lZCwKICAgICAgdHlwZTogYm9keVR5cGUgPyBCb2R5W2JvZHlUeXBlLnRvVXBwZXJDYXNlKCldIDogdW5kZWZpbmVkCiAgICB9KTsKICAgIGJvZHkudXVpZCA9IHV1aWQ7CiAgICBpZiAoY29sbGlzaW9uUmVzcG9uc2UgIT09IHVuZGVmaW5lZCkgewogICAgICBib2R5LmNvbGxpc2lvblJlc3BvbnNlID0gY29sbGlzaW9uUmVzcG9uc2U7CiAgICB9CiAgICBpZiAodHlwZSA9PT0gJ0NvbXBvdW5kJykgewogICAgICBzaGFwZXMuZm9yRWFjaChfcmVmMyA9PiB7CiAgICAgICAgbGV0IHsKICAgICAgICAgIHR5cGUsCiAgICAgICAgICBhcmdzLAogICAgICAgICAgcG9zaXRpb24sCiAgICAgICAgICByb3RhdGlvbiwKICAgICAgICAgIG1hdGVyaWFsLAogICAgICAgICAgLi4uZXh0cmEKICAgICAgICB9ID0gX3JlZjM7CiAgICAgICAgY29uc3Qgc2hhcGVCb2R5ID0gYm9keS5hZGRTaGFwZShjcmVhdGVTaGFwZSh0eXBlLCBhcmdzKSwgcG9zaXRpb24gPyBuZXcgVmVjMyguLi5wb3NpdGlvbikgOiB1bmRlZmluZWQsIHJvdGF0aW9uID8gbmV3IFF1YXRlcm5pb24oKS5zZXRGcm9tRXVsZXIoLi4ucm90YXRpb24pIDogdW5kZWZpbmVkKTsKICAgICAgICBpZiAobWF0ZXJpYWwpIHNoYXBlQm9keS5tYXRlcmlhbCA9IGNyZWF0ZU1hdGVyaWFsKG1hdGVyaWFsKTsKICAgICAgICBPYmplY3QuYXNzaWduKHNoYXBlQm9keSwgZXh0cmEpOwogICAgICB9KTsKICAgIH0gZWxzZSB7CiAgICAgIGJvZHkuYWRkU2hhcGUoY3JlYXRlU2hhcGUodHlwZSwgYXJncykpOwogICAgfQogICAgYm9keS5wb3NpdGlvbi5zZXQocG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdLCBwb3NpdGlvblsyXSk7CiAgICBib2R5LnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKHJvdGF0aW9uWzBdLCByb3RhdGlvblsxXSwgcm90YXRpb25bMl0pOwogICAgYm9keS52ZWxvY2l0eS5zZXQodmVsb2NpdHlbMF0sIHZlbG9jaXR5WzFdLCB2ZWxvY2l0eVsyXSk7CiAgICBib2R5LmFuZ3VsYXJWZWxvY2l0eS5zZXQoYW5ndWxhclZlbG9jaXR5WzBdLCBhbmd1bGFyVmVsb2NpdHlbMV0sIGFuZ3VsYXJWZWxvY2l0eVsyXSk7CiAgICBib2R5LmxpbmVhckZhY3Rvci5zZXQobGluZWFyRmFjdG9yWzBdLCBsaW5lYXJGYWN0b3JbMV0sIGxpbmVhckZhY3RvclsyXSk7CiAgICBib2R5LmFuZ3VsYXJGYWN0b3Iuc2V0KGFuZ3VsYXJGYWN0b3JbMF0sIGFuZ3VsYXJGYWN0b3JbMV0sIGFuZ3VsYXJGYWN0b3JbMl0pOwogICAgcmV0dXJuIGJvZHk7CiAgfTsKCiAgY29uc3QgYWRkQm9kaWVzID0gKHN0YXRlLCBjcmVhdGVNYXRlcmlhbCwgX3JlZikgPT4gewogICAgbGV0IHsKICAgICAgcHJvcHMsCiAgICAgIHR5cGUsCiAgICAgIHV1aWQKICAgIH0gPSBfcmVmOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dWlkLmxlbmd0aDsgaSsrKSB7CiAgICAgIGNvbnN0IGJvZHkgPSBwcm9wc1RvQm9keSh7CiAgICAgICAgY3JlYXRlTWF0ZXJpYWwsCiAgICAgICAgcHJvcHM6IHByb3BzW2ldLAogICAgICAgIHR5cGUsCiAgICAgICAgdXVpZDogdXVpZFtpXQogICAgICB9KTsKICAgICAgc3RhdGUud29ybGQuYWRkQm9keShib2R5KTsKICAgICAgaWYgKHByb3BzW2ldLm9uQ29sbGlkZSkgYm9keS5hZGRFdmVudExpc3RlbmVyKCdjb2xsaWRlJywgX3JlZjIgPT4gewogICAgICAgIGxldCB7CiAgICAgICAgICB0eXBlLAogICAgICAgICAgYm9keSwKICAgICAgICAgIHRhcmdldCwKICAgICAgICAgIGNvbnRhY3QKICAgICAgICB9ID0gX3JlZjI7CiAgICAgICAgaWYgKCFib2R5LnV1aWQgfHwgIXRhcmdldC51dWlkKSByZXR1cm47CiAgICAgICAgY29uc3QgewogICAgICAgICAgbmksCiAgICAgICAgICByaSwKICAgICAgICAgIHJqLAogICAgICAgICAgYmksCiAgICAgICAgICBiaiwKICAgICAgICAgIGlkCiAgICAgICAgfSA9IGNvbnRhY3Q7CiAgICAgICAgY29uc3QgY29udGFjdFBvaW50ID0gYmkucG9zaXRpb24udmFkZChyaSk7CiAgICAgICAgY29uc3QgY29udGFjdE5vcm1hbCA9IGJpID09PSBib2R5ID8gbmkgOiBuaS5zY2FsZSgtMSk7CiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7CiAgICAgICAgICBib2R5OiBib2R5LnV1aWQsCiAgICAgICAgICBjb2xsaXNpb25GaWx0ZXJzOiB7CiAgICAgICAgICAgIGJvZHlGaWx0ZXJHcm91cDogYm9keS5jb2xsaXNpb25GaWx0ZXJHcm91cCwKICAgICAgICAgICAgYm9keUZpbHRlck1hc2s6IGJvZHkuY29sbGlzaW9uRmlsdGVyTWFzaywKICAgICAgICAgICAgdGFyZ2V0RmlsdGVyR3JvdXA6IHRhcmdldC5jb2xsaXNpb25GaWx0ZXJHcm91cCwKICAgICAgICAgICAgdGFyZ2V0RmlsdGVyTWFzazogdGFyZ2V0LmNvbGxpc2lvbkZpbHRlck1hc2sKICAgICAgICAgIH0sCiAgICAgICAgICBjb250YWN0OiB7CiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogdXNlIGlkIGluc3RlYWQgb2YgdXVpZAogICAgICAgICAgICBiaTogYmkudXVpZCwKICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiB1c2UgaWQgaW5zdGVhZCBvZiB1dWlkCiAgICAgICAgICAgIGJqOiBiai51dWlkLAogICAgICAgICAgICAvLyBOb3JtYWwgb2YgdGhlIGNvbnRhY3QsIHJlbGF0aXZlIHRvIHRoZSBjb2xsaWRpbmcgYm9keQogICAgICAgICAgICBjb250YWN0Tm9ybWFsOiBjb250YWN0Tm9ybWFsLnRvQXJyYXkoKSwKICAgICAgICAgICAgLy8gV29ybGQgcG9zaXRpb24gb2YgdGhlIGNvbnRhY3QKICAgICAgICAgICAgY29udGFjdFBvaW50OiBjb250YWN0UG9pbnQudG9BcnJheSgpLAogICAgICAgICAgICBpZCwKICAgICAgICAgICAgaW1wYWN0VmVsb2NpdHk6IGNvbnRhY3QuZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbCgpLAogICAgICAgICAgICBuaTogbmkudG9BcnJheSgpLAogICAgICAgICAgICByaTogcmkudG9BcnJheSgpLAogICAgICAgICAgICByajogcmoudG9BcnJheSgpCiAgICAgICAgICB9LAogICAgICAgICAgb3A6ICdldmVudCcsCiAgICAgICAgICB0YXJnZXQ6IHRhcmdldC51dWlkLAogICAgICAgICAgdHlwZQogICAgICAgIH0pOwogICAgICB9KTsKICAgIH0KICB9OwoKICBjb25zdCB0cmlwbGV0VG9WZWMzID0gdCA9PiB0ID8gbmV3IFZlYzMoLi4udCkgOiB1bmRlZmluZWQ7CgogIGNvbnN0IGFkZENvbnN0cmFpbnQgPSAoc3RhdGUsIF9yZWYpID0+IHsKICAgIGxldCB7CiAgICAgIHByb3BzOiBbYm9keUEsIGJvZHlCLCB7CiAgICAgICAgYW5nbGUsCiAgICAgICAgYXhpc0EsCiAgICAgICAgYXhpc0IsCiAgICAgICAgY29sbGlkZUNvbm5lY3RlZCwKICAgICAgICBkaXN0YW5jZSwKICAgICAgICBtYXhGb3JjZSwKICAgICAgICBtYXhNdWx0aXBsaWVyLAogICAgICAgIHBpdm90QSwKICAgICAgICBwaXZvdEIsCiAgICAgICAgdHdpc3RBbmdsZSwKICAgICAgICB3YWtlVXBCb2RpZXMKICAgICAgfV0sCiAgICAgIHR5cGUsCiAgICAgIHV1aWQKICAgIH0gPSBfcmVmOwogICAgbGV0IGNvbnN0cmFpbnQ7CiAgICBzd2l0Y2ggKHR5cGUpIHsKICAgICAgY2FzZSAnUG9pbnRUb1BvaW50JzoKICAgICAgICBjb25zdHJhaW50ID0gbmV3IFBvaW50VG9Qb2ludENvbnN0cmFpbnQoc3RhdGUuYm9kaWVzW2JvZHlBXSwgdHJpcGxldFRvVmVjMyhwaXZvdEEpLCBzdGF0ZS5ib2RpZXNbYm9keUJdLCB0cmlwbGV0VG9WZWMzKHBpdm90QiksIG1heEZvcmNlKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnQ29uZVR3aXN0JzoKICAgICAgICBjb25zdHJhaW50ID0gbmV3IENvbmVUd2lzdENvbnN0cmFpbnQoc3RhdGUuYm9kaWVzW2JvZHlBXSwgc3RhdGUuYm9kaWVzW2JvZHlCXSwgewogICAgICAgICAgYW5nbGUsCiAgICAgICAgICBheGlzQTogdHJpcGxldFRvVmVjMyhheGlzQSksCiAgICAgICAgICBheGlzQjogdHJpcGxldFRvVmVjMyhheGlzQiksCiAgICAgICAgICBjb2xsaWRlQ29ubmVjdGVkLAogICAgICAgICAgbWF4Rm9yY2UsCiAgICAgICAgICBwaXZvdEE6IHRyaXBsZXRUb1ZlYzMocGl2b3RBKSwKICAgICAgICAgIHBpdm90QjogdHJpcGxldFRvVmVjMyhwaXZvdEIpLAogICAgICAgICAgdHdpc3RBbmdsZQogICAgICAgIH0pOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdIaW5nZSc6CiAgICAgICAgY29uc3RyYWludCA9IG5ldyBIaW5nZUNvbnN0cmFpbnQoc3RhdGUuYm9kaWVzW2JvZHlBXSwgc3RhdGUuYm9kaWVzW2JvZHlCXSwgewogICAgICAgICAgYXhpc0E6IHRyaXBsZXRUb1ZlYzMoYXhpc0EpLAogICAgICAgICAgYXhpc0I6IHRyaXBsZXRUb1ZlYzMoYXhpc0IpLAogICAgICAgICAgY29sbGlkZUNvbm5lY3RlZCwKICAgICAgICAgIG1heEZvcmNlLAogICAgICAgICAgcGl2b3RBOiB0cmlwbGV0VG9WZWMzKHBpdm90QSksCiAgICAgICAgICBwaXZvdEI6IHRyaXBsZXRUb1ZlYzMocGl2b3RCKQogICAgICAgIH0pOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdEaXN0YW5jZSc6CiAgICAgICAgY29uc3RyYWludCA9IG5ldyBEaXN0YW5jZUNvbnN0cmFpbnQoc3RhdGUuYm9kaWVzW2JvZHlBXSwgc3RhdGUuYm9kaWVzW2JvZHlCXSwgZGlzdGFuY2UsIG1heEZvcmNlKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnTG9jayc6CiAgICAgICAgY29uc3RyYWludCA9IG5ldyBMb2NrQ29uc3RyYWludChzdGF0ZS5ib2RpZXNbYm9keUFdLCBzdGF0ZS5ib2RpZXNbYm9keUJdLCB7CiAgICAgICAgICBtYXhGb3JjZQogICAgICAgIH0pOwogICAgICAgIGJyZWFrOwogICAgICBkZWZhdWx0OgogICAgICAgIGNvbnN0cmFpbnQgPSBuZXcgQ29uc3RyYWludChzdGF0ZS5ib2RpZXNbYm9keUFdLCBzdGF0ZS5ib2RpZXNbYm9keUJdLCB7CiAgICAgICAgICBjb2xsaWRlQ29ubmVjdGVkLAogICAgICAgICAgd2FrZVVwQm9kaWVzCiAgICAgICAgfSk7CiAgICAgICAgYnJlYWs7CiAgICB9CiAgICBjb25zdHJhaW50LnV1aWQgPSB1dWlkOwogICAgc3RhdGUud29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTsKICAgIGlmIChtYXhNdWx0aXBsaWVyICE9PSB1bmRlZmluZWQpIHsKICAgICAgY29uc3QgcG9zdFN0ZXBDb25zdHJhaW50ID0gKCkgPT4gewogICAgICAgIC8vIFRoZSBtdWx0aXBsaWVyIGlzIHByb3BvcnRpb25hbCB0byBob3cgbXVjaCBmb3JjZSBpcyBhZGRlZCB0byB0aGUgYm9kaWVzIGJ5IHRoZSBjb25zdHJhaW50LgogICAgICAgIC8vIElmIHRoaXMgZXhjZWVkcyBhIGxpbWl0IHRoZSBjb25zdHJhaW50IGlzIGRpc2FibGVkLgogICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLmFicyhjb25zdHJhaW50LmVxdWF0aW9uc1swXS5tdWx0aXBsaWVyKTsKICAgICAgICBpZiAobXVsdGlwbGllciA+IG1heE11bHRpcGxpZXIpIHsKICAgICAgICAgIGNvbnN0cmFpbnQuZGlzYWJsZSgpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgc3RhdGUuY29uc3RyYWludHNbdXVpZF0gPSBwb3N0U3RlcENvbnN0cmFpbnQ7CiAgICAgIHN0YXRlLndvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3Bvc3RTdGVwJywgc3RhdGUuY29uc3RyYWludHNbdXVpZF0pOwogICAgfQogIH07CgogIGZ1bmN0aW9uIHRvVXBwZXJjYXNlKHN0cikgewogICAgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpOwogIH0KICBjb25zdCBhZGRSYXkgPSAoc3RhdGUsIF9yZWYpID0+IHsKICAgIGxldCB7CiAgICAgIHByb3BzOiB7CiAgICAgICAgZnJvbSwKICAgICAgICBtb2RlLAogICAgICAgIHRvLAogICAgICAgIC4uLnJheU9wdGlvbnMKICAgICAgfSwKICAgICAgdXVpZAogICAgfSA9IF9yZWY7CiAgICBjb25zdCByYXkgPSBuZXcgUmF5KHRyaXBsZXRUb1ZlYzMoZnJvbSksIHRyaXBsZXRUb1ZlYzModG8pKTsKICAgIGNvbnN0IG9wdGlvbnMgPSB7CiAgICAgIG1vZGU6IFJBWV9NT0RFU1t0b1VwcGVyY2FzZShtb2RlKV0sCiAgICAgIHJlc3VsdDogbmV3IFJheWNhc3RSZXN1bHQoKSwKICAgICAgLi4ucmF5T3B0aW9ucwogICAgfTsKICAgIHN0YXRlLnJheXNbdXVpZF0gPSAoKSA9PiB7CiAgICAgIHJheS5pbnRlcnNlY3RXb3JsZChzdGF0ZS53b3JsZCwgb3B0aW9ucyk7CiAgICAgIGlmICghb3B0aW9ucy5yZXN1bHQgfHwgIW9wdGlvbnMucmVzdWx0LmJvZHkpIHJldHVybjsKICAgICAgY29uc3QgewogICAgICAgIGJvZHksCiAgICAgICAgc2hhcGUsCiAgICAgICAgcmF5RnJvbVdvcmxkLAogICAgICAgIHJheVRvV29ybGQsCiAgICAgICAgaGl0Tm9ybWFsV29ybGQsCiAgICAgICAgaGl0UG9pbnRXb3JsZCwKICAgICAgICAuLi5yZXN0CiAgICAgIH0gPSBvcHRpb25zLnJlc3VsdDsKICAgICAgY29uc3QgYm9keVVVSUQgPSBib2R5LnV1aWQ7CiAgICAgIGlmICghYm9keVVVSUQpIHJldHVybjsKICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7CiAgICAgICAgYm9keTogYm9keVVVSUQsCiAgICAgICAgaGl0Tm9ybWFsV29ybGQ6IGhpdE5vcm1hbFdvcmxkLnRvQXJyYXkoKSwKICAgICAgICBoaXRQb2ludFdvcmxkOiBoaXRQb2ludFdvcmxkLnRvQXJyYXkoKSwKICAgICAgICBvcDogJ2V2ZW50JywKICAgICAgICByYXk6IHsKICAgICAgICAgIGNvbGxpc2lvbkZpbHRlckdyb3VwOiByYXkuY29sbGlzaW9uRmlsdGVyR3JvdXAsCiAgICAgICAgICBjb2xsaXNpb25GaWx0ZXJNYXNrOiByYXkuY29sbGlzaW9uRmlsdGVyTWFzaywKICAgICAgICAgIGRpcmVjdGlvbjogcmF5LmRpcmVjdGlvbi50b0FycmF5KCksCiAgICAgICAgICBmcm9tLAogICAgICAgICAgdG8sCiAgICAgICAgICB1dWlkCiAgICAgICAgfSwKICAgICAgICByYXlGcm9tV29ybGQ6IHJheUZyb21Xb3JsZC50b0FycmF5KCksCiAgICAgICAgcmF5VG9Xb3JsZDogcmF5VG9Xb3JsZC50b0FycmF5KCksCiAgICAgICAgc2hhcGU6IHNoYXBlID8gewogICAgICAgICAgLi4uc2hhcGUsCiAgICAgICAgICBib2R5OiBib2R5VVVJRAogICAgICAgIH0gOiBudWxsLAogICAgICAgIHR5cGU6ICdyYXloaXQnLAogICAgICAgIC4uLnJlc3QKICAgICAgfSk7CiAgICB9OwogICAgc3RhdGUud29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHN0YXRlLnJheXNbdXVpZF0pOwogIH07CgogIGNvbnN0IGFkZFJheWNhc3RWZWhpY2xlID0gKHN0YXRlLCBkYXRhKSA9PiB7CiAgICBjb25zdCBbY2hhc3Npc0JvZHksIHdoZWVscywgd2hlZWxJbmZvcywgaW5kZXhGb3J3YXJkQXhpcywgaW5kZXhSaWdodEF4aXMsIGluZGV4VXBBeGlzXSA9IGRhdGEucHJvcHM7CiAgICBjb25zdCB2ZWhpY2xlID0gbmV3IFJheWNhc3RWZWhpY2xlKHsKICAgICAgY2hhc3Npc0JvZHk6IHN0YXRlLmJvZGllc1tjaGFzc2lzQm9keV0sCiAgICAgIGluZGV4Rm9yd2FyZEF4aXMsCiAgICAgIGluZGV4UmlnaHRBeGlzLAogICAgICBpbmRleFVwQXhpcwogICAgfSk7CiAgICB2ZWhpY2xlLndvcmxkID0gc3RhdGUud29ybGQ7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdoZWVsSW5mb3MubGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3QgewogICAgICAgIGF4bGVMb2NhbCwKICAgICAgICBjaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWwsCiAgICAgICAgZGlyZWN0aW9uTG9jYWwsCiAgICAgICAgLi4ucmVzdAogICAgICB9ID0gd2hlZWxJbmZvc1tpXTsKICAgICAgdmVoaWNsZS5hZGRXaGVlbCh7CiAgICAgICAgYXhsZUxvY2FsOiB0cmlwbGV0VG9WZWMzKGF4bGVMb2NhbCksCiAgICAgICAgY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsOiB0cmlwbGV0VG9WZWMzKGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbCksCiAgICAgICAgZGlyZWN0aW9uTG9jYWw6IHRyaXBsZXRUb1ZlYzMoZGlyZWN0aW9uTG9jYWwpLAogICAgICAgIC4uLnJlc3QKICAgICAgfSk7CiAgICB9CiAgICBjb25zdCBwcmVTdGVwID0gKCkgPT4gewogICAgICB2ZWhpY2xlLnVwZGF0ZVZlaGljbGUoc3RhdGUud29ybGQuZHQpOwogICAgfTsKICAgIGNvbnN0IHBvc3RTdGVwID0gKCkgPT4gewogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlaGljbGUud2hlZWxJbmZvcy5sZW5ndGg7IGkrKykgewogICAgICAgIHZlaGljbGUudXBkYXRlV2hlZWxUcmFuc2Zvcm0oaSk7CiAgICAgICAgY29uc3QgdCA9IHZlaGljbGUud2hlZWxJbmZvc1tpXS53b3JsZFRyYW5zZm9ybTsKICAgICAgICBjb25zdCB3aGVlbEJvZHkgPSBzdGF0ZS5ib2RpZXNbd2hlZWxzW2ldXTsKICAgICAgICB3aGVlbEJvZHkucG9zaXRpb24uY29weSh0LnBvc2l0aW9uKTsKICAgICAgICB3aGVlbEJvZHkucXVhdGVybmlvbi5jb3B5KHQucXVhdGVybmlvbik7CiAgICAgIH0KICAgIH07CiAgICBzdGF0ZS52ZWhpY2xlc1tkYXRhLnV1aWRdID0gewogICAgICBwb3N0U3RlcCwKICAgICAgcHJlU3RlcCwKICAgICAgdmVoaWNsZQogICAgfTsKICAgIHN0YXRlLndvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZVN0ZXAnLCBwcmVTdGVwKTsKICAgIHN0YXRlLndvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3Bvc3RTdGVwJywgcG9zdFN0ZXApOwogIH07CgogIGNvbnN0IGFkZFNwcmluZyA9IChzdGF0ZSwgX3JlZikgPT4gewogICAgbGV0IHsKICAgICAgcHJvcHM6IFtib2R5QSwgYm9keUIsIHsKICAgICAgICBkYW1waW5nLAogICAgICAgIGxvY2FsQW5jaG9yQSwKICAgICAgICBsb2NhbEFuY2hvckIsCiAgICAgICAgcmVzdExlbmd0aCwKICAgICAgICBzdGlmZm5lc3MsCiAgICAgICAgd29ybGRBbmNob3JBLAogICAgICAgIHdvcmxkQW5jaG9yQgogICAgICB9XSwKICAgICAgdXVpZAogICAgfSA9IF9yZWY7CiAgICBjb25zdCBzcHJpbmcgPSBuZXcgU3ByaW5nKHN0YXRlLmJvZGllc1tib2R5QV0sIHN0YXRlLmJvZGllc1tib2R5Ql0sIHsKICAgICAgZGFtcGluZywKICAgICAgbG9jYWxBbmNob3JBOiB0cmlwbGV0VG9WZWMzKGxvY2FsQW5jaG9yQSksCiAgICAgIGxvY2FsQW5jaG9yQjogdHJpcGxldFRvVmVjMyhsb2NhbEFuY2hvckIpLAogICAgICByZXN0TGVuZ3RoLAogICAgICBzdGlmZm5lc3MsCiAgICAgIHdvcmxkQW5jaG9yQTogdHJpcGxldFRvVmVjMyh3b3JsZEFuY2hvckEpLAogICAgICB3b3JsZEFuY2hvckI6IHRyaXBsZXRUb1ZlYzMod29ybGRBbmNob3JCKQogICAgfSk7CiAgICBzcHJpbmcudXVpZCA9IHV1aWQ7CiAgICBjb25zdCBwb3N0U3RlcFNwcmluZyA9ICgpID0+IHNwcmluZy5hcHBseUZvcmNlKCk7CiAgICBzdGF0ZS5zcHJpbmdzW3V1aWRdID0gcG9zdFN0ZXBTcHJpbmc7CiAgICBzdGF0ZS5zcHJpbmdJbnN0YW5jZXNbdXVpZF0gPSBzcHJpbmc7CgogICAgLy8gQ29tcHV0ZSB0aGUgZm9yY2UgYWZ0ZXIgZWFjaCBzdGVwCiAgICBzdGF0ZS53b3JsZC5hZGRFdmVudExpc3RlbmVyKCdwb3N0U3RlcCcsIHN0YXRlLnNwcmluZ3NbdXVpZF0pOwogIH07CgogIGZ1bmN0aW9uIGVtaXRCZWdpbkNvbnRhY3QoX3JlZikgewogICAgbGV0IHsKICAgICAgYm9keUEsCiAgICAgIGJvZHlCCiAgICB9ID0gX3JlZjsKICAgIGlmICghKGJvZHlBICE9IG51bGwgJiYgYm9keUEudXVpZCkgfHwgIShib2R5QiAhPSBudWxsICYmIGJvZHlCLnV1aWQpKSByZXR1cm47CiAgICBzZWxmLnBvc3RNZXNzYWdlKHsKICAgICAgYm9keUE6IGJvZHlBLnV1aWQsCiAgICAgIGJvZHlCOiBib2R5Qi51dWlkLAogICAgICBvcDogJ2V2ZW50JywKICAgICAgdHlwZTogJ2NvbGxpZGVCZWdpbicKICAgIH0pOwogIH0KICBmdW5jdGlvbiBlbWl0RW5kQ29udGFjdChfcmVmMikgewogICAgbGV0IHsKICAgICAgYm9keUEsCiAgICAgIGJvZHlCCiAgICB9ID0gX3JlZjI7CiAgICBpZiAoIShib2R5QSAhPSBudWxsICYmIGJvZHlBLnV1aWQpIHx8ICEoYm9keUIgIT0gbnVsbCAmJiBib2R5Qi51dWlkKSkgcmV0dXJuOwogICAgc2VsZi5wb3N0TWVzc2FnZSh7CiAgICAgIGJvZHlBOiBib2R5QS51dWlkLAogICAgICBib2R5QjogYm9keUIudXVpZCwKICAgICAgb3A6ICdldmVudCcsCiAgICAgIHR5cGU6ICdjb2xsaWRlRW5kJwogICAgfSk7CiAgfQogIGNvbnN0IGluaXQgPSAod29ybGQsIF9yZWYzKSA9PiB7CiAgICBsZXQgewogICAgICBhbGxvd1NsZWVwLAogICAgICBheGlzSW5kZXggPSAwLAogICAgICBicm9hZHBoYXNlLAogICAgICBkZWZhdWx0Q29udGFjdE1hdGVyaWFsLAogICAgICBmcmljdGlvbkdyYXZpdHksCiAgICAgIGdyYXZpdHksCiAgICAgIGl0ZXJhdGlvbnMsCiAgICAgIHF1YXROb3JtYWxpemVGYXN0LAogICAgICBxdWF0Tm9ybWFsaXplU2tpcCwKICAgICAgc29sdmVyLAogICAgICB0b2xlcmFuY2UKICAgIH0gPSBfcmVmMzsKICAgIHdvcmxkLmFsbG93U2xlZXAgPSBhbGxvd1NsZWVwOwogICAgd29ybGQuZ3Jhdml0eS5zZXQoLi4uZ3Jhdml0eSk7CiAgICB3b3JsZC5mcmljdGlvbkdyYXZpdHkgPSBmcmljdGlvbkdyYXZpdHkgPyBuZXcgVmVjMyguLi5mcmljdGlvbkdyYXZpdHkpIDogdW5kZWZpbmVkOwogICAgd29ybGQucXVhdE5vcm1hbGl6ZUZhc3QgPSBxdWF0Tm9ybWFsaXplRmFzdDsKICAgIHdvcmxkLnF1YXROb3JtYWxpemVTa2lwID0gcXVhdE5vcm1hbGl6ZVNraXA7CiAgICBpZiAoc29sdmVyID09PSAnU3BsaXQnKSB7CiAgICAgIHdvcmxkLnNvbHZlciA9IG5ldyBTcGxpdFNvbHZlcihuZXcgR1NTb2x2ZXIoKSk7CiAgICB9CiAgICBpZiAod29ybGQuc29sdmVyIGluc3RhbmNlb2YgR1NTb2x2ZXIpIHsKICAgICAgd29ybGQuc29sdmVyLnRvbGVyYW5jZSA9IHRvbGVyYW5jZTsKICAgICAgd29ybGQuc29sdmVyLml0ZXJhdGlvbnMgPSBpdGVyYXRpb25zOwogICAgfQogICAgd29ybGQuYnJvYWRwaGFzZSA9IGJyb2FkcGhhc2UgPT09ICdTQVAnID8gbmV3IFNBUEJyb2FkcGhhc2Uod29ybGQpIDogbmV3IE5haXZlQnJvYWRwaGFzZSgpOwogICAgaWYgKHdvcmxkLmJyb2FkcGhhc2UgaW5zdGFuY2VvZiBTQVBCcm9hZHBoYXNlKSB7CiAgICAgIHdvcmxkLmJyb2FkcGhhc2UuYXhpc0luZGV4ID0gYXhpc0luZGV4OwogICAgfQogICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcignYmVnaW5Db250YWN0JywgZW1pdEJlZ2luQ29udGFjdCk7CiAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKCdlbmRDb250YWN0JywgZW1pdEVuZENvbnRhY3QpOwogICAgT2JqZWN0LmFzc2lnbih3b3JsZC5kZWZhdWx0Q29udGFjdE1hdGVyaWFsLCBkZWZhdWx0Q29udGFjdE1hdGVyaWFsKTsKICB9OwoKICBjb25zdCBpc1FvclYgPSB2ID0+IHYgaW5zdGFuY2VvZiBRdWF0ZXJuaW9uIHx8IHYgaW5zdGFuY2VvZiBWZWMzOwogIGNvbnN0IHN0ZXAgPSAoc3RhdGUsIF9yZWYpID0+IHsKICAgIGxldCB7CiAgICAgIHBvc2l0aW9ucywKICAgICAgcHJvcHM6IHsKICAgICAgICBtYXhTdWJTdGVwcywKICAgICAgICBzdGVwU2l6ZSwKICAgICAgICB0aW1lU2luY2VMYXN0Q2FsbGVkCiAgICAgIH0sCiAgICAgIHF1YXRlcm5pb25zCiAgICB9ID0gX3JlZjsKICAgIHN0YXRlLndvcmxkLnN0ZXAoc3RlcFNpemUsIHRpbWVTaW5jZUxhc3RDYWxsZWQsIG1heFN1YlN0ZXBzKTsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUud29ybGQuYm9kaWVzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgIGNvbnN0IHAgPSBzdGF0ZS53b3JsZC5ib2RpZXNbaV0ucG9zaXRpb247CiAgICAgIGNvbnN0IHEgPSBzdGF0ZS53b3JsZC5ib2RpZXNbaV0ucXVhdGVybmlvbjsKICAgICAgcG9zaXRpb25zWzMgKiBpICsgMF0gPSBwLng7CiAgICAgIHBvc2l0aW9uc1szICogaSArIDFdID0gcC55OwogICAgICBwb3NpdGlvbnNbMyAqIGkgKyAyXSA9IHAuejsKICAgICAgcXVhdGVybmlvbnNbNCAqIGkgKyAwXSA9IHEueDsKICAgICAgcXVhdGVybmlvbnNbNCAqIGkgKyAxXSA9IHEueTsKICAgICAgcXVhdGVybmlvbnNbNCAqIGkgKyAyXSA9IHEuejsKICAgICAgcXVhdGVybmlvbnNbNCAqIGkgKyAzXSA9IHEudzsKICAgIH0KICAgIGNvbnN0IG9ic2VydmF0aW9ucyA9IFtdOwogICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyhzdGF0ZS5zdWJzY3JpcHRpb25zKSkgewogICAgICBjb25zdCBbdXVpZCwgdHlwZSwgdGFyZ2V0ID0gJ2JvZGllcyddID0gc3RhdGUuc3Vic2NyaXB0aW9uc1tpZF07CiAgICAgIGNvbnN0IHsKICAgICAgICBib2RpZXMsCiAgICAgICAgdmVoaWNsZXMKICAgICAgfSA9IHN0YXRlOwogICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldCA9PT0gJ3ZlaGljbGVzJyA/CiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogRGlmZmVyZW50aWF0ZSB0aGVzZSAidHlwZXMiCiAgICAgIHZlaGljbGVzW3V1aWRdLnZlaGljbGVbdHlwZV0gOgogICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IERpZmZlcmVudGlhdGUgdGhlc2UgInR5cGVzIgogICAgICBib2RpZXNbdXVpZF1bdHlwZV07CiAgICAgIGNvbnN0IHNlcmlhbGl6YWJsZVZhbHVlID0gaXNRb3JWKHZhbHVlKSA/IHZhbHVlLnRvQXJyYXkoKSA6IHZhbHVlOwogICAgICBvYnNlcnZhdGlvbnMucHVzaChbTnVtYmVyKGlkKSwgc2VyaWFsaXphYmxlVmFsdWUsCiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogRGlmZmVyZW50aWF0ZSB0aGVzZSAidHlwZXMiCiAgICAgIHR5cGVdKTsKICAgIH0KICAgIGNvbnN0IG1lc3NhZ2UgPSB7CiAgICAgIGFjdGl2ZTogc3RhdGUud29ybGQuaGFzQWN0aXZlQm9kaWVzLAogICAgICBvYnNlcnZhdGlvbnMsCiAgICAgIG9wOiAnZnJhbWUnLAogICAgICBwb3NpdGlvbnMsCiAgICAgIHF1YXRlcm5pb25zCiAgICB9OwogICAgaWYgKHN0YXRlLmJvZGllc05lZWRTeW5jaW5nKSB7CiAgICAgIG1lc3NhZ2UuYm9kaWVzID0gc3RhdGUud29ybGQuYm9kaWVzLnJlZHVjZSgoYm9kaWVzLCBib2R5KSA9PiB7CiAgICAgICAgaWYgKGJvZHkudXVpZCkgYm9kaWVzLnB1c2goYm9keS51dWlkKTsKICAgICAgICByZXR1cm4gYm9kaWVzOwogICAgICB9LCBbXSk7CiAgICAgIHN0YXRlLmJvZGllc05lZWRTeW5jaW5nID0gZmFsc2U7CiAgICB9CiAgICBzZWxmLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFtwb3NpdGlvbnMuYnVmZmVyLCBxdWF0ZXJuaW9ucy5idWZmZXJdKTsKICB9OwoKICBjb25zdCBzdGF0ZSA9IHsKICAgIGJvZGllczoge30sCiAgICBib2RpZXNOZWVkU3luY2luZzogZmFsc2UsCiAgICBjb25zdHJhaW50czoge30sCiAgICBtYXRlcmlhbHM6IHt9LAogICAgcmF5czoge30sCiAgICBzcHJpbmdJbnN0YW5jZXM6IHt9LAogICAgc3ByaW5nczoge30sCiAgICBzdWJzY3JpcHRpb25zOiB7fSwKICAgIHZlaGljbGVzOiB7fSwKICAgIHdvcmxkOiBuZXcgV29ybGQoKQogIH07CgogIC8vLyA8cmVmZXJlbmNlIG5vLWRlZmF1bHQtbGliPSJ0cnVlIi8+CiAgY29uc3QgaXNIaW5nZUNvbnN0cmFpbnQgPSBjID0+IGMgaW5zdGFuY2VvZiBIaW5nZUNvbnN0cmFpbnQ7CiAgZnVuY3Rpb24gc3luY0JvZGllcygpIHsKICAgIHN0YXRlLmJvZGllc05lZWRTeW5jaW5nID0gdHJ1ZTsKICAgIHN0YXRlLmJvZGllcyA9IHN0YXRlLndvcmxkLmJvZGllcy5yZWR1Y2UoKGJvZGllcywgYm9keSkgPT4gYm9keS51dWlkID8gewogICAgICAuLi5ib2RpZXMsCiAgICAgIFtib2R5LnV1aWRdOiBib2R5CiAgICB9IDogYm9kaWVzLCB7fSk7CiAgfQogIGNvbnN0IGJyb2FkcGhhc2VzID0gewogICAgTmFpdmVCcm9hZHBoYXNlLAogICAgU0FQQnJvYWRwaGFzZQogIH07CiAgY29uc3QgY3JlYXRlTWF0ZXJpYWwgPSBjcmVhdGVNYXRlcmlhbEZhY3Rvcnkoc3RhdGUubWF0ZXJpYWxzKTsKICBzZWxmLm9ubWVzc2FnZSA9IF9yZWYgPT4gewogICAgbGV0IHsKICAgICAgZGF0YQogICAgfSA9IF9yZWY7CiAgICBzd2l0Y2ggKGRhdGEub3ApIHsKICAgICAgY2FzZSAnaW5pdCc6CiAgICAgICAgewogICAgICAgICAgaW5pdChzdGF0ZS53b3JsZCwgZGF0YS5wcm9wcyk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3N0ZXAnOgogICAgICAgIHsKICAgICAgICAgIHN0ZXAoc3RhdGUsIGRhdGEpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdhZGRCb2RpZXMnOgogICAgICAgIHsKICAgICAgICAgIGFkZEJvZGllcyhzdGF0ZSwgY3JlYXRlTWF0ZXJpYWwsIGRhdGEpOwogICAgICAgICAgc3luY0JvZGllcygpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdyZW1vdmVCb2RpZXMnOgogICAgICAgIHsKICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS51dWlkLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHN0YXRlLndvcmxkLnJlbW92ZUJvZHkoc3RhdGUuYm9kaWVzW2RhdGEudXVpZFtpXV0pOwogICAgICAgICAgICBjb25zdCBrZXkgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdWJzY3JpcHRpb25zKS5maW5kKGsgPT4gc3RhdGUuc3Vic2NyaXB0aW9uc1trXVswXSA9PT0gZGF0YS51dWlkW2ldKTsKICAgICAgICAgICAgaWYgKGtleSkgewogICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5zdWJzY3JpcHRpb25zW2tleV07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHN5bmNCb2RpZXMoKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnc3Vic2NyaWJlJzoKICAgICAgICB7CiAgICAgICAgICBjb25zdCB7CiAgICAgICAgICAgIGlkLAogICAgICAgICAgICB0YXJnZXQsCiAgICAgICAgICAgIHR5cGUKICAgICAgICAgIH0gPSBkYXRhLnByb3BzOwogICAgICAgICAgc3RhdGUuc3Vic2NyaXB0aW9uc1tpZF0gPSBbZGF0YS51dWlkLCB0eXBlLCB0YXJnZXRdOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICd1bnN1YnNjcmliZSc6CiAgICAgICAgewogICAgICAgICAgZGVsZXRlIHN0YXRlLnN1YnNjcmlwdGlvbnNbZGF0YS5wcm9wc107CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3NldFBvc2l0aW9uJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5wb3NpdGlvbi5zZXQoZGF0YS5wcm9wc1swXSwgZGF0YS5wcm9wc1sxXSwgZGF0YS5wcm9wc1syXSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldFF1YXRlcm5pb24nOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLnF1YXRlcm5pb24uc2V0KGRhdGEucHJvcHNbMF0sIGRhdGEucHJvcHNbMV0sIGRhdGEucHJvcHNbMl0sIGRhdGEucHJvcHNbM10pOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRSb3RhdGlvbic6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0ucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoZGF0YS5wcm9wc1swXSwgZGF0YS5wcm9wc1sxXSwgZGF0YS5wcm9wc1syXSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldFZlbG9jaXR5JzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS52ZWxvY2l0eS5zZXQoZGF0YS5wcm9wc1swXSwgZGF0YS5wcm9wc1sxXSwgZGF0YS5wcm9wc1syXSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldEFuZ3VsYXJWZWxvY2l0eSc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0uYW5ndWxhclZlbG9jaXR5LnNldChkYXRhLnByb3BzWzBdLCBkYXRhLnByb3BzWzFdLCBkYXRhLnByb3BzWzJdKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0TGluZWFyRmFjdG9yJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5saW5lYXJGYWN0b3Iuc2V0KGRhdGEucHJvcHNbMF0sIGRhdGEucHJvcHNbMV0sIGRhdGEucHJvcHNbMl0pOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRBbmd1bGFyRmFjdG9yJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5hbmd1bGFyRmFjdG9yLnNldChkYXRhLnByb3BzWzBdLCBkYXRhLnByb3BzWzFdLCBkYXRhLnByb3BzWzJdKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0TWFzcyc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0ubWFzcyA9IGRhdGEucHJvcHM7CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0udXBkYXRlTWFzc1Byb3BlcnRpZXMoKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0TWF0ZXJpYWwnOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLm1hdGVyaWFsID0gZGF0YS5wcm9wcyA/IGNyZWF0ZU1hdGVyaWFsKGRhdGEucHJvcHMpIDogbnVsbDsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0TGluZWFyRGFtcGluZyc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0ubGluZWFyRGFtcGluZyA9IGRhdGEucHJvcHM7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldEFuZ3VsYXJEYW1waW5nJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5hbmd1bGFyRGFtcGluZyA9IGRhdGEucHJvcHM7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldEFsbG93U2xlZXAnOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmFsbG93U2xlZXAgPSBkYXRhLnByb3BzOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRTbGVlcFNwZWVkTGltaXQnOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLnNsZWVwU3BlZWRMaW1pdCA9IGRhdGEucHJvcHM7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldFNsZWVwVGltZUxpbWl0JzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5zbGVlcFRpbWVMaW1pdCA9IGRhdGEucHJvcHM7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldENvbGxpc2lvbkZpbHRlckdyb3VwJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IGRhdGEucHJvcHM7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldENvbGxpc2lvbkZpbHRlck1hc2snOgogICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLmNvbGxpc2lvbkZpbHRlck1hc2sgPSBkYXRhLnByb3BzOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRDb2xsaXNpb25SZXNwb25zZSc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0uY29sbGlzaW9uUmVzcG9uc2UgPSBkYXRhLnByb3BzOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRGaXhlZFJvdGF0aW9uJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5maXhlZFJvdGF0aW9uID0gZGF0YS5wcm9wczsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0RnJpY3Rpb25HcmF2aXR5JzoKICAgICAgICBzdGF0ZS53b3JsZC5mcmljdGlvbkdyYXZpdHkgPSBkYXRhLnByb3BzID8gbmV3IFZlYzMoLi4uZGF0YS5wcm9wcykgOiB1bmRlZmluZWQ7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldElzVHJpZ2dlcic6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0uaXNUcmlnZ2VyID0gZGF0YS5wcm9wczsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0R3Jhdml0eSc6CiAgICAgICAgc3RhdGUud29ybGQuZ3Jhdml0eS5zZXQoZGF0YS5wcm9wc1swXSwgZGF0YS5wcm9wc1sxXSwgZGF0YS5wcm9wc1syXSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldFRvbGVyYW5jZSc6CiAgICAgICAgaWYgKHN0YXRlLndvcmxkLnNvbHZlciBpbnN0YW5jZW9mIEdTU29sdmVyKSB7CiAgICAgICAgICBzdGF0ZS53b3JsZC5zb2x2ZXIudG9sZXJhbmNlID0gZGF0YS5wcm9wczsKICAgICAgICB9CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldEl0ZXJhdGlvbnMnOgogICAgICAgIGlmIChzdGF0ZS53b3JsZC5zb2x2ZXIgaW5zdGFuY2VvZiBHU1NvbHZlcikgewogICAgICAgICAgc3RhdGUud29ybGQuc29sdmVyLml0ZXJhdGlvbnMgPSBkYXRhLnByb3BzOwogICAgICAgIH0KICAgICAgICBicmVhazsKICAgICAgY2FzZSAnc2V0QnJvYWRwaGFzZSc6CiAgICAgICAgc3RhdGUud29ybGQuYnJvYWRwaGFzZSA9IG5ldyAoYnJvYWRwaGFzZXNbYCR7ZGF0YS5wcm9wc31Ccm9hZHBoYXNlYF0gfHwgTmFpdmVCcm9hZHBoYXNlKShzdGF0ZS53b3JsZCk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldEF4aXNJbmRleCc6CiAgICAgICAgaWYgKHN0YXRlLndvcmxkLmJyb2FkcGhhc2UgaW5zdGFuY2VvZiBTQVBCcm9hZHBoYXNlKSB7CiAgICAgICAgICBzdGF0ZS53b3JsZC5icm9hZHBoYXNlLmF4aXNJbmRleCA9IGRhdGEucHJvcHMgPT09IHVuZGVmaW5lZCB8fCBkYXRhLnByb3BzID09PSBudWxsID8gMCA6IGRhdGEucHJvcHM7CiAgICAgICAgfQogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdhcHBseUZvcmNlJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5hcHBseUZvcmNlKG5ldyBWZWMzKC4uLmRhdGEucHJvcHNbMF0pLCBuZXcgVmVjMyguLi5kYXRhLnByb3BzWzFdKSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ2FwcGx5SW1wdWxzZSc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0uYXBwbHlJbXB1bHNlKG5ldyBWZWMzKC4uLmRhdGEucHJvcHNbMF0pLCBuZXcgVmVjMyguLi5kYXRhLnByb3BzWzFdKSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ2FwcGx5TG9jYWxGb3JjZSc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0uYXBwbHlMb2NhbEZvcmNlKG5ldyBWZWMzKC4uLmRhdGEucHJvcHNbMF0pLCBuZXcgVmVjMyguLi5kYXRhLnByb3BzWzFdKSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ2FwcGx5TG9jYWxJbXB1bHNlJzoKICAgICAgICBzdGF0ZS5ib2RpZXNbZGF0YS51dWlkXS5hcHBseUxvY2FsSW1wdWxzZShuZXcgVmVjMyguLi5kYXRhLnByb3BzWzBdKSwgbmV3IFZlYzMoLi4uZGF0YS5wcm9wc1sxXSkpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdhcHBseVRvcnF1ZSc6CiAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0uYXBwbHlUb3JxdWUobmV3IFZlYzMoLi4uZGF0YS5wcm9wc1swXSkpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdhZGRDb25zdHJhaW50JzoKICAgICAgICB7CiAgICAgICAgICBhZGRDb25zdHJhaW50KHN0YXRlLCBkYXRhKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAncmVtb3ZlQ29uc3RyYWludCc6CiAgICAgICAgc3RhdGUud29ybGQuY29uc3RyYWludHMuZmlsdGVyKF9yZWYyID0+IHsKICAgICAgICAgIGxldCB7CiAgICAgICAgICAgIHV1aWQKICAgICAgICAgIH0gPSBfcmVmMjsKICAgICAgICAgIHJldHVybiB1dWlkID09PSBkYXRhLnV1aWQ7CiAgICAgICAgfSkubWFwKGMgPT4gc3RhdGUud29ybGQucmVtb3ZlQ29uc3RyYWludChjKSk7CiAgICAgICAgaWYgKHN0YXRlLmNvbnN0cmFpbnRzW2RhdGEudXVpZF0pIHsKICAgICAgICAgIHN0YXRlLndvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bvc3RTdGVwJywgc3RhdGUuY29uc3RyYWludHNbZGF0YS51dWlkXSk7CiAgICAgICAgICBkZWxldGUgc3RhdGUuY29uc3RyYWludHNbZGF0YS51dWlkXTsKICAgICAgICB9CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ2VuYWJsZUNvbnN0cmFpbnQnOgogICAgICAgIHN0YXRlLndvcmxkLmNvbnN0cmFpbnRzLmZpbHRlcihjID0+IGMudXVpZCA9PT0gZGF0YS51dWlkKS5tYXAoYyA9PiBjLmVuYWJsZSgpKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnZGlzYWJsZUNvbnN0cmFpbnQnOgogICAgICAgIHN0YXRlLndvcmxkLmNvbnN0cmFpbnRzLmZpbHRlcihjID0+IGMudXVpZCA9PT0gZGF0YS51dWlkKS5tYXAoYyA9PiBjLmRpc2FibGUoKSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ2VuYWJsZUNvbnN0cmFpbnRNb3Rvcic6CiAgICAgICAgc3RhdGUud29ybGQuY29uc3RyYWludHMuZmlsdGVyKGMgPT4gYy51dWlkID09PSBkYXRhLnV1aWQpLmZpbHRlcihpc0hpbmdlQ29uc3RyYWludCkubWFwKGMgPT4gYy5lbmFibGVNb3RvcigpKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnZGlzYWJsZUNvbnN0cmFpbnRNb3Rvcic6CiAgICAgICAgc3RhdGUud29ybGQuY29uc3RyYWludHMuZmlsdGVyKGMgPT4gYy51dWlkID09PSBkYXRhLnV1aWQpLmZpbHRlcihpc0hpbmdlQ29uc3RyYWludCkubWFwKGMgPT4gYy5kaXNhYmxlTW90b3IoKSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgJ3NldENvbnN0cmFpbnRNb3RvclNwZWVkJzoKICAgICAgICBzdGF0ZS53b3JsZC5jb25zdHJhaW50cy5maWx0ZXIoYyA9PiBjLnV1aWQgPT09IGRhdGEudXVpZCkuZmlsdGVyKGlzSGluZ2VDb25zdHJhaW50KS5tYXAoYyA9PiBjLnNldE1vdG9yU3BlZWQoZGF0YS5wcm9wcykpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICdzZXRDb25zdHJhaW50TW90b3JNYXhGb3JjZSc6CiAgICAgICAgc3RhdGUud29ybGQuY29uc3RyYWludHMuZmlsdGVyKGMgPT4gYy51dWlkID09PSBkYXRhLnV1aWQpLmZpbHRlcihpc0hpbmdlQ29uc3RyYWludCkubWFwKGMgPT4gYy5zZXRNb3Rvck1heEZvcmNlKGRhdGEucHJvcHMpKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAnYWRkU3ByaW5nJzoKICAgICAgICB7CiAgICAgICAgICBhZGRTcHJpbmcoc3RhdGUsIGRhdGEpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdzZXRTcHJpbmdTdGlmZm5lc3MnOgogICAgICAgIHsKICAgICAgICAgIHN0YXRlLnNwcmluZ0luc3RhbmNlc1tkYXRhLnV1aWRdLnN0aWZmbmVzcyA9IGRhdGEucHJvcHM7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3NldFNwcmluZ1Jlc3RMZW5ndGgnOgogICAgICAgIHsKICAgICAgICAgIHN0YXRlLnNwcmluZ0luc3RhbmNlc1tkYXRhLnV1aWRdLnJlc3RMZW5ndGggPSBkYXRhLnByb3BzOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdzZXRTcHJpbmdEYW1waW5nJzoKICAgICAgICB7CiAgICAgICAgICBzdGF0ZS5zcHJpbmdJbnN0YW5jZXNbZGF0YS51dWlkXS5kYW1waW5nID0gZGF0YS5wcm9wczsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAncmVtb3ZlU3ByaW5nJzoKICAgICAgICB7CiAgICAgICAgICBzdGF0ZS53b3JsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3N0U3RlcCcsIHN0YXRlLnNwcmluZ3NbZGF0YS51dWlkXSk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ2FkZFJheSc6CiAgICAgICAgewogICAgICAgICAgYWRkUmF5KHN0YXRlLCBkYXRhKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAncmVtb3ZlUmF5JzoKICAgICAgICB7CiAgICAgICAgICBzdGF0ZS53b3JsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdwcmVTdGVwJywgc3RhdGUucmF5c1tkYXRhLnV1aWRdKTsKICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5yYXlzW2RhdGEudXVpZF07CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ2FkZFJheWNhc3RWZWhpY2xlJzoKICAgICAgICB7CiAgICAgICAgICBhZGRSYXljYXN0VmVoaWNsZShzdGF0ZSwgZGF0YSk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3JlbW92ZVJheWNhc3RWZWhpY2xlJzoKICAgICAgICB7CiAgICAgICAgICBzdGF0ZS53b3JsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdwcmVTdGVwJywgc3RhdGUudmVoaWNsZXNbZGF0YS51dWlkXS5wcmVTdGVwKTsKICAgICAgICAgIHN0YXRlLndvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bvc3RTdGVwJywgc3RhdGUudmVoaWNsZXNbZGF0YS51dWlkXS5wb3N0U3RlcCk7CiAgICAgICAgICBzdGF0ZS52ZWhpY2xlc1tkYXRhLnV1aWRdLnZlaGljbGUud29ybGQgPSBudWxsOwogICAgICAgICAgZGVsZXRlIHN0YXRlLnZlaGljbGVzW2RhdGEudXVpZF07CiAgICAgICAgICBjb25zdCBrZXkgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdWJzY3JpcHRpb25zKS5maW5kKGsgPT4gc3RhdGUuc3Vic2NyaXB0aW9uc1trXVswXSA9PT0gZGF0YS51dWlkKTsKICAgICAgICAgIGlmIChrZXkpIHsKICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnN1YnNjcmlwdGlvbnNba2V5XTsKICAgICAgICAgIH0KICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnc2V0UmF5Y2FzdFZlaGljbGVTdGVlcmluZ1ZhbHVlJzoKICAgICAgICB7CiAgICAgICAgICBjb25zdCBbdmFsdWUsIHdoZWVsSW5kZXhdID0gZGF0YS5wcm9wczsKICAgICAgICAgIHN0YXRlLnZlaGljbGVzW2RhdGEudXVpZF0udmVoaWNsZS5zZXRTdGVlcmluZ1ZhbHVlKHZhbHVlLCB3aGVlbEluZGV4KTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnYXBwbHlSYXljYXN0VmVoaWNsZUVuZ2luZUZvcmNlJzoKICAgICAgICB7CiAgICAgICAgICBjb25zdCBbdmFsdWUsIHdoZWVsSW5kZXhdID0gZGF0YS5wcm9wczsKICAgICAgICAgIHN0YXRlLnZlaGljbGVzW2RhdGEudXVpZF0udmVoaWNsZS5hcHBseUVuZ2luZUZvcmNlKHZhbHVlLCB3aGVlbEluZGV4KTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgY2FzZSAnc2V0UmF5Y2FzdFZlaGljbGVCcmFrZSc6CiAgICAgICAgewogICAgICAgICAgY29uc3QgW2JyYWtlLCB3aGVlbEluZGV4XSA9IGRhdGEucHJvcHM7CiAgICAgICAgICBzdGF0ZS52ZWhpY2xlc1tkYXRhLnV1aWRdLnZlaGljbGUuc2V0QnJha2UoYnJha2UsIHdoZWVsSW5kZXgpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdhZGRDb250YWN0TWF0ZXJpYWwnOgogICAgICAgIHsKICAgICAgICAgIGFkZENvbnRhY3RNYXRlcmlhbChzdGF0ZS53b3JsZCwgY3JlYXRlTWF0ZXJpYWwsIGRhdGEucHJvcHMsIGRhdGEudXVpZCk7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIGNhc2UgJ3JlbW92ZUNvbnRhY3RNYXRlcmlhbCc6CiAgICAgICAgewogICAgICAgICAgcmVtb3ZlQ29udGFjdE1hdGVyaWFsKHN0YXRlLndvcmxkLCBkYXRhLnV1aWQpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICd3YWtlVXAnOgogICAgICAgIHsKICAgICAgICAgIHN0YXRlLmJvZGllc1tkYXRhLnV1aWRdLndha2VVcCgpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBjYXNlICdzbGVlcCc6CiAgICAgICAgewogICAgICAgICAgc3RhdGUuYm9kaWVzW2RhdGEudXVpZF0uc2xlZXAoKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgIH0KICB9OwoKfSkoKTsKCg==', null, false);\n/* eslint-enable */\nvar CannonWorkerAPI = /*#__PURE__*/function (_EventEmitter$) {\n  _inherits(CannonWorkerAPI, _EventEmitter$);\n  var _super = _createSuper(CannonWorkerAPI);\n  function CannonWorkerAPI(_ref) {\n    var _this;\n    _classCallCheck(this, CannonWorkerAPI);\n    var _ref$allowSleep = _ref.allowSleep,\n      allowSleep = _ref$allowSleep === void 0 ? false : _ref$allowSleep,\n      _ref$axisIndex = _ref.axisIndex,\n      axisIndex = _ref$axisIndex === void 0 ? 0 : _ref$axisIndex,\n      _ref$broadphase = _ref.broadphase,\n      broadphase = _ref$broadphase === void 0 ? 'Naive' : _ref$broadphase,\n      _ref$defaultContactMa = _ref.defaultContactMaterial,\n      defaultContactMaterial = _ref$defaultContactMa === void 0 ? {\n        contactEquationStiffness: 1e6\n      } : _ref$defaultContactMa,\n      _ref$frictionGravity = _ref.frictionGravity,\n      frictionGravity = _ref$frictionGravity === void 0 ? null : _ref$frictionGravity,\n      _ref$gravity = _ref.gravity,\n      gravity = _ref$gravity === void 0 ? [0, -9.81, 0] : _ref$gravity,\n      _ref$iterations = _ref.iterations,\n      iterations = _ref$iterations === void 0 ? 5 : _ref$iterations,\n      _ref$quatNormalizeFas = _ref.quatNormalizeFast,\n      quatNormalizeFast = _ref$quatNormalizeFas === void 0 ? false : _ref$quatNormalizeFas,\n      _ref$quatNormalizeSki = _ref.quatNormalizeSkip,\n      quatNormalizeSkip = _ref$quatNormalizeSki === void 0 ? 0 : _ref$quatNormalizeSki,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 1000 : _ref$size,\n      _ref$solver = _ref.solver,\n      solver = _ref$solver === void 0 ? 'GS' : _ref$solver,\n      _ref$tolerance = _ref.tolerance,\n      tolerance = _ref$tolerance === void 0 ? 0.001 : _ref$tolerance;\n    _this = _super.call(this);\n    _defineProperty(_assertThisInitialized(_this), \"messageQueue\", []);\n    _defineProperty(_assertThisInitialized(_this), \"worker\", null);\n    _this.config = {\n      allowSleep: allowSleep,\n      axisIndex: axisIndex,\n      broadphase: broadphase,\n      defaultContactMaterial: defaultContactMaterial,\n      frictionGravity: frictionGravity,\n      gravity: gravity,\n      iterations: iterations,\n      quatNormalizeFast: quatNormalizeFast,\n      quatNormalizeSkip: quatNormalizeSkip,\n      size: size,\n      solver: solver,\n      tolerance: tolerance\n    };\n    _this.buffers = {\n      positions: new Float32Array(size * 3),\n      quaternions: new Float32Array(size * 4)\n    };\n    return _this;\n  }\n  _createClass(CannonWorkerAPI, [{\n    key: \"axisIndex\",\n    get: function get() {\n      return this.config.axisIndex;\n    },\n    set: function set(value) {\n      this.config.axisIndex = value;\n      this.postMessage({\n        op: 'setAxisIndex',\n        props: value\n      });\n    }\n  }, {\n    key: \"broadphase\",\n    get: function get() {\n      return this.config.broadphase;\n    },\n    set: function set(value) {\n      this.config.broadphase = value;\n      this.postMessage({\n        op: 'setBroadphase',\n        props: value\n      });\n    }\n  }, {\n    key: \"frictionGravity\",\n    get: function get() {\n      return this.config.frictionGravity;\n    },\n    set: function set(value) {\n      this.config.frictionGravity = value;\n      this.postMessage({\n        op: 'setFrictionGravity',\n        props: value\n      });\n    }\n  }, {\n    key: \"gravity\",\n    get: function get() {\n      return this.config.gravity;\n    },\n    set: function set(value) {\n      this.config.gravity = value;\n      this.postMessage({\n        op: 'setGravity',\n        props: value\n      });\n    }\n  }, {\n    key: \"iterations\",\n    get: function get() {\n      return this.config.iterations;\n    },\n    set: function set(value) {\n      this.config.iterations = value;\n      this.postMessage({\n        op: 'setIterations',\n        props: value\n      });\n    }\n  }, {\n    key: \"tolerance\",\n    get: function get() {\n      return this.config.tolerance;\n    },\n    set: function set(value) {\n      this.config.tolerance = value;\n      this.postMessage({\n        op: 'setTolerance',\n        props: value\n      });\n    }\n  }, {\n    key: \"addBodies\",\n    value: function addBodies(_ref2) {\n      var props = _ref2.props,\n        type = _ref2.type,\n        uuid = _ref2.uuid;\n      this.postMessage({\n        op: 'addBodies',\n        props: props,\n        type: type,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"addConstraint\",\n    value: function addConstraint(_ref3) {\n      var _ref3$props = _slicedToArray(_ref3.props, 3),\n        refA = _ref3$props[0],\n        refB = _ref3$props[1],\n        optns = _ref3$props[2],\n        type = _ref3.type,\n        uuid = _ref3.uuid;\n      this.postMessage({\n        op: 'addConstraint',\n        props: [refA, refB, optns],\n        type: type,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"addContactMaterial\",\n    value: function addContactMaterial(_ref4) {\n      var props = _ref4.props,\n        uuid = _ref4.uuid;\n      this.postMessage({\n        op: 'addContactMaterial',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"addRay\",\n    value: function addRay(_ref5) {\n      var props = _ref5.props,\n        uuid = _ref5.uuid;\n      this.postMessage({\n        op: 'addRay',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"addRaycastVehicle\",\n    value: function addRaycastVehicle(_ref6) {\n      var _ref6$props = _slicedToArray(_ref6.props, 6),\n        chassisBodyUUID = _ref6$props[0],\n        wheelUUIDs = _ref6$props[1],\n        wheelInfos = _ref6$props[2],\n        indexForwardAxis = _ref6$props[3],\n        indexRightAxis = _ref6$props[4],\n        indexUpAxis = _ref6$props[5],\n        uuid = _ref6.uuid;\n      this.postMessage({\n        op: 'addRaycastVehicle',\n        props: [chassisBodyUUID, wheelUUIDs, wheelInfos, indexForwardAxis, indexRightAxis, indexUpAxis],\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"addSpring\",\n    value: function addSpring(_ref7) {\n      var _ref7$props = _slicedToArray(_ref7.props, 3),\n        refA = _ref7$props[0],\n        refB = _ref7$props[1],\n        optns = _ref7$props[2],\n        uuid = _ref7.uuid;\n      this.postMessage({\n        op: 'addSpring',\n        props: [refA, refB, optns],\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"applyForce\",\n    value: function applyForce(_ref8) {\n      var props = _ref8.props,\n        uuid = _ref8.uuid;\n      this.postMessage({\n        op: 'applyForce',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"applyImpulse\",\n    value: function applyImpulse(_ref9) {\n      var props = _ref9.props,\n        uuid = _ref9.uuid;\n      this.postMessage({\n        op: 'applyImpulse',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"applyLocalForce\",\n    value: function applyLocalForce(_ref10) {\n      var props = _ref10.props,\n        uuid = _ref10.uuid;\n      this.postMessage({\n        op: 'applyLocalForce',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"applyLocalImpulse\",\n    value: function applyLocalImpulse(_ref11) {\n      var props = _ref11.props,\n        uuid = _ref11.uuid;\n      this.postMessage({\n        op: 'applyLocalImpulse',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"applyRaycastVehicleEngineForce\",\n    value: function applyRaycastVehicleEngineForce(_ref12) {\n      var props = _ref12.props,\n        uuid = _ref12.uuid;\n      this.postMessage({\n        op: 'applyRaycastVehicleEngineForce',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"applyTorque\",\n    value: function applyTorque(_ref13) {\n      var props = _ref13.props,\n        uuid = _ref13.uuid;\n      this.postMessage({\n        op: 'applyTorque',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n      this.worker = new WorkerFactory();\n      this.worker.onmessage = function (message) {\n        if (message.data.op === 'frame') {\n          _this2.buffers.positions = message.data.positions;\n          _this2.buffers.quaternions = message.data.quaternions;\n          _this2.emit(message.data.op, message.data);\n          return;\n        }\n        _this2.emit(message.data.type, message.data);\n      };\n      var _iterator = _createForOfIteratorHelper(this.messageQueue),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var message = _step.value;\n          this.worker.postMessage(message);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.messageQueue.length = 0;\n    }\n  }, {\n    key: \"disableConstraint\",\n    value: function disableConstraint(_ref14) {\n      var uuid = _ref14.uuid;\n      this.postMessage({\n        op: 'disableConstraint',\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"disableConstraintMotor\",\n    value: function disableConstraintMotor(_ref15) {\n      var uuid = _ref15.uuid;\n      this.postMessage({\n        op: 'disableConstraintMotor',\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this.worker) this.worker.onmessage = null;\n    }\n  }, {\n    key: \"enableConstraint\",\n    value: function enableConstraint(_ref16) {\n      var uuid = _ref16.uuid;\n      this.postMessage({\n        op: 'enableConstraint',\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"enableConstraintMotor\",\n    value: function enableConstraintMotor(_ref17) {\n      var uuid = _ref17.uuid;\n      this.postMessage({\n        op: 'enableConstraintMotor',\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      var _this$config = this.config,\n        allowSleep = _this$config.allowSleep,\n        axisIndex = _this$config.axisIndex,\n        broadphase = _this$config.broadphase,\n        defaultContactMaterial = _this$config.defaultContactMaterial,\n        frictionGravity = _this$config.frictionGravity,\n        gravity = _this$config.gravity,\n        iterations = _this$config.iterations,\n        quatNormalizeFast = _this$config.quatNormalizeFast,\n        quatNormalizeSkip = _this$config.quatNormalizeSkip,\n        solver = _this$config.solver,\n        tolerance = _this$config.tolerance;\n      this.postMessage({\n        op: 'init',\n        props: {\n          allowSleep: allowSleep,\n          axisIndex: axisIndex,\n          broadphase: broadphase,\n          defaultContactMaterial: defaultContactMaterial,\n          frictionGravity: frictionGravity,\n          gravity: gravity,\n          iterations: iterations,\n          quatNormalizeFast: quatNormalizeFast,\n          quatNormalizeSkip: quatNormalizeSkip,\n          solver: solver,\n          tolerance: tolerance\n        }\n      });\n    }\n  }, {\n    key: \"removeBodies\",\n    value: function removeBodies(_ref18) {\n      var uuid = _ref18.uuid;\n      this.postMessage({\n        op: 'removeBodies',\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"removeConstraint\",\n    value: function removeConstraint(_ref19) {\n      var uuid = _ref19.uuid;\n      this.postMessage({\n        op: 'removeConstraint',\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"removeContactMaterial\",\n    value: function removeContactMaterial(_ref20) {\n      var uuid = _ref20.uuid;\n      this.postMessage({\n        op: 'removeContactMaterial',\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"removeRay\",\n    value: function removeRay(_ref21) {\n      var uuid = _ref21.uuid;\n      this.postMessage({\n        op: 'removeRay',\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"removeRaycastVehicle\",\n    value: function removeRaycastVehicle(_ref22) {\n      var uuid = _ref22.uuid;\n      this.postMessage({\n        op: 'removeRaycastVehicle',\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"removeSpring\",\n    value: function removeSpring(_ref23) {\n      var uuid = _ref23.uuid;\n      this.postMessage({\n        op: 'removeSpring',\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setAllowSleep\",\n    value: function setAllowSleep(_ref24) {\n      var props = _ref24.props,\n        uuid = _ref24.uuid;\n      this.postMessage({\n        op: 'setAllowSleep',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setAngularDamping\",\n    value: function setAngularDamping(_ref25) {\n      var props = _ref25.props,\n        uuid = _ref25.uuid;\n      this.postMessage({\n        op: 'setAngularDamping',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setAngularFactor\",\n    value: function setAngularFactor(_ref26) {\n      var props = _ref26.props,\n        uuid = _ref26.uuid;\n      this.postMessage({\n        op: 'setAngularFactor',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setAngularVelocity\",\n    value: function setAngularVelocity(_ref27) {\n      var props = _ref27.props,\n        uuid = _ref27.uuid;\n      this.postMessage({\n        op: 'setAngularVelocity',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setCollisionFilterGroup\",\n    value: function setCollisionFilterGroup(_ref28) {\n      var props = _ref28.props,\n        uuid = _ref28.uuid;\n      this.postMessage({\n        op: 'setCollisionFilterGroup',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setCollisionFilterMask\",\n    value: function setCollisionFilterMask(_ref29) {\n      var props = _ref29.props,\n        uuid = _ref29.uuid;\n      this.postMessage({\n        op: 'setCollisionFilterMask',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setCollisionResponse\",\n    value: function setCollisionResponse(_ref30) {\n      var props = _ref30.props,\n        uuid = _ref30.uuid;\n      this.postMessage({\n        op: 'setCollisionResponse',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setConstraintMotorMaxForce\",\n    value: function setConstraintMotorMaxForce(_ref31) {\n      var props = _ref31.props,\n        uuid = _ref31.uuid;\n      this.postMessage({\n        op: 'setConstraintMotorMaxForce',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setConstraintMotorSpeed\",\n    value: function setConstraintMotorSpeed(_ref32) {\n      var props = _ref32.props,\n        uuid = _ref32.uuid;\n      this.postMessage({\n        op: 'setConstraintMotorSpeed',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setFixedRotation\",\n    value: function setFixedRotation(_ref33) {\n      var props = _ref33.props,\n        uuid = _ref33.uuid;\n      this.postMessage({\n        op: 'setFixedRotation',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setIsTrigger\",\n    value: function setIsTrigger(_ref34) {\n      var props = _ref34.props,\n        uuid = _ref34.uuid;\n      this.postMessage({\n        op: 'setIsTrigger',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setLinearDamping\",\n    value: function setLinearDamping(_ref35) {\n      var props = _ref35.props,\n        uuid = _ref35.uuid;\n      this.postMessage({\n        op: 'setLinearDamping',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setLinearFactor\",\n    value: function setLinearFactor(_ref36) {\n      var props = _ref36.props,\n        uuid = _ref36.uuid;\n      this.postMessage({\n        op: 'setLinearFactor',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setMass\",\n    value: function setMass(_ref37) {\n      var props = _ref37.props,\n        uuid = _ref37.uuid;\n      this.postMessage({\n        op: 'setMass',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setMaterial\",\n    value: function setMaterial(_ref38) {\n      var props = _ref38.props,\n        uuid = _ref38.uuid;\n      this.postMessage({\n        op: 'setMaterial',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(_ref39) {\n      var props = _ref39.props,\n        uuid = _ref39.uuid;\n      this.postMessage({\n        op: 'setPosition',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setQuaternion\",\n    value: function setQuaternion(_ref40) {\n      var _ref40$props = _slicedToArray(_ref40.props, 4),\n        x = _ref40$props[0],\n        y = _ref40$props[1],\n        z = _ref40$props[2],\n        w = _ref40$props[3],\n        uuid = _ref40.uuid;\n      this.postMessage({\n        op: 'setQuaternion',\n        props: [x, y, z, w],\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setRaycastVehicleBrake\",\n    value: function setRaycastVehicleBrake(_ref41) {\n      var props = _ref41.props,\n        uuid = _ref41.uuid;\n      this.postMessage({\n        op: 'setRaycastVehicleBrake',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setRaycastVehicleSteeringValue\",\n    value: function setRaycastVehicleSteeringValue(_ref42) {\n      var props = _ref42.props,\n        uuid = _ref42.uuid;\n      this.postMessage({\n        op: 'setRaycastVehicleSteeringValue',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setRotation\",\n    value: function setRotation(_ref43) {\n      var props = _ref43.props,\n        uuid = _ref43.uuid;\n      this.postMessage({\n        op: 'setRotation',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setSleepSpeedLimit\",\n    value: function setSleepSpeedLimit(_ref44) {\n      var props = _ref44.props,\n        uuid = _ref44.uuid;\n      this.postMessage({\n        op: 'setSleepSpeedLimit',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setSleepTimeLimit\",\n    value: function setSleepTimeLimit(_ref45) {\n      var props = _ref45.props,\n        uuid = _ref45.uuid;\n      this.postMessage({\n        op: 'setSleepTimeLimit',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setSpringDamping\",\n    value: function setSpringDamping(_ref46) {\n      var props = _ref46.props,\n        uuid = _ref46.uuid;\n      this.postMessage({\n        op: 'setSpringDamping',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setSpringRestLength\",\n    value: function setSpringRestLength(_ref47) {\n      var props = _ref47.props,\n        uuid = _ref47.uuid;\n      this.postMessage({\n        op: 'setSpringRestLength',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setSpringStiffness\",\n    value: function setSpringStiffness(_ref48) {\n      var props = _ref48.props,\n        uuid = _ref48.uuid;\n      this.postMessage({\n        op: 'setSpringStiffness',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setUserData\",\n    value: function setUserData(_ref49) {\n      var props = _ref49.props,\n        uuid = _ref49.uuid;\n      this.postMessage({\n        op: 'setUserData',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"setVelocity\",\n    value: function setVelocity(_ref50) {\n      var props = _ref50.props,\n        uuid = _ref50.uuid;\n      this.postMessage({\n        op: 'setVelocity',\n        props: props,\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"sleep\",\n    value: function sleep(_ref51) {\n      var uuid = _ref51.uuid;\n      this.postMessage({\n        op: 'sleep',\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"step\",\n    value: function step(props) {\n      var _this$worker;\n      var _this$buffers = this.buffers,\n        positions = _this$buffers.positions,\n        quaternions = _this$buffers.quaternions;\n      if (!positions.byteLength && !quaternions.byteLength) return;\n      (_this$worker = this.worker) == null ? void 0 : _this$worker.postMessage({\n        op: 'step',\n        positions: positions,\n        props: props,\n        quaternions: quaternions\n      }, [positions.buffer, quaternions.buffer]);\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(_ref52) {\n      var _ref52$props = _ref52.props,\n        id = _ref52$props.id,\n        target = _ref52$props.target,\n        type = _ref52$props.type,\n        uuid = _ref52.uuid;\n      this.postMessage({\n        op: 'subscribe',\n        props: {\n          id: id,\n          target: target,\n          type: type\n        },\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      var _this$worker2;\n      (_this$worker2 = this.worker) == null ? void 0 : _this$worker2.terminate();\n      this.worker = null;\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(_ref53) {\n      var props = _ref53.props;\n      this.postMessage({\n        op: 'unsubscribe',\n        props: props\n      });\n    }\n  }, {\n    key: \"wakeUp\",\n    value: function wakeUp(_ref54) {\n      var uuid = _ref54.uuid;\n      this.postMessage({\n        op: 'wakeUp',\n        uuid: uuid\n      });\n    }\n  }, {\n    key: \"postMessage\",\n    value: function postMessage(message) {\n      if (this.worker) return this.worker.postMessage(message);\n      this.messageQueue.push(message);\n    }\n  }]);\n  return CannonWorkerAPI;\n}(EventEmitter$1);\n/**\n * Records what objects are colliding with each other\n */\n/**\n * A 3x3 matrix.\n * Authored by {@link http://github.com/schteppe/ schteppe}\n */\nvar Mat3$1 = /*#__PURE__*/function () {\n  /**\n   * A vector of length 9, containing all matrix elements.\n   */\n\n  /**\n   * @param elements A vector of length 9, containing all matrix elements.\n   */\n  function Mat3$1(elements) {\n    _classCallCheck(this, Mat3$1);\n    if (elements === void 0) {\n      elements = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n    this.elements = elements;\n  }\n  /**\n   * Sets the matrix to identity\n   * @todo Should perhaps be renamed to `setIdentity()` to be more clear.\n   * @todo Create another function that immediately creates an identity matrix eg. `eye()`\n   */\n  _createClass(Mat3$1, [{\n    key: \"identity\",\n    value: function identity() {\n      var e = this.elements;\n      e[0] = 1;\n      e[1] = 0;\n      e[2] = 0;\n      e[3] = 0;\n      e[4] = 1;\n      e[5] = 0;\n      e[6] = 0;\n      e[7] = 0;\n      e[8] = 1;\n    }\n    /**\n     * Set all elements to zero\n     */\n  }, {\n    key: \"setZero\",\n    value: function setZero() {\n      var e = this.elements;\n      e[0] = 0;\n      e[1] = 0;\n      e[2] = 0;\n      e[3] = 0;\n      e[4] = 0;\n      e[5] = 0;\n      e[6] = 0;\n      e[7] = 0;\n      e[8] = 0;\n    }\n    /**\n     * Sets the matrix diagonal elements from a Vec3\n     */\n  }, {\n    key: \"setTrace\",\n    value: function setTrace(vector) {\n      var e = this.elements;\n      e[0] = vector.x;\n      e[4] = vector.y;\n      e[8] = vector.z;\n    }\n    /**\n     * Gets the matrix diagonal elements\n     */\n  }, {\n    key: \"getTrace\",\n    value: function getTrace(target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      var e = this.elements;\n      target.x = e[0];\n      target.y = e[4];\n      target.z = e[8];\n      return target;\n    }\n    /**\n     * Matrix-Vector multiplication\n     * @param v The vector to multiply with\n     * @param target Optional, target to save the result in.\n     */\n  }, {\n    key: \"vmult\",\n    value: function vmult(v, target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      var e = this.elements;\n      var x = v.x;\n      var y = v.y;\n      var z = v.z;\n      target.x = e[0] * x + e[1] * y + e[2] * z;\n      target.y = e[3] * x + e[4] * y + e[5] * z;\n      target.z = e[6] * x + e[7] * y + e[8] * z;\n      return target;\n    }\n    /**\n     * Matrix-scalar multiplication\n     */\n  }, {\n    key: \"smult\",\n    value: function smult(s) {\n      for (var i = 0; i < this.elements.length; i++) {\n        this.elements[i] *= s;\n      }\n    }\n    /**\n     * Matrix multiplication\n     * @param matrix Matrix to multiply with from left side.\n     */\n  }, {\n    key: \"mmult\",\n    value: function mmult(matrix, target) {\n      if (target === void 0) {\n        target = new Mat3$1();\n      }\n      var A = this.elements;\n      var B = matrix.elements;\n      var T = target.elements;\n      var a11 = A[0],\n        a12 = A[1],\n        a13 = A[2],\n        a21 = A[3],\n        a22 = A[4],\n        a23 = A[5],\n        a31 = A[6],\n        a32 = A[7],\n        a33 = A[8];\n      var b11 = B[0],\n        b12 = B[1],\n        b13 = B[2],\n        b21 = B[3],\n        b22 = B[4],\n        b23 = B[5],\n        b31 = B[6],\n        b32 = B[7],\n        b33 = B[8];\n      T[0] = a11 * b11 + a12 * b21 + a13 * b31;\n      T[1] = a11 * b12 + a12 * b22 + a13 * b32;\n      T[2] = a11 * b13 + a12 * b23 + a13 * b33;\n      T[3] = a21 * b11 + a22 * b21 + a23 * b31;\n      T[4] = a21 * b12 + a22 * b22 + a23 * b32;\n      T[5] = a21 * b13 + a22 * b23 + a23 * b33;\n      T[6] = a31 * b11 + a32 * b21 + a33 * b31;\n      T[7] = a31 * b12 + a32 * b22 + a33 * b32;\n      T[8] = a31 * b13 + a32 * b23 + a33 * b33;\n      return target;\n    }\n    /**\n     * Scale each column of the matrix\n     */\n  }, {\n    key: \"scale\",\n    value: function scale(vector, target) {\n      if (target === void 0) {\n        target = new Mat3$1();\n      }\n      var e = this.elements;\n      var t = target.elements;\n      for (var i = 0; i !== 3; i++) {\n        t[3 * i + 0] = vector.x * e[3 * i + 0];\n        t[3 * i + 1] = vector.y * e[3 * i + 1];\n        t[3 * i + 2] = vector.z * e[3 * i + 2];\n      }\n      return target;\n    }\n    /**\n     * Solve Ax=b\n     * @param b The right hand side\n     * @param target Optional. Target vector to save in.\n     * @return The solution x\n     * @todo should reuse arrays\n     */\n  }, {\n    key: \"solve\",\n    value: function solve(b, target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n\n      // Construct equations\n      var nr = 3; // num rows\n\n      var nc = 4; // num cols\n\n      var eqns = [];\n      var i;\n      var j;\n      for (i = 0; i < nr * nc; i++) {\n        eqns.push(0);\n      }\n      for (i = 0; i < 3; i++) {\n        for (j = 0; j < 3; j++) {\n          eqns[i + nc * j] = this.elements[i + 3 * j];\n        }\n      }\n      eqns[3 + 4 * 0] = b.x;\n      eqns[3 + 4 * 1] = b.y;\n      eqns[3 + 4 * 2] = b.z; // Compute right upper triangular version of the matrix - Gauss elimination\n\n      var n = 3;\n      var k = n;\n      var np;\n      var kp = 4; // num rows\n\n      var p;\n      do {\n        i = k - n;\n        if (eqns[i + nc * i] === 0) {\n          // the pivot is null, swap lines\n          for (j = i + 1; j < k; j++) {\n            if (eqns[i + nc * j] !== 0) {\n              np = kp;\n              do {\n                // do ligne( i ) = ligne( i ) + ligne( k )\n                p = kp - np;\n                eqns[p + nc * i] += eqns[p + nc * j];\n              } while (--np);\n              break;\n            }\n          }\n        }\n        if (eqns[i + nc * i] !== 0) {\n          for (j = i + 1; j < k; j++) {\n            var multiplier = eqns[i + nc * j] / eqns[i + nc * i];\n            np = kp;\n            do {\n              // do ligne( k ) = ligne( k ) - multiplier * ligne( i )\n              p = kp - np;\n              eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;\n            } while (--np);\n          }\n        }\n      } while (--n); // Get the solution\n\n      target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];\n      target.y = (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) / eqns[1 * nc + 1];\n      target.x = (eqns[0 * nc + 3] - eqns[0 * nc + 2] * target.z - eqns[0 * nc + 1] * target.y) / eqns[0 * nc + 0];\n      if (isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x === Infinity || target.y === Infinity || target.z === Infinity) {\n        throw \"Could not solve equation! Got x=[\".concat(target.toString(), \"], b=[\").concat(b.toString(), \"], A=[\").concat(this.toString(), \"]\");\n      }\n      return target;\n    }\n    /**\n     * Get an element in the matrix by index. Index starts at 0, not 1!!!\n     * @param value If provided, the matrix element will be set to this value.\n     */\n  }, {\n    key: \"e\",\n    value: function e(row, column, value) {\n      if (value === undefined) {\n        return this.elements[column + 3 * row];\n      } else {\n        // Set value\n        this.elements[column + 3 * row] = value;\n      }\n    }\n    /**\n     * Copy another matrix into this matrix object.\n     */\n  }, {\n    key: \"copy\",\n    value: function copy(matrix) {\n      for (var i = 0; i < matrix.elements.length; i++) {\n        this.elements[i] = matrix.elements[i];\n      }\n      return this;\n    }\n    /**\n     * Returns a string representation of the matrix.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var r = '';\n      var sep = ',';\n      for (var i = 0; i < 9; i++) {\n        r += this.elements[i] + sep;\n      }\n      return r;\n    }\n    /**\n     * reverse the matrix\n     * @param target Target matrix to save in.\n     * @return The solution x\n     */\n  }, {\n    key: \"reverse\",\n    value: function reverse(target) {\n      if (target === void 0) {\n        target = new Mat3$1();\n      }\n\n      // Construct equations\n      var nr = 3; // num rows\n\n      var nc = 6; // num cols\n\n      var eqns = reverse_eqns$1;\n      var i;\n      var j;\n      for (i = 0; i < 3; i++) {\n        for (j = 0; j < 3; j++) {\n          eqns[i + nc * j] = this.elements[i + 3 * j];\n        }\n      }\n      eqns[3 + 6 * 0] = 1;\n      eqns[3 + 6 * 1] = 0;\n      eqns[3 + 6 * 2] = 0;\n      eqns[4 + 6 * 0] = 0;\n      eqns[4 + 6 * 1] = 1;\n      eqns[4 + 6 * 2] = 0;\n      eqns[5 + 6 * 0] = 0;\n      eqns[5 + 6 * 1] = 0;\n      eqns[5 + 6 * 2] = 1; // Compute right upper triangular version of the matrix - Gauss elimination\n\n      var n = 3;\n      var k = n;\n      var np;\n      var kp = nc; // num rows\n\n      var p;\n      do {\n        i = k - n;\n        if (eqns[i + nc * i] === 0) {\n          // the pivot is null, swap lines\n          for (j = i + 1; j < k; j++) {\n            if (eqns[i + nc * j] !== 0) {\n              np = kp;\n              do {\n                // do line( i ) = line( i ) + line( k )\n                p = kp - np;\n                eqns[p + nc * i] += eqns[p + nc * j];\n              } while (--np);\n              break;\n            }\n          }\n        }\n        if (eqns[i + nc * i] !== 0) {\n          for (j = i + 1; j < k; j++) {\n            var multiplier = eqns[i + nc * j] / eqns[i + nc * i];\n            np = kp;\n            do {\n              // do line( k ) = line( k ) - multiplier * line( i )\n              p = kp - np;\n              eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;\n            } while (--np);\n          }\n        }\n      } while (--n); // eliminate the upper left triangle of the matrix\n\n      i = 2;\n      do {\n        j = i - 1;\n        do {\n          var _multiplier = eqns[i + nc * j] / eqns[i + nc * i];\n          np = nc;\n          do {\n            p = nc - np;\n            eqns[p + nc * j] = eqns[p + nc * j] - eqns[p + nc * i] * _multiplier;\n          } while (--np);\n        } while (j--);\n      } while (--i); // operations on the diagonal\n\n      i = 2;\n      do {\n        var _multiplier2 = 1 / eqns[i + nc * i];\n        np = nc;\n        do {\n          p = nc - np;\n          eqns[p + nc * i] = eqns[p + nc * i] * _multiplier2;\n        } while (--np);\n      } while (i--);\n      i = 2;\n      do {\n        j = 2;\n        do {\n          p = eqns[nr + j + nc * i];\n          if (isNaN(p) || p === Infinity) {\n            throw \"Could not reverse! A=[\".concat(this.toString(), \"]\");\n          }\n          target.e(i, j, p);\n        } while (j--);\n      } while (i--);\n      return target;\n    }\n    /**\n     * Set the matrix from a quaterion\n     */\n  }, {\n    key: \"setRotationFromQuaternion\",\n    value: function setRotationFromQuaternion(q) {\n      var x = q.x;\n      var y = q.y;\n      var z = q.z;\n      var w = q.w;\n      var x2 = x + x;\n      var y2 = y + y;\n      var z2 = z + z;\n      var xx = x * x2;\n      var xy = x * y2;\n      var xz = x * z2;\n      var yy = y * y2;\n      var yz = y * z2;\n      var zz = z * z2;\n      var wx = w * x2;\n      var wy = w * y2;\n      var wz = w * z2;\n      var e = this.elements;\n      e[3 * 0 + 0] = 1 - (yy + zz);\n      e[3 * 0 + 1] = xy - wz;\n      e[3 * 0 + 2] = xz + wy;\n      e[3 * 1 + 0] = xy + wz;\n      e[3 * 1 + 1] = 1 - (xx + zz);\n      e[3 * 1 + 2] = yz - wx;\n      e[3 * 2 + 0] = xz - wy;\n      e[3 * 2 + 1] = yz + wx;\n      e[3 * 2 + 2] = 1 - (xx + yy);\n      return this;\n    }\n    /**\n     * Transpose the matrix\n     * @param target Optional. Where to store the result.\n     * @return The target Mat3, or a new Mat3 if target was omitted.\n     */\n  }, {\n    key: \"transpose\",\n    value: function transpose(target) {\n      if (target === void 0) {\n        target = new Mat3$1();\n      }\n      var M = this.elements;\n      var T = target.elements;\n      var tmp; //Set diagonals\n\n      T[0] = M[0];\n      T[4] = M[4];\n      T[8] = M[8];\n      tmp = M[1];\n      T[1] = M[3];\n      T[3] = tmp;\n      tmp = M[2];\n      T[2] = M[6];\n      T[6] = tmp;\n      tmp = M[5];\n      T[5] = M[7];\n      T[7] = tmp;\n      return target;\n    }\n  }]);\n  return Mat3$1;\n}();\nvar reverse_eqns$1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n/**\n * 3-dimensional vector\n * @example\n *     const v = new Vec3(1, 2, 3)\n *     console.log('x=' + v.x) // x=1\n */\nvar Vec3$1 = /*#__PURE__*/function () {\n  function Vec3$1(x, y, z) {\n    _classCallCheck(this, Vec3$1);\n    if (x === void 0) {\n      x = 0.0;\n    }\n    if (y === void 0) {\n      y = 0.0;\n    }\n    if (z === void 0) {\n      z = 0.0;\n    }\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  /**\n   * Vector cross product\n   * @param target Optional target to save in.\n   */\n  _createClass(Vec3$1, [{\n    key: \"cross\",\n    value: function cross(vector, target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      var vx = vector.x;\n      var vy = vector.y;\n      var vz = vector.z;\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      target.x = y * vz - z * vy;\n      target.y = z * vx - x * vz;\n      target.z = x * vy - y * vx;\n      return target;\n    }\n    /**\n     * Set the vectors' 3 elements\n     */\n  }, {\n    key: \"set\",\n    value: function set(x, y, z) {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      return this;\n    }\n    /**\n     * Set all components of the vector to zero.\n     */\n  }, {\n    key: \"setZero\",\n    value: function setZero() {\n      this.x = this.y = this.z = 0;\n    }\n    /**\n     * Vector addition\n     */\n  }, {\n    key: \"vadd\",\n    value: function vadd(vector, target) {\n      if (target) {\n        target.x = vector.x + this.x;\n        target.y = vector.y + this.y;\n        target.z = vector.z + this.z;\n      } else {\n        return new Vec3$1(this.x + vector.x, this.y + vector.y, this.z + vector.z);\n      }\n    }\n    /**\n     * Vector subtraction\n     * @param target Optional target to save in.\n     */\n  }, {\n    key: \"vsub\",\n    value: function vsub(vector, target) {\n      if (target) {\n        target.x = this.x - vector.x;\n        target.y = this.y - vector.y;\n        target.z = this.z - vector.z;\n      } else {\n        return new Vec3$1(this.x - vector.x, this.y - vector.y, this.z - vector.z);\n      }\n    }\n    /**\n     * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c\n     *\n     * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Umeå University Lecture}\n     */\n  }, {\n    key: \"crossmat\",\n    value: function crossmat() {\n      return new Mat3$1([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);\n    }\n    /**\n     * Normalize the vector. Note that this changes the values in the vector.\n      * @return Returns the norm of the vector\n     */\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      var n = Math.sqrt(x * x + y * y + z * z);\n      if (n > 0.0) {\n        var invN = 1 / n;\n        this.x *= invN;\n        this.y *= invN;\n        this.z *= invN;\n      } else {\n        // Make something up\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n      }\n      return n;\n    }\n    /**\n     * Get the version of this vector that is of length 1.\n     * @param target Optional target to save in\n     * @return Returns the unit vector\n     */\n  }, {\n    key: \"unit\",\n    value: function unit(target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      var ninv = Math.sqrt(x * x + y * y + z * z);\n      if (ninv > 0.0) {\n        ninv = 1.0 / ninv;\n        target.x = x * ninv;\n        target.y = y * ninv;\n        target.z = z * ninv;\n      } else {\n        target.x = 1;\n        target.y = 0;\n        target.z = 0;\n      }\n      return target;\n    }\n    /**\n     * Get the length of the vector\n     */\n  }, {\n    key: \"length\",\n    value: function length() {\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      return Math.sqrt(x * x + y * y + z * z);\n    }\n    /**\n     * Get the squared length of the vector.\n     */\n  }, {\n    key: \"lengthSquared\",\n    value: function lengthSquared() {\n      return this.dot(this);\n    }\n    /**\n     * Get distance from this point to another point\n     */\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(p) {\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      var px = p.x;\n      var py = p.y;\n      var pz = p.z;\n      return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z));\n    }\n    /**\n     * Get squared distance from this point to another point\n     */\n  }, {\n    key: \"distanceSquared\",\n    value: function distanceSquared(p) {\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      var px = p.x;\n      var py = p.y;\n      var pz = p.z;\n      return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);\n    }\n    /**\n     * Multiply all the components of the vector with a scalar.\n     * @param target The vector to save the result in.\n     */\n  }, {\n    key: \"scale\",\n    value: function scale(scalar, target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      target.x = scalar * x;\n      target.y = scalar * y;\n      target.z = scalar * z;\n      return target;\n    }\n    /**\n     * Multiply the vector with an other vector, component-wise.\n     * @param target The vector to save the result in.\n     */\n  }, {\n    key: \"vmul\",\n    value: function vmul(vector, target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      target.x = vector.x * this.x;\n      target.y = vector.y * this.y;\n      target.z = vector.z * this.z;\n      return target;\n    }\n    /**\n     * Scale a vector and add it to this vector. Save the result in \"target\". (target = this + vector * scalar)\n     * @param target The vector to save the result in.\n     */\n  }, {\n    key: \"addScaledVector\",\n    value: function addScaledVector(scalar, vector, target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      target.x = this.x + scalar * vector.x;\n      target.y = this.y + scalar * vector.y;\n      target.z = this.z + scalar * vector.z;\n      return target;\n    }\n    /**\n     * Calculate dot product\n     * @param vector\n     */\n  }, {\n    key: \"dot\",\n    value: function dot(vector) {\n      return this.x * vector.x + this.y * vector.y + this.z * vector.z;\n    }\n  }, {\n    key: \"isZero\",\n    value: function isZero() {\n      return this.x === 0 && this.y === 0 && this.z === 0;\n    }\n    /**\n     * Make the vector point in the opposite direction.\n     * @param target Optional target to save in\n     */\n  }, {\n    key: \"negate\",\n    value: function negate(target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      target.x = -this.x;\n      target.y = -this.y;\n      target.z = -this.z;\n      return target;\n    }\n    /**\n     * Compute two artificial tangents to the vector\n     * @param t1 Vector object to save the first tangent in\n     * @param t2 Vector object to save the second tangent in\n     */\n  }, {\n    key: \"tangents\",\n    value: function tangents(t1, t2) {\n      var norm = this.length();\n      if (norm > 0.0) {\n        var n = Vec3_tangents_n$1;\n        var inorm = 1 / norm;\n        n.set(this.x * inorm, this.y * inorm, this.z * inorm);\n        var randVec = Vec3_tangents_randVec$1;\n        if (Math.abs(n.x) < 0.9) {\n          randVec.set(1, 0, 0);\n          n.cross(randVec, t1);\n        } else {\n          randVec.set(0, 1, 0);\n          n.cross(randVec, t1);\n        }\n        n.cross(t1, t2);\n      } else {\n        // The normal length is zero, make something up\n        t1.set(1, 0, 0);\n        t2.set(0, 1, 0);\n      }\n    }\n    /**\n     * Converts to a more readable format\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.x, \",\").concat(this.y, \",\").concat(this.z);\n    }\n    /**\n     * Converts to an array\n     */\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return [this.x, this.y, this.z];\n    }\n    /**\n     * Copies value of source to this vector.\n     */\n  }, {\n    key: \"copy\",\n    value: function copy(vector) {\n      this.x = vector.x;\n      this.y = vector.y;\n      this.z = vector.z;\n      return this;\n    }\n    /**\n     * Do a linear interpolation between two vectors\n     * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.\n     */\n  }, {\n    key: \"lerp\",\n    value: function lerp(vector, t, target) {\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      target.x = x + (vector.x - x) * t;\n      target.y = y + (vector.y - y) * t;\n      target.z = z + (vector.z - z) * t;\n    }\n    /**\n     * Check if a vector equals is almost equal to another one.\n     */\n  }, {\n    key: \"almostEquals\",\n    value: function almostEquals(vector, precision) {\n      if (precision === void 0) {\n        precision = 1e-6;\n      }\n      if (Math.abs(this.x - vector.x) > precision || Math.abs(this.y - vector.y) > precision || Math.abs(this.z - vector.z) > precision) {\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Check if a vector is almost zero\n     */\n  }, {\n    key: \"almostZero\",\n    value: function almostZero(precision) {\n      if (precision === void 0) {\n        precision = 1e-6;\n      }\n      if (Math.abs(this.x) > precision || Math.abs(this.y) > precision || Math.abs(this.z) > precision) {\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Check if the vector is anti-parallel to another vector.\n     * @param precision Set to zero for exact comparisons\n     */\n  }, {\n    key: \"isAntiparallelTo\",\n    value: function isAntiparallelTo(vector, precision) {\n      this.negate(antip_neg$1);\n      return antip_neg$1.almostEquals(vector, precision);\n    }\n    /**\n     * Clone the vector\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Vec3$1(this.x, this.y, this.z);\n    }\n  }]);\n  return Vec3$1;\n}();\nVec3$1.ZERO = new Vec3$1(0, 0, 0);\nVec3$1.UNIT_X = new Vec3$1(1, 0, 0);\nVec3$1.UNIT_Y = new Vec3$1(0, 1, 0);\nVec3$1.UNIT_Z = new Vec3$1(0, 0, 1);\nvar Vec3_tangents_n$1 = new Vec3$1();\nvar Vec3_tangents_randVec$1 = new Vec3$1();\nvar antip_neg$1 = new Vec3$1();\n\n/**\n * Axis aligned bounding box class.\n */\nvar AABB$1 = /*#__PURE__*/function () {\n  /**\n   * The lower bound of the bounding box\n   */\n\n  /**\n   * The upper bound of the bounding box\n   */\n  function AABB$1(options) {\n    _classCallCheck(this, AABB$1);\n    if (options === void 0) {\n      options = {};\n    }\n    this.lowerBound = new Vec3$1();\n    this.upperBound = new Vec3$1();\n    if (options.lowerBound) {\n      this.lowerBound.copy(options.lowerBound);\n    }\n    if (options.upperBound) {\n      this.upperBound.copy(options.upperBound);\n    }\n  }\n  /**\n   * Set the AABB bounds from a set of points.\n   * @param points An array of Vec3's.\n   * @return The self object\n   */\n  _createClass(AABB$1, [{\n    key: \"setFromPoints\",\n    value: function setFromPoints(points, position, quaternion, skinSize) {\n      var l = this.lowerBound;\n      var u = this.upperBound;\n      var q = quaternion; // Set to the first point\n\n      l.copy(points[0]);\n      if (q) {\n        q.vmult(l, l);\n      }\n      u.copy(l);\n      for (var i = 1; i < points.length; i++) {\n        var p = points[i];\n        if (q) {\n          q.vmult(p, tmp$1$1);\n          p = tmp$1$1;\n        }\n        if (p.x > u.x) {\n          u.x = p.x;\n        }\n        if (p.x < l.x) {\n          l.x = p.x;\n        }\n        if (p.y > u.y) {\n          u.y = p.y;\n        }\n        if (p.y < l.y) {\n          l.y = p.y;\n        }\n        if (p.z > u.z) {\n          u.z = p.z;\n        }\n        if (p.z < l.z) {\n          l.z = p.z;\n        }\n      } // Add offset\n\n      if (position) {\n        position.vadd(l, l);\n        position.vadd(u, u);\n      }\n      if (skinSize) {\n        l.x -= skinSize;\n        l.y -= skinSize;\n        l.z -= skinSize;\n        u.x += skinSize;\n        u.y += skinSize;\n        u.z += skinSize;\n      }\n      return this;\n    }\n    /**\n     * Copy bounds from an AABB to this AABB\n     * @param aabb Source to copy from\n     * @return The this object, for chainability\n     */\n  }, {\n    key: \"copy\",\n    value: function copy(aabb) {\n      this.lowerBound.copy(aabb.lowerBound);\n      this.upperBound.copy(aabb.upperBound);\n      return this;\n    }\n    /**\n     * Clone an AABB\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new AABB$1().copy(this);\n    }\n    /**\n     * Extend this AABB so that it covers the given AABB too.\n     */\n  }, {\n    key: \"extend\",\n    value: function extend(aabb) {\n      this.lowerBound.x = Math.min(this.lowerBound.x, aabb.lowerBound.x);\n      this.upperBound.x = Math.max(this.upperBound.x, aabb.upperBound.x);\n      this.lowerBound.y = Math.min(this.lowerBound.y, aabb.lowerBound.y);\n      this.upperBound.y = Math.max(this.upperBound.y, aabb.upperBound.y);\n      this.lowerBound.z = Math.min(this.lowerBound.z, aabb.lowerBound.z);\n      this.upperBound.z = Math.max(this.upperBound.z, aabb.upperBound.z);\n    }\n    /**\n     * Returns true if the given AABB overlaps this AABB.\n     */\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(aabb) {\n      var l1 = this.lowerBound;\n      var u1 = this.upperBound;\n      var l2 = aabb.lowerBound;\n      var u2 = aabb.upperBound; //      l2        u2\n      //      |---------|\n      // |--------|\n      // l1       u1\n\n      var overlapsX = l2.x <= u1.x && u1.x <= u2.x || l1.x <= u2.x && u2.x <= u1.x;\n      var overlapsY = l2.y <= u1.y && u1.y <= u2.y || l1.y <= u2.y && u2.y <= u1.y;\n      var overlapsZ = l2.z <= u1.z && u1.z <= u2.z || l1.z <= u2.z && u2.z <= u1.z;\n      return overlapsX && overlapsY && overlapsZ;\n    } // Mostly for debugging\n  }, {\n    key: \"volume\",\n    value: function volume() {\n      var l = this.lowerBound;\n      var u = this.upperBound;\n      return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);\n    }\n    /**\n     * Returns true if the given AABB is fully contained in this AABB.\n     */\n  }, {\n    key: \"contains\",\n    value: function contains(aabb) {\n      var l1 = this.lowerBound;\n      var u1 = this.upperBound;\n      var l2 = aabb.lowerBound;\n      var u2 = aabb.upperBound; //      l2        u2\n      //      |---------|\n      // |---------------|\n      // l1              u1\n\n      return l1.x <= l2.x && u1.x >= u2.x && l1.y <= l2.y && u1.y >= u2.y && l1.z <= l2.z && u1.z >= u2.z;\n    }\n  }, {\n    key: \"getCorners\",\n    value: function getCorners(a, b, c, d, e, f, g, h) {\n      var l = this.lowerBound;\n      var u = this.upperBound;\n      a.copy(l);\n      b.set(u.x, l.y, l.z);\n      c.set(u.x, u.y, l.z);\n      d.set(l.x, u.y, u.z);\n      e.set(u.x, l.y, u.z);\n      f.set(l.x, u.y, l.z);\n      g.set(l.x, l.y, u.z);\n      h.copy(u);\n    }\n    /**\n     * Get the representation of an AABB in another frame.\n     * @return The \"target\" AABB object.\n     */\n  }, {\n    key: \"toLocalFrame\",\n    value: function toLocalFrame(frame, target) {\n      var corners = transformIntoFrame_corners$1;\n      var a = corners[0];\n      var b = corners[1];\n      var c = corners[2];\n      var d = corners[3];\n      var e = corners[4];\n      var f = corners[5];\n      var g = corners[6];\n      var h = corners[7]; // Get corners in current frame\n\n      this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame\n\n      for (var i = 0; i !== 8; i++) {\n        var corner = corners[i];\n        frame.pointToLocal(corner, corner);\n      }\n      return target.setFromPoints(corners);\n    }\n    /**\n     * Get the representation of an AABB in the global frame.\n     * @return The \"target\" AABB object.\n     */\n  }, {\n    key: \"toWorldFrame\",\n    value: function toWorldFrame(frame, target) {\n      var corners = transformIntoFrame_corners$1;\n      var a = corners[0];\n      var b = corners[1];\n      var c = corners[2];\n      var d = corners[3];\n      var e = corners[4];\n      var f = corners[5];\n      var g = corners[6];\n      var h = corners[7]; // Get corners in current frame\n\n      this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame\n\n      for (var i = 0; i !== 8; i++) {\n        var corner = corners[i];\n        frame.pointToWorld(corner, corner);\n      }\n      return target.setFromPoints(corners);\n    }\n    /**\n     * Check if the AABB is hit by a ray.\n     */\n  }, {\n    key: \"overlapsRay\",\n    value: function overlapsRay(ray) {\n      var direction = ray.direction,\n        from = ray.from; // const t = 0\n      // ray.direction is unit direction vector of ray\n\n      var dirFracX = 1 / direction.x;\n      var dirFracY = 1 / direction.y;\n      var dirFracZ = 1 / direction.z; // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner\n\n      var t1 = (this.lowerBound.x - from.x) * dirFracX;\n      var t2 = (this.upperBound.x - from.x) * dirFracX;\n      var t3 = (this.lowerBound.y - from.y) * dirFracY;\n      var t4 = (this.upperBound.y - from.y) * dirFracY;\n      var t5 = (this.lowerBound.z - from.z) * dirFracZ;\n      var t6 = (this.upperBound.z - from.z) * dirFracZ; // const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));\n      // const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));\n\n      var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));\n      var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6)); // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us\n\n      if (tmax < 0) {\n        //t = tmax;\n        return false;\n      } // if tmin > tmax, ray doesn't intersect AABB\n\n      if (tmin > tmax) {\n        //t = tmax;\n        return false;\n      }\n      return true;\n    }\n  }]);\n  return AABB$1;\n}();\nvar tmp$1$1 = new Vec3$1();\nvar transformIntoFrame_corners$1 = [new Vec3$1(), new Vec3$1(), new Vec3$1(), new Vec3$1(), new Vec3$1(), new Vec3$1(), new Vec3$1(), new Vec3$1()];\n\n/**\n * Base class for objects that dispatches events.\n */\nvar EventTarget = /*#__PURE__*/function () {\n  function EventTarget() {\n    _classCallCheck(this, EventTarget);\n  }\n  _createClass(EventTarget, [{\n    key: \"addEventListener\",\n    value:\n    /**\n     * Add an event listener\n     * @return The self object, for chainability.\n     */\n    function addEventListener(type, listener) {\n      if (this._listeners === undefined) {\n        this._listeners = {};\n      }\n      var listeners = this._listeners;\n      if (listeners[type] === undefined) {\n        listeners[type] = [];\n      }\n      if (!listeners[type].includes(listener)) {\n        listeners[type].push(listener);\n      }\n      return this;\n    }\n    /**\n     * Check if an event listener is added\n     */\n  }, {\n    key: \"hasEventListener\",\n    value: function hasEventListener(type, listener) {\n      if (this._listeners === undefined) {\n        return false;\n      }\n      var listeners = this._listeners;\n      if (listeners[type] !== undefined && listeners[type].includes(listener)) {\n        return true;\n      }\n      return false;\n    }\n    /**\n     * Check if any event listener of the given type is added\n     */\n  }, {\n    key: \"hasAnyEventListener\",\n    value: function hasAnyEventListener(type) {\n      if (this._listeners === undefined) {\n        return false;\n      }\n      var listeners = this._listeners;\n      return listeners[type] !== undefined;\n    }\n    /**\n     * Remove an event listener\n     * @return The self object, for chainability.\n     */\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, listener) {\n      if (this._listeners === undefined) {\n        return this;\n      }\n      var listeners = this._listeners;\n      if (listeners[type] === undefined) {\n        return this;\n      }\n      var index = listeners[type].indexOf(listener);\n      if (index !== -1) {\n        listeners[type].splice(index, 1);\n      }\n      return this;\n    }\n    /**\n     * Emit an event.\n     * @return The self object, for chainability.\n     */\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      if (this._listeners === undefined) {\n        return this;\n      }\n      var listeners = this._listeners;\n      var listenerArray = listeners[event.type];\n      if (listenerArray !== undefined) {\n        event.target = this;\n        for (var i = 0, l = listenerArray.length; i < l; i++) {\n          listenerArray[i].call(this, event);\n        }\n      }\n      return this;\n    }\n  }]);\n  return EventTarget;\n}();\n/**\n * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.\n * @param x Multiplier of the imaginary basis vector i.\n * @param y Multiplier of the imaginary basis vector j.\n * @param z Multiplier of the imaginary basis vector k.\n * @param w Multiplier of the real part.\n * @see http://en.wikipedia.org/wiki/Quaternion\n */\nvar Quaternion$1 = /*#__PURE__*/function () {\n  function Quaternion$1(x, y, z, w) {\n    _classCallCheck(this, Quaternion$1);\n    if (x === void 0) {\n      x = 0;\n    }\n    if (y === void 0) {\n      y = 0;\n    }\n    if (z === void 0) {\n      z = 0;\n    }\n    if (w === void 0) {\n      w = 1;\n    }\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n  /**\n   * Set the value of the quaternion.\n   */\n  _createClass(Quaternion$1, [{\n    key: \"set\",\n    value: function set(x, y, z, w) {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n      return this;\n    }\n    /**\n     * Convert to a readable format\n     * @return \"x,y,z,w\"\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.x, \",\").concat(this.y, \",\").concat(this.z, \",\").concat(this.w);\n    }\n    /**\n     * Convert to an Array\n     * @return [x, y, z, w]\n     */\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return [this.x, this.y, this.z, this.w];\n    }\n    /**\n     * Set the quaternion components given an axis and an angle in radians.\n     */\n  }, {\n    key: \"setFromAxisAngle\",\n    value: function setFromAxisAngle(vector, angle) {\n      var s = Math.sin(angle * 0.5);\n      this.x = vector.x * s;\n      this.y = vector.y * s;\n      this.z = vector.z * s;\n      this.w = Math.cos(angle * 0.5);\n      return this;\n    }\n    /**\n     * Converts the quaternion to [ axis, angle ] representation.\n     * @param targetAxis A vector object to reuse for storing the axis.\n     * @return An array, first element is the axis and the second is the angle in radians.\n     */\n  }, {\n    key: \"toAxisAngle\",\n    value: function toAxisAngle(targetAxis) {\n      if (targetAxis === void 0) {\n        targetAxis = new Vec3$1();\n      }\n      this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised\n\n      var angle = 2 * Math.acos(this.w);\n      var s = Math.sqrt(1 - this.w * this.w); // assuming quaternion normalised then w is less than 1, so term always positive.\n\n      if (s < 0.001) {\n        // test to avoid divide by zero, s is always positive due to sqrt\n        // if s close to zero then direction of axis not important\n        targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;\n\n        targetAxis.y = this.y;\n        targetAxis.z = this.z;\n      } else {\n        targetAxis.x = this.x / s; // normalise axis\n\n        targetAxis.y = this.y / s;\n        targetAxis.z = this.z / s;\n      }\n      return [targetAxis, angle];\n    }\n    /**\n     * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.\n     */\n  }, {\n    key: \"setFromVectors\",\n    value: function setFromVectors(u, v) {\n      if (u.isAntiparallelTo(v)) {\n        var t1 = sfv_t1$1;\n        var t2 = sfv_t2$1;\n        u.tangents(t1, t2);\n        this.setFromAxisAngle(t1, Math.PI);\n      } else {\n        var _a = u.cross(v);\n        this.x = _a.x;\n        this.y = _a.y;\n        this.z = _a.z;\n        this.w = Math.sqrt(Math.pow(u.length(), 2) * Math.pow(v.length(), 2)) + u.dot(v);\n        this.normalize();\n      }\n      return this;\n    }\n    /**\n     * Multiply the quaternion with an other quaternion.\n     */\n  }, {\n    key: \"mult\",\n    value: function mult(quat, target) {\n      if (target === void 0) {\n        target = new Quaternion$1();\n      }\n      var ax = this.x;\n      var ay = this.y;\n      var az = this.z;\n      var aw = this.w;\n      var bx = quat.x;\n      var by = quat.y;\n      var bz = quat.z;\n      var bw = quat.w;\n      target.x = ax * bw + aw * bx + ay * bz - az * by;\n      target.y = ay * bw + aw * by + az * bx - ax * bz;\n      target.z = az * bw + aw * bz + ax * by - ay * bx;\n      target.w = aw * bw - ax * bx - ay * by - az * bz;\n      return target;\n    }\n    /**\n     * Get the inverse quaternion rotation.\n     */\n  }, {\n    key: \"inverse\",\n    value: function inverse(target) {\n      if (target === void 0) {\n        target = new Quaternion$1();\n      }\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      var w = this.w;\n      this.conjugate(target);\n      var inorm2 = 1 / (x * x + y * y + z * z + w * w);\n      target.x *= inorm2;\n      target.y *= inorm2;\n      target.z *= inorm2;\n      target.w *= inorm2;\n      return target;\n    }\n    /**\n     * Get the quaternion conjugate\n     */\n  }, {\n    key: \"conjugate\",\n    value: function conjugate(target) {\n      if (target === void 0) {\n        target = new Quaternion$1();\n      }\n      target.x = -this.x;\n      target.y = -this.y;\n      target.z = -this.z;\n      target.w = this.w;\n      return target;\n    }\n    /**\n     * Normalize the quaternion. Note that this changes the values of the quaternion.\n     */\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n      if (l === 0) {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n      } else {\n        l = 1 / l;\n        this.x *= l;\n        this.y *= l;\n        this.z *= l;\n        this.w *= l;\n      }\n      return this;\n    }\n    /**\n     * Approximation of quaternion normalization. Works best when quat is already almost-normalized.\n     * @author unphased, https://github.com/unphased\n     */\n  }, {\n    key: \"normalizeFast\",\n    value: function normalizeFast() {\n      var f = (3.0 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2.0;\n      if (f === 0) {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n      } else {\n        this.x *= f;\n        this.y *= f;\n        this.z *= f;\n        this.w *= f;\n      }\n      return this;\n    }\n    /**\n     * Multiply the quaternion by a vector\n     */\n  }, {\n    key: \"vmult\",\n    value: function vmult(v, target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      var x = v.x;\n      var y = v.y;\n      var z = v.z;\n      var qx = this.x;\n      var qy = this.y;\n      var qz = this.z;\n      var qw = this.w; // q*v\n\n      var ix = qw * x + qy * z - qz * y;\n      var iy = qw * y + qz * x - qx * z;\n      var iz = qw * z + qx * y - qy * x;\n      var iw = -qx * x - qy * y - qz * z;\n      target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n      target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n      target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n      return target;\n    }\n    /**\n     * Copies value of source to this quaternion.\n     * @return this\n     */\n  }, {\n    key: \"copy\",\n    value: function copy(quat) {\n      this.x = quat.x;\n      this.y = quat.y;\n      this.z = quat.z;\n      this.w = quat.w;\n      return this;\n    }\n    /**\n     * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm\n     * @param order Three-character string, defaults to \"YZX\"\n     */\n  }, {\n    key: \"toEuler\",\n    value: function toEuler(target, order) {\n      if (order === void 0) {\n        order = 'YZX';\n      }\n      var heading;\n      var attitude;\n      var bank;\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      var w = this.w;\n      switch (order) {\n        case 'YZX':\n          var test = x * y + z * w;\n          if (test > 0.499) {\n            // singularity at north pole\n            heading = 2 * Math.atan2(x, w);\n            attitude = Math.PI / 2;\n            bank = 0;\n          }\n          if (test < -0.499) {\n            // singularity at south pole\n            heading = -2 * Math.atan2(x, w);\n            attitude = -Math.PI / 2;\n            bank = 0;\n          }\n          if (heading === undefined) {\n            var sqx = x * x;\n            var sqy = y * y;\n            var sqz = z * z;\n            heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz); // Heading\n\n            attitude = Math.asin(2 * test); // attitude\n\n            bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz); // bank\n          }\n\n          break;\n        default:\n          throw new Error(\"Euler order \".concat(order, \" not supported yet.\"));\n      }\n      target.y = heading;\n      target.z = attitude;\n      target.x = bank;\n    }\n    /**\n     * Set the quaternion components given Euler angle representation.\n     *\n     * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.\n     *\n     * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference\n     */\n  }, {\n    key: \"setFromEuler\",\n    value: function setFromEuler(x, y, z, order) {\n      if (order === void 0) {\n        order = 'XYZ';\n      }\n      var c1 = Math.cos(x / 2);\n      var c2 = Math.cos(y / 2);\n      var c3 = Math.cos(z / 2);\n      var s1 = Math.sin(x / 2);\n      var s2 = Math.sin(y / 2);\n      var s3 = Math.sin(z / 2);\n      if (order === 'XYZ') {\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n      } else if (order === 'YXZ') {\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 - s1 * s2 * c3;\n        this.w = c1 * c2 * c3 + s1 * s2 * s3;\n      } else if (order === 'ZXY') {\n        this.x = s1 * c2 * c3 - c1 * s2 * s3;\n        this.y = c1 * s2 * c3 + s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n      } else if (order === 'ZYX') {\n        this.x = s1 * c2 * c3 - c1 * s2 * s3;\n        this.y = c1 * s2 * c3 + s1 * c2 * s3;\n        this.z = c1 * c2 * s3 - s1 * s2 * c3;\n        this.w = c1 * c2 * c3 + s1 * s2 * s3;\n      } else if (order === 'YZX') {\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 + s1 * c2 * s3;\n        this.z = c1 * c2 * s3 - s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n      } else if (order === 'XZY') {\n        this.x = s1 * c2 * c3 - c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 + s1 * s2 * s3;\n      }\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Quaternion$1(this.x, this.y, this.z, this.w);\n    }\n    /**\n     * Performs a spherical linear interpolation between two quat\n     *\n     * @param toQuat second operand\n     * @param t interpolation amount between the self quaternion and toQuat\n     * @param target A quaternion to store the result in. If not provided, a new one will be created.\n     * @returns {Quaternion} The \"target\" object\n     */\n  }, {\n    key: \"slerp\",\n    value: function slerp(toQuat, t, target) {\n      if (target === void 0) {\n        target = new Quaternion$1();\n      }\n      var ax = this.x;\n      var ay = this.y;\n      var az = this.z;\n      var aw = this.w;\n      var bx = toQuat.x;\n      var by = toQuat.y;\n      var bz = toQuat.z;\n      var bw = toQuat.w;\n      var omega;\n      var cosom;\n      var sinom;\n      var scale0;\n      var scale1; // calc cosine\n\n      cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n      if (cosom < 0.0) {\n        cosom = -cosom;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n      } // calculate coefficients\n\n      if (1.0 - cosom > 0.000001) {\n        // standard case (slerp)\n        omega = Math.acos(cosom);\n        sinom = Math.sin(omega);\n        scale0 = Math.sin((1.0 - t) * omega) / sinom;\n        scale1 = Math.sin(t * omega) / sinom;\n      } else {\n        // \"from\" and \"to\" quaternions are very close\n        //  ... so we can do a linear interpolation\n        scale0 = 1.0 - t;\n        scale1 = t;\n      } // calculate final values\n\n      target.x = scale0 * ax + scale1 * bx;\n      target.y = scale0 * ay + scale1 * by;\n      target.z = scale0 * az + scale1 * bz;\n      target.w = scale0 * aw + scale1 * bw;\n      return target;\n    }\n    /**\n     * Rotate an absolute orientation quaternion given an angular velocity and a time step.\n     */\n  }, {\n    key: \"integrate\",\n    value: function integrate(angularVelocity, dt, angularFactor, target) {\n      if (target === void 0) {\n        target = new Quaternion$1();\n      }\n      var ax = angularVelocity.x * angularFactor.x,\n        ay = angularVelocity.y * angularFactor.y,\n        az = angularVelocity.z * angularFactor.z,\n        bx = this.x,\n        by = this.y,\n        bz = this.z,\n        bw = this.w;\n      var half_dt = dt * 0.5;\n      target.x += half_dt * (ax * bw + ay * bz - az * by);\n      target.y += half_dt * (ay * bw + az * bx - ax * bz);\n      target.z += half_dt * (az * bw + ax * by - ay * bx);\n      target.w += half_dt * (-ax * bx - ay * by - az * bz);\n      return target;\n    }\n  }]);\n  return Quaternion$1;\n}();\nvar sfv_t1$1 = new Vec3$1();\nvar sfv_t2$1 = new Vec3$1();\n\n/**\n * The available shape types.\n */\nvar SHAPE_TYPES$1 = {\n  /** SPHERE */\n  SPHERE: 1,\n  /** PLANE */\n  PLANE: 2,\n  /** BOX */\n  BOX: 4,\n  /** COMPOUND */\n  COMPOUND: 8,\n  /** CONVEXPOLYHEDRON */\n  CONVEXPOLYHEDRON: 16,\n  /** HEIGHTFIELD */\n  HEIGHTFIELD: 32,\n  /** PARTICLE */\n  PARTICLE: 64,\n  /** CYLINDER */\n  CYLINDER: 128,\n  /** TRIMESH */\n  TRIMESH: 256\n};\n/**\n * ShapeType\n */\n\n/**\n * Base class for shapes\n */\nvar Shape$1 = /*#__PURE__*/function () {\n  /**\n   * Identifier of the Shape.\n   */\n\n  /**\n   * The type of this shape. Must be set to an int > 0 by subclasses.\n   */\n\n  /**\n   * The local bounding sphere radius of this shape.\n   */\n\n  /**\n   * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.\n   * @default true\n   */\n\n  /**\n   * @default 1\n   */\n\n  /**\n   * @default -1\n   */\n\n  /**\n   * Optional material of the shape that regulates contact properties.\n   */\n\n  /**\n   * The body to which the shape is added to.\n   */\n\n  /**\n   * All the Shape types.\n   */\n  function Shape$1(options) {\n    _classCallCheck(this, Shape$1);\n    if (options === void 0) {\n      options = {};\n    }\n    this.id = Shape$1.idCounter++;\n    this.type = options.type || 0;\n    this.boundingSphereRadius = 0;\n    this.collisionResponse = options.collisionResponse ? options.collisionResponse : true;\n    this.collisionFilterGroup = options.collisionFilterGroup !== undefined ? options.collisionFilterGroup : 1;\n    this.collisionFilterMask = options.collisionFilterMask !== undefined ? options.collisionFilterMask : -1;\n    this.material = options.material ? options.material : null;\n    this.body = null;\n  }\n  /**\n   * Computes the bounding sphere radius.\n   * The result is stored in the property `.boundingSphereRadius`\n   */\n  _createClass(Shape$1, [{\n    key: \"updateBoundingSphereRadius\",\n    value: function updateBoundingSphereRadius() {\n      throw \"computeBoundingSphereRadius() not implemented for shape type \".concat(this.type);\n    }\n    /**\n     * Get the volume of this shape\n     */\n  }, {\n    key: \"volume\",\n    value: function volume() {\n      throw \"volume() not implemented for shape type \".concat(this.type);\n    }\n    /**\n     * Calculates the inertia in the local frame for this shape.\n     * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia\n     */\n  }, {\n    key: \"calculateLocalInertia\",\n    value: function calculateLocalInertia(mass, target) {\n      throw \"calculateLocalInertia() not implemented for shape type \".concat(this.type);\n    }\n    /**\n     * @todo use abstract for these kind of methods\n     */\n  }, {\n    key: \"calculateWorldAABB\",\n    value: function calculateWorldAABB(pos, quat, min, max) {\n      throw \"calculateWorldAABB() not implemented for shape type \".concat(this.type);\n    }\n  }]);\n  return Shape$1;\n}();\nShape$1.idCounter = 0;\nShape$1.types = SHAPE_TYPES$1;\n\n/**\n * Transformation utilities.\n */\nvar Transform$1 = /*#__PURE__*/function () {\n  /**\n   * position\n   */\n\n  /**\n   * quaternion\n   */\n  function Transform$1(options) {\n    _classCallCheck(this, Transform$1);\n    if (options === void 0) {\n      options = {};\n    }\n    this.position = new Vec3$1();\n    this.quaternion = new Quaternion$1();\n    if (options.position) {\n      this.position.copy(options.position);\n    }\n    if (options.quaternion) {\n      this.quaternion.copy(options.quaternion);\n    }\n  }\n  /**\n   * Get a global point in local transform coordinates.\n   */\n  _createClass(Transform$1, [{\n    key: \"pointToLocal\",\n    value: function pointToLocal(worldPoint, result) {\n      return Transform$1.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);\n    }\n    /**\n     * Get a local point in global transform coordinates.\n     */\n  }, {\n    key: \"pointToWorld\",\n    value: function pointToWorld(localPoint, result) {\n      return Transform$1.pointToWorldFrame(this.position, this.quaternion, localPoint, result);\n    }\n    /**\n     * vectorToWorldFrame\n     */\n  }, {\n    key: \"vectorToWorldFrame\",\n    value: function vectorToWorldFrame(localVector, result) {\n      if (result === void 0) {\n        result = new Vec3$1();\n      }\n      this.quaternion.vmult(localVector, result);\n      return result;\n    }\n    /**\n     * pointToLocalFrame\n     */\n  }], [{\n    key: \"pointToLocalFrame\",\n    value: function pointToLocalFrame(position, quaternion, worldPoint, result) {\n      if (result === void 0) {\n        result = new Vec3$1();\n      }\n      worldPoint.vsub(position, result);\n      quaternion.conjugate(tmpQuat$1$1);\n      tmpQuat$1$1.vmult(result, result);\n      return result;\n    }\n    /**\n     * pointToWorldFrame\n     */\n  }, {\n    key: \"pointToWorldFrame\",\n    value: function pointToWorldFrame(position, quaternion, localPoint, result) {\n      if (result === void 0) {\n        result = new Vec3$1();\n      }\n      quaternion.vmult(localPoint, result);\n      result.vadd(position, result);\n      return result;\n    }\n    /**\n     * vectorToWorldFrame\n     */\n  }, {\n    key: \"vectorToWorldFrame\",\n    value: function vectorToWorldFrame(quaternion, localVector, result) {\n      if (result === void 0) {\n        result = new Vec3$1();\n      }\n      quaternion.vmult(localVector, result);\n      return result;\n    }\n    /**\n     * vectorToLocalFrame\n     */\n  }, {\n    key: \"vectorToLocalFrame\",\n    value: function vectorToLocalFrame(position, quaternion, worldVector, result) {\n      if (result === void 0) {\n        result = new Vec3$1();\n      }\n      quaternion.w *= -1;\n      quaternion.vmult(worldVector, result);\n      quaternion.w *= -1;\n      return result;\n    }\n  }]);\n  return Transform$1;\n}();\nvar tmpQuat$1$1 = new Quaternion$1();\n\n/**\n * A set of polygons describing a convex shape.\n *\n * The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained\n * in the same 3D plane), instead these should be merged into one polygon.\n *\n * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)\n * @author schteppe / https://github.com/schteppe\n * @see https://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/\n *\n * @todo Move the clipping functions to ContactGenerator?\n * @todo Automatically merge coplanar polygons in constructor.\n * @example\n *     const convexShape = new CANNON.ConvexPolyhedron({ vertices, faces })\n *     const convexBody = new CANNON.Body({ mass: 1, shape: convexShape })\n *     world.addBody(convexBody)\n */\nvar ConvexPolyhedron = /*#__PURE__*/function (_Shape$) {\n  _inherits(ConvexPolyhedron, _Shape$);\n  var _super2 = _createSuper(ConvexPolyhedron);\n  /** vertices */\n\n  /**\n   * Array of integer arrays, indicating which vertices each face consists of\n   */\n\n  /** faceNormals */\n\n  /** worldVertices */\n\n  /** worldVerticesNeedsUpdate */\n\n  /** worldFaceNormals */\n\n  /** worldFaceNormalsNeedsUpdate */\n\n  /**\n   * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.\n   */\n\n  /** uniqueEdges */\n\n  /**\n   * @param vertices An array of Vec3's\n   * @param faces Array of integer arrays, describing which vertices that is included in each face.\n   */\n  function ConvexPolyhedron(props) {\n    var _this3;\n    _classCallCheck(this, ConvexPolyhedron);\n    if (props === void 0) {\n      props = {};\n    }\n    var _props = props,\n      _props$vertices = _props.vertices,\n      vertices = _props$vertices === void 0 ? [] : _props$vertices,\n      _props$faces = _props.faces,\n      faces = _props$faces === void 0 ? [] : _props$faces,\n      _props$normals = _props.normals,\n      normals = _props$normals === void 0 ? [] : _props$normals,\n      axes = _props.axes,\n      boundingSphereRadius = _props.boundingSphereRadius;\n    _this3 = _super2.call(this, {\n      type: Shape$1.types.CONVEXPOLYHEDRON\n    });\n    _this3.vertices = vertices;\n    _this3.faces = faces;\n    _this3.faceNormals = normals;\n    if (_this3.faceNormals.length === 0) {\n      _this3.computeNormals();\n    }\n    if (!boundingSphereRadius) {\n      _this3.updateBoundingSphereRadius();\n    } else {\n      _this3.boundingSphereRadius = boundingSphereRadius;\n    }\n    _this3.worldVertices = []; // World transformed version of .vertices\n\n    _this3.worldVerticesNeedsUpdate = true;\n    _this3.worldFaceNormals = []; // World transformed version of .faceNormals\n\n    _this3.worldFaceNormalsNeedsUpdate = true;\n    _this3.uniqueAxes = axes ? axes.slice() : null;\n    _this3.uniqueEdges = [];\n    _this3.computeEdges();\n    return _this3;\n  }\n  /**\n   * Computes uniqueEdges\n   */\n  _createClass(ConvexPolyhedron, [{\n    key: \"computeEdges\",\n    value: function computeEdges() {\n      var faces = this.faces;\n      var vertices = this.vertices;\n      var edges = this.uniqueEdges;\n      edges.length = 0;\n      var edge = new Vec3$1();\n      for (var i = 0; i !== faces.length; i++) {\n        var face = faces[i];\n        var numVertices = face.length;\n        for (var j = 0; j !== numVertices; j++) {\n          var k = (j + 1) % numVertices;\n          vertices[face[j]].vsub(vertices[face[k]], edge);\n          edge.normalize();\n          var found = false;\n          for (var p = 0; p !== edges.length; p++) {\n            if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            edges.push(edge.clone());\n          }\n        }\n      }\n    }\n    /**\n     * Compute the normals of the faces.\n     * Will reuse existing Vec3 objects in the `faceNormals` array if they exist.\n     */\n  }, {\n    key: \"computeNormals\",\n    value: function computeNormals() {\n      this.faceNormals.length = this.faces.length; // Generate normals\n\n      for (var i = 0; i < this.faces.length; i++) {\n        // Check so all vertices exists for this face\n        for (var j = 0; j < this.faces[i].length; j++) {\n          if (!this.vertices[this.faces[i][j]]) {\n            throw new Error(\"Vertex \".concat(this.faces[i][j], \" not found!\"));\n          }\n        }\n        var n = this.faceNormals[i] || new Vec3$1();\n        this.getFaceNormal(i, n);\n        n.negate(n);\n        this.faceNormals[i] = n;\n        var vertex = this.vertices[this.faces[i][0]];\n        if (n.dot(vertex) < 0) {\n          console.error(\".faceNormals[\".concat(i, \"] = Vec3(\").concat(n.toString(), \") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.\"));\n          for (var _j = 0; _j < this.faces[i].length; _j++) {\n            console.warn(\".vertices[\".concat(this.faces[i][_j], \"] = Vec3(\").concat(this.vertices[this.faces[i][_j]].toString(), \")\"));\n          }\n        }\n      }\n    }\n    /**\n     * Compute the normal of a face from its vertices\n     */\n  }, {\n    key: \"getFaceNormal\",\n    value: function getFaceNormal(i, target) {\n      var f = this.faces[i];\n      var va = this.vertices[f[0]];\n      var vb = this.vertices[f[1]];\n      var vc = this.vertices[f[2]];\n      ConvexPolyhedron.computeNormal(va, vb, vc, target);\n    }\n    /**\n     * Get face normal given 3 vertices\n     */\n  }, {\n    key: \"clipAgainstHull\",\n    value:\n    /**\n     * @param minDist Clamp distance\n     * @param result The an array of contact point objects, see clipFaceAgainstHull\n     */\n\n    function clipAgainstHull(posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result) {\n      var WorldNormal = new Vec3$1();\n      var closestFaceB = -1;\n      var dmax = -Number.MAX_VALUE;\n      for (var face = 0; face < hullB.faces.length; face++) {\n        WorldNormal.copy(hullB.faceNormals[face]);\n        quatB.vmult(WorldNormal, WorldNormal);\n        var d = WorldNormal.dot(separatingNormal);\n        if (d > dmax) {\n          dmax = d;\n          closestFaceB = face;\n        }\n      }\n      var worldVertsB1 = [];\n      for (var i = 0; i < hullB.faces[closestFaceB].length; i++) {\n        var _b = hullB.vertices[hullB.faces[closestFaceB][i]];\n        var worldb = new Vec3$1();\n        worldb.copy(_b);\n        quatB.vmult(worldb, worldb);\n        posB.vadd(worldb, worldb);\n        worldVertsB1.push(worldb);\n      }\n      if (closestFaceB >= 0) {\n        this.clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result);\n      }\n    }\n    /**\n     * Find the separating axis between this hull and another\n     * @param target The target vector to save the axis in\n     * @return Returns false if a separation is found, else true\n     */\n  }, {\n    key: \"findSeparatingAxis\",\n    value: function findSeparatingAxis(hullB, posA, quatA, posB, quatB, target, faceListA, faceListB) {\n      var faceANormalWS3 = new Vec3$1();\n      var Worldnormal1 = new Vec3$1();\n      var deltaC = new Vec3$1();\n      var worldEdge0 = new Vec3$1();\n      var worldEdge1 = new Vec3$1();\n      var Cross = new Vec3$1();\n      var dmin = Number.MAX_VALUE;\n      var hullA = this;\n      if (!hullA.uniqueAxes) {\n        var numFacesA = faceListA ? faceListA.length : hullA.faces.length; // Test face normals from hullA\n\n        for (var i = 0; i < numFacesA; i++) {\n          var fi = faceListA ? faceListA[i] : i; // Get world face normal\n\n          faceANormalWS3.copy(hullA.faceNormals[fi]);\n          quatA.vmult(faceANormalWS3, faceANormalWS3);\n          var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);\n          if (d === false) {\n            return false;\n          }\n          if (d < dmin) {\n            dmin = d;\n            target.copy(faceANormalWS3);\n          }\n        }\n      } else {\n        // Test unique axes\n        for (var _i = 0; _i !== hullA.uniqueAxes.length; _i++) {\n          // Get world axis\n          quatA.vmult(hullA.uniqueAxes[_i], faceANormalWS3);\n          var _d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);\n          if (_d === false) {\n            return false;\n          }\n          if (_d < dmin) {\n            dmin = _d;\n            target.copy(faceANormalWS3);\n          }\n        }\n      }\n      if (!hullB.uniqueAxes) {\n        // Test face normals from hullB\n        var numFacesB = faceListB ? faceListB.length : hullB.faces.length;\n        for (var _i2 = 0; _i2 < numFacesB; _i2++) {\n          var _fi = faceListB ? faceListB[_i2] : _i2;\n          Worldnormal1.copy(hullB.faceNormals[_fi]);\n          quatB.vmult(Worldnormal1, Worldnormal1);\n          var _d2 = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);\n          if (_d2 === false) {\n            return false;\n          }\n          if (_d2 < dmin) {\n            dmin = _d2;\n            target.copy(Worldnormal1);\n          }\n        }\n      } else {\n        // Test unique axes in B\n        for (var _i3 = 0; _i3 !== hullB.uniqueAxes.length; _i3++) {\n          quatB.vmult(hullB.uniqueAxes[_i3], Worldnormal1);\n          var _d3 = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);\n          if (_d3 === false) {\n            return false;\n          }\n          if (_d3 < dmin) {\n            dmin = _d3;\n            target.copy(Worldnormal1);\n          }\n        }\n      } // Test edges\n\n      for (var e0 = 0; e0 !== hullA.uniqueEdges.length; e0++) {\n        // Get world edge\n        quatA.vmult(hullA.uniqueEdges[e0], worldEdge0);\n        for (var e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) {\n          // Get world edge 2\n          quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);\n          worldEdge0.cross(worldEdge1, Cross);\n          if (!Cross.almostZero()) {\n            Cross.normalize();\n            var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);\n            if (dist === false) {\n              return false;\n            }\n            if (dist < dmin) {\n              dmin = dist;\n              target.copy(Cross);\n            }\n          }\n        }\n      }\n      posB.vsub(posA, deltaC);\n      if (deltaC.dot(target) > 0.0) {\n        target.negate(target);\n      }\n      return true;\n    }\n    /**\n     * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.\n     * @return The overlap depth, or FALSE if no penetration.\n     */\n  }, {\n    key: \"testSepAxis\",\n    value: function testSepAxis(axis, hullB, posA, quatA, posB, quatB) {\n      var hullA = this;\n      ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);\n      ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);\n      var maxA = maxminA[0];\n      var minA = maxminA[1];\n      var maxB = maxminB[0];\n      var minB = maxminB[1];\n      if (maxA < minB || maxB < minA) {\n        return false; // Separated\n      }\n\n      var d0 = maxA - minB;\n      var d1 = maxB - minA;\n      var depth = d0 < d1 ? d0 : d1;\n      return depth;\n    }\n    /**\n     * calculateLocalInertia\n     */\n  }, {\n    key: \"calculateLocalInertia\",\n    value: function calculateLocalInertia(mass, target) {\n      // Approximate with box inertia\n      // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it\n      var aabbmax = new Vec3$1();\n      var aabbmin = new Vec3$1();\n      this.computeLocalAABB(aabbmin, aabbmax);\n      var x = aabbmax.x - aabbmin.x;\n      var y = aabbmax.y - aabbmin.y;\n      var z = aabbmax.z - aabbmin.z;\n      target.x = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z);\n      target.y = 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z);\n      target.z = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x);\n    }\n    /**\n     * @param face_i Index of the face\n     */\n  }, {\n    key: \"getPlaneConstantOfFace\",\n    value: function getPlaneConstantOfFace(face_i) {\n      var f = this.faces[face_i];\n      var n = this.faceNormals[face_i];\n      var v = this.vertices[f[0]];\n      var c = -n.dot(v);\n      return c;\n    }\n    /**\n     * Clip a face against a hull.\n     * @param worldVertsB1 An array of Vec3 with vertices in the world frame.\n     * @param minDist Distance clamping\n     * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.\n     */\n  }, {\n    key: \"clipFaceAgainstHull\",\n    value: function clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result) {\n      var faceANormalWS = new Vec3$1();\n      var edge0 = new Vec3$1();\n      var WorldEdge0 = new Vec3$1();\n      var worldPlaneAnormal1 = new Vec3$1();\n      var planeNormalWS1 = new Vec3$1();\n      var worldA1 = new Vec3$1();\n      var localPlaneNormal = new Vec3$1();\n      var planeNormalWS = new Vec3$1();\n      var hullA = this;\n      var worldVertsB2 = [];\n      var pVtxIn = worldVertsB1;\n      var pVtxOut = worldVertsB2;\n      var closestFaceA = -1;\n      var dmin = Number.MAX_VALUE; // Find the face with normal closest to the separating axis\n\n      for (var face = 0; face < hullA.faces.length; face++) {\n        faceANormalWS.copy(hullA.faceNormals[face]);\n        quatA.vmult(faceANormalWS, faceANormalWS);\n        var d = faceANormalWS.dot(separatingNormal);\n        if (d < dmin) {\n          dmin = d;\n          closestFaceA = face;\n        }\n      }\n      if (closestFaceA < 0) {\n        return;\n      } // Get the face and construct connected faces\n\n      var polyA = hullA.faces[closestFaceA];\n      polyA.connectedFaces = [];\n      for (var i = 0; i < hullA.faces.length; i++) {\n        for (var j = 0; j < hullA.faces[i].length; j++) {\n          if ( /* Sharing a vertex*/\n          polyA.indexOf(hullA.faces[i][j]) !== -1 && /* Not the one we are looking for connections from */\n          i !== closestFaceA && /* Not already added */\n          polyA.connectedFaces.indexOf(i) === -1) {\n            polyA.connectedFaces.push(i);\n          }\n        }\n      } // Clip the polygon to the back of the planes of all faces of hull A,\n      // that are adjacent to the witness face\n\n      var numVerticesA = polyA.length;\n      for (var _i4 = 0; _i4 < numVerticesA; _i4++) {\n        var _a2 = hullA.vertices[polyA[_i4]];\n        var _b2 = hullA.vertices[polyA[(_i4 + 1) % numVerticesA]];\n        _a2.vsub(_b2, edge0);\n        WorldEdge0.copy(edge0);\n        quatA.vmult(WorldEdge0, WorldEdge0);\n        posA.vadd(WorldEdge0, WorldEdge0);\n        worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);\n        quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1);\n        posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1);\n        WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1);\n        planeNormalWS1.negate(planeNormalWS1);\n        worldA1.copy(_a2);\n        quatA.vmult(worldA1, worldA1);\n        posA.vadd(worldA1, worldA1);\n        var otherFace = polyA.connectedFaces[_i4];\n        localPlaneNormal.copy(this.faceNormals[otherFace]);\n        var _localPlaneEq = this.getPlaneConstantOfFace(otherFace);\n        planeNormalWS.copy(localPlaneNormal);\n        quatA.vmult(planeNormalWS, planeNormalWS);\n        var _planeEqWS = _localPlaneEq - planeNormalWS.dot(posA); // Clip face against our constructed plane\n\n        this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, _planeEqWS); // Throw away all clipped points, but save the remaining until next clip\n\n        while (pVtxIn.length) {\n          pVtxIn.shift();\n        }\n        while (pVtxOut.length) {\n          pVtxIn.push(pVtxOut.shift());\n        }\n      } // only keep contact points that are behind the witness face\n\n      localPlaneNormal.copy(this.faceNormals[closestFaceA]);\n      var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);\n      planeNormalWS.copy(localPlaneNormal);\n      quatA.vmult(planeNormalWS, planeNormalWS);\n      var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);\n      for (var _i5 = 0; _i5 < pVtxIn.length; _i5++) {\n        var depth = planeNormalWS.dot(pVtxIn[_i5]) + planeEqWS; // ???\n\n        if (depth <= minDist) {\n          console.log(\"clamped: depth=\".concat(depth, \" to minDist=\").concat(minDist));\n          depth = minDist;\n        }\n        if (depth <= maxDist) {\n          var point = pVtxIn[_i5];\n          if (depth <= 1e-6) {\n            var p = {\n              point: point,\n              normal: planeNormalWS,\n              depth: depth\n            };\n            result.push(p);\n          }\n        }\n      }\n    }\n    /**\n     * Clip a face in a hull against the back of a plane.\n     * @param planeConstant The constant in the mathematical plane equation\n     */\n  }, {\n    key: \"clipFaceAgainstPlane\",\n    value: function clipFaceAgainstPlane(inVertices, outVertices, planeNormal, planeConstant) {\n      var n_dot_first;\n      var n_dot_last;\n      var numVerts = inVertices.length;\n      if (numVerts < 2) {\n        return outVertices;\n      }\n      var firstVertex = inVertices[inVertices.length - 1];\n      var lastVertex = inVertices[0];\n      n_dot_first = planeNormal.dot(firstVertex) + planeConstant;\n      for (var vi = 0; vi < numVerts; vi++) {\n        lastVertex = inVertices[vi];\n        n_dot_last = planeNormal.dot(lastVertex) + planeConstant;\n        if (n_dot_first < 0) {\n          if (n_dot_last < 0) {\n            // Start < 0, end < 0, so output lastVertex\n            var newv = new Vec3$1();\n            newv.copy(lastVertex);\n            outVertices.push(newv);\n          } else {\n            // Start < 0, end >= 0, so output intersection\n            var _newv = new Vec3$1();\n            firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), _newv);\n            outVertices.push(_newv);\n          }\n        } else {\n          if (n_dot_last < 0) {\n            // Start >= 0, end < 0 so output intersection and end\n            var _newv2 = new Vec3$1();\n            firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), _newv2);\n            outVertices.push(_newv2);\n            outVertices.push(lastVertex);\n          }\n        }\n        firstVertex = lastVertex;\n        n_dot_first = n_dot_last;\n      }\n      return outVertices;\n    }\n    /**\n     * Updates `.worldVertices` and sets `.worldVerticesNeedsUpdate` to false.\n     */\n  }, {\n    key: \"computeWorldVertices\",\n    value: function computeWorldVertices(position, quat) {\n      while (this.worldVertices.length < this.vertices.length) {\n        this.worldVertices.push(new Vec3$1());\n      }\n      var verts = this.vertices;\n      var worldVerts = this.worldVertices;\n      for (var i = 0; i !== this.vertices.length; i++) {\n        quat.vmult(verts[i], worldVerts[i]);\n        position.vadd(worldVerts[i], worldVerts[i]);\n      }\n      this.worldVerticesNeedsUpdate = false;\n    }\n  }, {\n    key: \"computeLocalAABB\",\n    value: function computeLocalAABB(aabbmin, aabbmax) {\n      var vertices = this.vertices;\n      aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n      aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n      for (var i = 0; i < this.vertices.length; i++) {\n        var _v = vertices[i];\n        if (_v.x < aabbmin.x) {\n          aabbmin.x = _v.x;\n        } else if (_v.x > aabbmax.x) {\n          aabbmax.x = _v.x;\n        }\n        if (_v.y < aabbmin.y) {\n          aabbmin.y = _v.y;\n        } else if (_v.y > aabbmax.y) {\n          aabbmax.y = _v.y;\n        }\n        if (_v.z < aabbmin.z) {\n          aabbmin.z = _v.z;\n        } else if (_v.z > aabbmax.z) {\n          aabbmax.z = _v.z;\n        }\n      }\n    }\n    /**\n     * Updates `worldVertices` and sets `worldVerticesNeedsUpdate` to false.\n     */\n  }, {\n    key: \"computeWorldFaceNormals\",\n    value: function computeWorldFaceNormals(quat) {\n      var N = this.faceNormals.length;\n      while (this.worldFaceNormals.length < N) {\n        this.worldFaceNormals.push(new Vec3$1());\n      }\n      var normals = this.faceNormals;\n      var worldNormals = this.worldFaceNormals;\n      for (var i = 0; i !== N; i++) {\n        quat.vmult(normals[i], worldNormals[i]);\n      }\n      this.worldFaceNormalsNeedsUpdate = false;\n    }\n    /**\n     * updateBoundingSphereRadius\n     */\n  }, {\n    key: \"updateBoundingSphereRadius\",\n    value: function updateBoundingSphereRadius() {\n      // Assume points are distributed with local (0,0,0) as center\n      var max2 = 0;\n      var verts = this.vertices;\n      for (var i = 0; i !== verts.length; i++) {\n        var norm2 = verts[i].lengthSquared();\n        if (norm2 > max2) {\n          max2 = norm2;\n        }\n      }\n      this.boundingSphereRadius = Math.sqrt(max2);\n    }\n    /**\n     * calculateWorldAABB\n     */\n  }, {\n    key: \"calculateWorldAABB\",\n    value: function calculateWorldAABB(pos, quat, min, max) {\n      var verts = this.vertices;\n      var minx;\n      var miny;\n      var minz;\n      var maxx;\n      var maxy;\n      var maxz;\n      var tempWorldVertex = new Vec3$1();\n      for (var i = 0; i < verts.length; i++) {\n        tempWorldVertex.copy(verts[i]);\n        quat.vmult(tempWorldVertex, tempWorldVertex);\n        pos.vadd(tempWorldVertex, tempWorldVertex);\n        var _v2 = tempWorldVertex;\n        if (minx === undefined || _v2.x < minx) {\n          minx = _v2.x;\n        }\n        if (maxx === undefined || _v2.x > maxx) {\n          maxx = _v2.x;\n        }\n        if (miny === undefined || _v2.y < miny) {\n          miny = _v2.y;\n        }\n        if (maxy === undefined || _v2.y > maxy) {\n          maxy = _v2.y;\n        }\n        if (minz === undefined || _v2.z < minz) {\n          minz = _v2.z;\n        }\n        if (maxz === undefined || _v2.z > maxz) {\n          maxz = _v2.z;\n        }\n      }\n      min.set(minx, miny, minz);\n      max.set(maxx, maxy, maxz);\n    }\n    /**\n     * Get approximate convex volume\n     */\n  }, {\n    key: \"volume\",\n    value: function volume() {\n      return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;\n    }\n    /**\n     * Get an average of all the vertices positions\n     */\n  }, {\n    key: \"getAveragePointLocal\",\n    value: function getAveragePointLocal(target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      var verts = this.vertices;\n      for (var i = 0; i < verts.length; i++) {\n        target.vadd(verts[i], target);\n      }\n      target.scale(1 / verts.length, target);\n      return target;\n    }\n    /**\n     * Transform all local points. Will change the .vertices\n     */\n  }, {\n    key: \"transformAllPoints\",\n    value: function transformAllPoints(offset, quat) {\n      var n = this.vertices.length;\n      var verts = this.vertices; // Apply rotation\n\n      if (quat) {\n        // Rotate vertices\n        for (var i = 0; i < n; i++) {\n          var _v3 = verts[i];\n          quat.vmult(_v3, _v3);\n        } // Rotate face normals\n\n        for (var _i6 = 0; _i6 < this.faceNormals.length; _i6++) {\n          var _v4 = this.faceNormals[_i6];\n          quat.vmult(_v4, _v4);\n        }\n        /*\n              // Rotate edges\n              for(let i=0; i<this.uniqueEdges.length; i++){\n                  const v = this.uniqueEdges[i];\n                  quat.vmult(v,v);\n              }*/\n      } // Apply offset\n\n      if (offset) {\n        for (var _i7 = 0; _i7 < n; _i7++) {\n          var _v5 = verts[_i7];\n          _v5.vadd(offset, _v5);\n        }\n      }\n    }\n    /**\n     * Checks whether p is inside the polyhedra. Must be in local coords.\n     * The point lies outside of the convex hull of the other points if and only if the direction\n     * of all the vectors from it to those other points are on less than one half of a sphere around it.\n     * @param p A point given in local coordinates\n     */\n  }, {\n    key: \"pointIsInside\",\n    value: function pointIsInside(p) {\n      var verts = this.vertices;\n      var faces = this.faces;\n      var normals = this.faceNormals;\n      var positiveResult = null;\n      var pointInside = new Vec3$1();\n      this.getAveragePointLocal(pointInside);\n      for (var i = 0; i < this.faces.length; i++) {\n        var n = normals[i];\n        var _v6 = verts[faces[i][0]]; // We only need one point in the face\n        // This dot product determines which side of the edge the point is\n\n        var vToP = new Vec3$1();\n        p.vsub(_v6, vToP);\n        var r1 = n.dot(vToP);\n        var vToPointInside = new Vec3$1();\n        pointInside.vsub(_v6, vToPointInside);\n        var r2 = n.dot(vToPointInside);\n        if (r1 < 0 && r2 > 0 || r1 > 0 && r2 < 0) {\n          return false; // Encountered some other sign. Exit.\n        }\n      } // If we got here, all dot products were of the same sign.\n\n      return positiveResult ? 1 : -1;\n    }\n    /**\n     * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis.\n     * Results are saved in the array maxmin.\n     * @param result result[0] and result[1] will be set to maximum and minimum, respectively.\n     */\n  }], [{\n    key: \"computeNormal\",\n    value: function computeNormal(va, vb, vc, target) {\n      var cb = new Vec3$1();\n      var ab = new Vec3$1();\n      vb.vsub(va, ab);\n      vc.vsub(vb, cb);\n      cb.cross(ab, target);\n      if (!target.isZero()) {\n        target.normalize();\n      }\n    }\n  }, {\n    key: \"project\",\n    value: function project(shape, axis, pos, quat, result) {\n      var n = shape.vertices.length;\n      var localAxis = project_localAxis;\n      var max = 0;\n      var min = 0;\n      var localOrigin = project_localOrigin;\n      var vs = shape.vertices;\n      localOrigin.setZero(); // Transform the axis to local\n\n      Transform$1.vectorToLocalFrame(pos, quat, axis, localAxis);\n      Transform$1.pointToLocalFrame(pos, quat, localOrigin, localOrigin);\n      var add = localOrigin.dot(localAxis);\n      min = max = vs[0].dot(localAxis);\n      for (var i = 1; i < n; i++) {\n        var val = vs[i].dot(localAxis);\n        if (val > max) {\n          max = val;\n        }\n        if (val < min) {\n          min = val;\n        }\n      }\n      min -= add;\n      max -= add;\n      if (min > max) {\n        // Inconsistent - swap\n        var _temp2 = min;\n        min = max;\n        max = _temp2;\n      } // Output\n\n      result[0] = max;\n      result[1] = min;\n    }\n  }]);\n  return ConvexPolyhedron;\n}(Shape$1);\nvar maxminA = [];\nvar maxminB = [];\nnew Vec3$1();\nvar project_localAxis = new Vec3$1();\nvar project_localOrigin = new Vec3$1();\n\n/**\n * A 3d box shape.\n * @example\n *     const size = 1\n *     const halfExtents = new CANNON.Vec3(size, size, size)\n *     const boxShape = new CANNON.Box(halfExtents)\n *     const boxBody = new CANNON.Body({ mass: 1, shape: boxShape })\n *     world.addBody(boxBody)\n */\nvar Box = /*#__PURE__*/function (_Shape$2) {\n  _inherits(Box, _Shape$2);\n  var _super3 = _createSuper(Box);\n  /**\n   * The half extents of the box.\n   */\n\n  /**\n   * Used by the contact generator to make contacts with other convex polyhedra for example.\n   */\n  function Box(halfExtents) {\n    var _this4;\n    _classCallCheck(this, Box);\n    _this4 = _super3.call(this, {\n      type: Shape$1.types.BOX\n    });\n    _this4.halfExtents = halfExtents;\n    _this4.convexPolyhedronRepresentation = null;\n    _this4.updateConvexPolyhedronRepresentation();\n    _this4.updateBoundingSphereRadius();\n    return _this4;\n  }\n  /**\n   * Updates the local convex polyhedron representation used for some collisions.\n   */\n  _createClass(Box, [{\n    key: \"updateConvexPolyhedronRepresentation\",\n    value: function updateConvexPolyhedronRepresentation() {\n      var sx = this.halfExtents.x;\n      var sy = this.halfExtents.y;\n      var sz = this.halfExtents.z;\n      var V = Vec3$1;\n      var vertices = [new V(-sx, -sy, -sz), new V(sx, -sy, -sz), new V(sx, sy, -sz), new V(-sx, sy, -sz), new V(-sx, -sy, sz), new V(sx, -sy, sz), new V(sx, sy, sz), new V(-sx, sy, sz)];\n      var faces = [[3, 2, 1, 0],\n      // -z\n      [4, 5, 6, 7],\n      // +z\n      [5, 4, 0, 1],\n      // -y\n      [2, 3, 7, 6],\n      // +y\n      [0, 4, 7, 3],\n      // -x\n      [1, 2, 6, 5] // +x\n      ];\n\n      var axes = [new V(0, 0, 1), new V(0, 1, 0), new V(1, 0, 0)];\n      var h = new ConvexPolyhedron({\n        vertices: vertices,\n        faces: faces,\n        axes: axes\n      });\n      this.convexPolyhedronRepresentation = h;\n      h.material = this.material;\n    }\n    /**\n     * Calculate the inertia of the box.\n     */\n  }, {\n    key: \"calculateLocalInertia\",\n    value: function calculateLocalInertia(mass, target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      Box.calculateInertia(this.halfExtents, mass, target);\n      return target;\n    }\n  }, {\n    key: \"getSideNormals\",\n    value:\n    /**\n     * Get the box 6 side normals\n     * @param sixTargetVectors An array of 6 vectors, to store the resulting side normals in.\n     * @param quat Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.\n     */\n\n    function getSideNormals(sixTargetVectors, quat) {\n      var sides = sixTargetVectors;\n      var ex = this.halfExtents;\n      sides[0].set(ex.x, 0, 0);\n      sides[1].set(0, ex.y, 0);\n      sides[2].set(0, 0, ex.z);\n      sides[3].set(-ex.x, 0, 0);\n      sides[4].set(0, -ex.y, 0);\n      sides[5].set(0, 0, -ex.z);\n      if (quat !== undefined) {\n        for (var i = 0; i !== sides.length; i++) {\n          quat.vmult(sides[i], sides[i]);\n        }\n      }\n      return sides;\n    }\n    /**\n     * Returns the volume of the box.\n     */\n  }, {\n    key: \"volume\",\n    value: function volume() {\n      return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;\n    }\n    /**\n     * updateBoundingSphereRadius\n     */\n  }, {\n    key: \"updateBoundingSphereRadius\",\n    value: function updateBoundingSphereRadius() {\n      this.boundingSphereRadius = this.halfExtents.length();\n    }\n    /**\n     * forEachWorldCorner\n     */\n  }, {\n    key: \"forEachWorldCorner\",\n    value: function forEachWorldCorner(pos, quat, callback) {\n      var e = this.halfExtents;\n      var corners = [[e.x, e.y, e.z], [-e.x, e.y, e.z], [-e.x, -e.y, e.z], [-e.x, -e.y, -e.z], [e.x, -e.y, -e.z], [e.x, e.y, -e.z], [-e.x, e.y, -e.z], [e.x, -e.y, e.z]];\n      for (var i = 0; i < corners.length; i++) {\n        worldCornerTempPos.set(corners[i][0], corners[i][1], corners[i][2]);\n        quat.vmult(worldCornerTempPos, worldCornerTempPos);\n        pos.vadd(worldCornerTempPos, worldCornerTempPos);\n        callback(worldCornerTempPos.x, worldCornerTempPos.y, worldCornerTempPos.z);\n      }\n    }\n    /**\n     * calculateWorldAABB\n     */\n  }, {\n    key: \"calculateWorldAABB\",\n    value: function calculateWorldAABB(pos, quat, min, max) {\n      var e = this.halfExtents;\n      worldCornersTemp[0].set(e.x, e.y, e.z);\n      worldCornersTemp[1].set(-e.x, e.y, e.z);\n      worldCornersTemp[2].set(-e.x, -e.y, e.z);\n      worldCornersTemp[3].set(-e.x, -e.y, -e.z);\n      worldCornersTemp[4].set(e.x, -e.y, -e.z);\n      worldCornersTemp[5].set(e.x, e.y, -e.z);\n      worldCornersTemp[6].set(-e.x, e.y, -e.z);\n      worldCornersTemp[7].set(e.x, -e.y, e.z);\n      var wc = worldCornersTemp[0];\n      quat.vmult(wc, wc);\n      pos.vadd(wc, wc);\n      max.copy(wc);\n      min.copy(wc);\n      for (var i = 1; i < 8; i++) {\n        var _wc = worldCornersTemp[i];\n        quat.vmult(_wc, _wc);\n        pos.vadd(_wc, _wc);\n        var x = _wc.x;\n        var y = _wc.y;\n        var z = _wc.z;\n        if (x > max.x) {\n          max.x = x;\n        }\n        if (y > max.y) {\n          max.y = y;\n        }\n        if (z > max.z) {\n          max.z = z;\n        }\n        if (x < min.x) {\n          min.x = x;\n        }\n        if (y < min.y) {\n          min.y = y;\n        }\n        if (z < min.z) {\n          min.z = z;\n        }\n      } // Get each axis max\n      // min.set(Infinity,Infinity,Infinity);\n      // max.set(-Infinity,-Infinity,-Infinity);\n      // this.forEachWorldCorner(pos,quat,function(x,y,z){\n      //     if(x > max.x){\n      //         max.x = x;\n      //     }\n      //     if(y > max.y){\n      //         max.y = y;\n      //     }\n      //     if(z > max.z){\n      //         max.z = z;\n      //     }\n      //     if(x < min.x){\n      //         min.x = x;\n      //     }\n      //     if(y < min.y){\n      //         min.y = y;\n      //     }\n      //     if(z < min.z){\n      //         min.z = z;\n      //     }\n      // });\n    }\n  }], [{\n    key: \"calculateInertia\",\n    value: function calculateInertia(halfExtents, mass, target) {\n      var e = halfExtents;\n      target.x = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z);\n      target.y = 1.0 / 12.0 * mass * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z);\n      target.z = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x);\n    }\n  }]);\n  return Box;\n}(Shape$1);\nvar worldCornerTempPos = new Vec3$1();\nvar worldCornersTemp = [new Vec3$1(), new Vec3$1(), new Vec3$1(), new Vec3$1(), new Vec3$1(), new Vec3$1(), new Vec3$1(), new Vec3$1()];\n\n/**\n * BODY_TYPES\n */\nvar BODY_TYPES = {\n  /** DYNAMIC */\n  DYNAMIC: 1,\n  /** STATIC */\n  STATIC: 2,\n  /** KINEMATIC */\n  KINEMATIC: 4\n};\n/**\n * BodyType\n */\n\n/**\n * BODY_SLEEP_STATES\n */\nvar BODY_SLEEP_STATES = {\n  /** AWAKE */\n  AWAKE: 0,\n  /** SLEEPY */\n  SLEEPY: 1,\n  /** SLEEPING */\n  SLEEPING: 2\n};\n/**\n * BodySleepState\n */\n\n/**\n * Base class for all body types.\n * @example\n *     const shape = new CANNON.Sphere(1)\n *     const body = new CANNON.Body({\n *       mass: 1,\n *       shape,\n *     })\n *     world.addBody(body)\n */\nvar Body = /*#__PURE__*/function (_EventTarget) {\n  _inherits(Body, _EventTarget);\n  var _super4 = _createSuper(Body);\n  /**\n   * Dispatched after two bodies collide. This event is dispatched on each\n   * of the two bodies involved in the collision.\n   * @event collide\n   * @param body The body that was involved in the collision.\n   * @param contact The details of the collision.\n   */\n\n  /**\n   * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.\n   */\n\n  /**\n   * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.\n   */\n\n  /**\n   * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.\n   */\n\n  /**\n   * AWAKE\n   */\n\n  /**\n   * SLEEPY\n   */\n\n  /**\n   * SLEEPING\n   */\n\n  /**\n   * Dispatched after a sleeping body has woken up.\n   * @event wakeup\n   */\n\n  /**\n   * Dispatched after a body has gone in to the sleepy state.\n   * @event sleepy\n   */\n\n  /**\n   * Dispatched after a body has fallen asleep.\n   * @event sleep\n   */\n  function Body(options) {\n    var _this5;\n    _classCallCheck(this, Body);\n    if (options === void 0) {\n      options = {};\n    }\n    _this5 = _super4.call(this);\n    _this5.id = Body.idCounter++;\n    _this5.index = -1;\n    _this5.world = null;\n    _this5.vlambda = new Vec3$1();\n    _this5.collisionFilterGroup = typeof options.collisionFilterGroup === 'number' ? options.collisionFilterGroup : 1;\n    _this5.collisionFilterMask = typeof options.collisionFilterMask === 'number' ? options.collisionFilterMask : -1;\n    _this5.collisionResponse = typeof options.collisionResponse === 'boolean' ? options.collisionResponse : true;\n    _this5.position = new Vec3$1();\n    _this5.previousPosition = new Vec3$1();\n    _this5.interpolatedPosition = new Vec3$1();\n    _this5.initPosition = new Vec3$1();\n    if (options.position) {\n      _this5.position.copy(options.position);\n      _this5.previousPosition.copy(options.position);\n      _this5.interpolatedPosition.copy(options.position);\n      _this5.initPosition.copy(options.position);\n    }\n    _this5.velocity = new Vec3$1();\n    if (options.velocity) {\n      _this5.velocity.copy(options.velocity);\n    }\n    _this5.initVelocity = new Vec3$1();\n    _this5.force = new Vec3$1();\n    var mass = typeof options.mass === 'number' ? options.mass : 0;\n    _this5.mass = mass;\n    _this5.invMass = mass > 0 ? 1.0 / mass : 0;\n    _this5.material = options.material || null;\n    _this5.linearDamping = typeof options.linearDamping === 'number' ? options.linearDamping : 0.01;\n    _this5.type = mass <= 0.0 ? Body.STATIC : Body.DYNAMIC;\n    if (typeof options.type === typeof Body.STATIC) {\n      _this5.type = options.type;\n    }\n    _this5.allowSleep = typeof options.allowSleep !== 'undefined' ? options.allowSleep : true;\n    _this5.sleepState = Body.AWAKE;\n    _this5.sleepSpeedLimit = typeof options.sleepSpeedLimit !== 'undefined' ? options.sleepSpeedLimit : 0.1;\n    _this5.sleepTimeLimit = typeof options.sleepTimeLimit !== 'undefined' ? options.sleepTimeLimit : 1;\n    _this5.timeLastSleepy = 0;\n    _this5.wakeUpAfterNarrowphase = false;\n    _this5.torque = new Vec3$1();\n    _this5.quaternion = new Quaternion$1();\n    _this5.initQuaternion = new Quaternion$1();\n    _this5.previousQuaternion = new Quaternion$1();\n    _this5.interpolatedQuaternion = new Quaternion$1();\n    if (options.quaternion) {\n      _this5.quaternion.copy(options.quaternion);\n      _this5.initQuaternion.copy(options.quaternion);\n      _this5.previousQuaternion.copy(options.quaternion);\n      _this5.interpolatedQuaternion.copy(options.quaternion);\n    }\n    _this5.angularVelocity = new Vec3$1();\n    if (options.angularVelocity) {\n      _this5.angularVelocity.copy(options.angularVelocity);\n    }\n    _this5.initAngularVelocity = new Vec3$1();\n    _this5.shapes = [];\n    _this5.shapeOffsets = [];\n    _this5.shapeOrientations = [];\n    _this5.inertia = new Vec3$1();\n    _this5.invInertia = new Vec3$1();\n    _this5.invInertiaWorld = new Mat3$1();\n    _this5.invMassSolve = 0;\n    _this5.invInertiaSolve = new Vec3$1();\n    _this5.invInertiaWorldSolve = new Mat3$1();\n    _this5.fixedRotation = typeof options.fixedRotation !== 'undefined' ? options.fixedRotation : false;\n    _this5.angularDamping = typeof options.angularDamping !== 'undefined' ? options.angularDamping : 0.01;\n    _this5.linearFactor = new Vec3$1(1, 1, 1);\n    if (options.linearFactor) {\n      _this5.linearFactor.copy(options.linearFactor);\n    }\n    _this5.angularFactor = new Vec3$1(1, 1, 1);\n    if (options.angularFactor) {\n      _this5.angularFactor.copy(options.angularFactor);\n    }\n    _this5.aabb = new AABB$1();\n    _this5.aabbNeedsUpdate = true;\n    _this5.boundingRadius = 0;\n    _this5.wlambda = new Vec3$1();\n    _this5.isTrigger = Boolean(options.isTrigger);\n    if (options.shape) {\n      _this5.addShape(options.shape);\n    }\n    _this5.updateMassProperties();\n    return _this5;\n  }\n  /**\n   * Wake the body up.\n   */\n  _createClass(Body, [{\n    key: \"wakeUp\",\n    value: function wakeUp() {\n      var prevState = this.sleepState;\n      this.sleepState = Body.AWAKE;\n      this.wakeUpAfterNarrowphase = false;\n      if (prevState === Body.SLEEPING) {\n        this.dispatchEvent(Body.wakeupEvent);\n      }\n    }\n    /**\n     * Force body sleep\n     */\n  }, {\n    key: \"sleep\",\n    value: function sleep() {\n      this.sleepState = Body.SLEEPING;\n      this.velocity.set(0, 0, 0);\n      this.angularVelocity.set(0, 0, 0);\n      this.wakeUpAfterNarrowphase = false;\n    }\n    /**\n     * Called every timestep to update internal sleep timer and change sleep state if needed.\n     * @param time The world time in seconds\n     */\n  }, {\n    key: \"sleepTick\",\n    value: function sleepTick(time) {\n      if (this.allowSleep) {\n        var sleepState = this.sleepState;\n        var speedSquared = this.velocity.lengthSquared() + this.angularVelocity.lengthSquared();\n        var speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);\n        if (sleepState === Body.AWAKE && speedSquared < speedLimitSquared) {\n          this.sleepState = Body.SLEEPY; // Sleepy\n\n          this.timeLastSleepy = time;\n          this.dispatchEvent(Body.sleepyEvent);\n        } else if (sleepState === Body.SLEEPY && speedSquared > speedLimitSquared) {\n          this.wakeUp(); // Wake up\n        } else if (sleepState === Body.SLEEPY && time - this.timeLastSleepy > this.sleepTimeLimit) {\n          this.sleep(); // Sleeping\n\n          this.dispatchEvent(Body.sleepEvent);\n        }\n      }\n    }\n    /**\n     * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate \"solve mass\".\n     */\n  }, {\n    key: \"updateSolveMassProperties\",\n    value: function updateSolveMassProperties() {\n      if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {\n        this.invMassSolve = 0;\n        this.invInertiaSolve.setZero();\n        this.invInertiaWorldSolve.setZero();\n      } else {\n        this.invMassSolve = this.invMass;\n        this.invInertiaSolve.copy(this.invInertia);\n        this.invInertiaWorldSolve.copy(this.invInertiaWorld);\n      }\n    }\n    /**\n     * Convert a world point to local body frame.\n     */\n  }, {\n    key: \"pointToLocalFrame\",\n    value: function pointToLocalFrame(worldPoint, result) {\n      if (result === void 0) {\n        result = new Vec3$1();\n      }\n      worldPoint.vsub(this.position, result);\n      this.quaternion.conjugate().vmult(result, result);\n      return result;\n    }\n    /**\n     * Convert a world vector to local body frame.\n     */\n  }, {\n    key: \"vectorToLocalFrame\",\n    value: function vectorToLocalFrame(worldVector, result) {\n      if (result === void 0) {\n        result = new Vec3$1();\n      }\n      this.quaternion.conjugate().vmult(worldVector, result);\n      return result;\n    }\n    /**\n     * Convert a local body point to world frame.\n     */\n  }, {\n    key: \"pointToWorldFrame\",\n    value: function pointToWorldFrame(localPoint, result) {\n      if (result === void 0) {\n        result = new Vec3$1();\n      }\n      this.quaternion.vmult(localPoint, result);\n      result.vadd(this.position, result);\n      return result;\n    }\n    /**\n     * Convert a local body point to world frame.\n     */\n  }, {\n    key: \"vectorToWorldFrame\",\n    value: function vectorToWorldFrame(localVector, result) {\n      if (result === void 0) {\n        result = new Vec3$1();\n      }\n      this.quaternion.vmult(localVector, result);\n      return result;\n    }\n    /**\n     * Add a shape to the body with a local offset and orientation.\n     * @return The body object, for chainability.\n     */\n  }, {\n    key: \"addShape\",\n    value: function addShape(shape, _offset, _orientation) {\n      var offset = new Vec3$1();\n      var orientation = new Quaternion$1();\n      if (_offset) {\n        offset.copy(_offset);\n      }\n      if (_orientation) {\n        orientation.copy(_orientation);\n      }\n      this.shapes.push(shape);\n      this.shapeOffsets.push(offset);\n      this.shapeOrientations.push(orientation);\n      this.updateMassProperties();\n      this.updateBoundingRadius();\n      this.aabbNeedsUpdate = true;\n      shape.body = this;\n      return this;\n    }\n    /**\n     * Remove a shape from the body.\n     * @return The body object, for chainability.\n     */\n  }, {\n    key: \"removeShape\",\n    value: function removeShape(shape) {\n      var index = this.shapes.indexOf(shape);\n      if (index === -1) {\n        console.warn('Shape does not belong to the body');\n        return this;\n      }\n      this.shapes.splice(index, 1);\n      this.shapeOffsets.splice(index, 1);\n      this.shapeOrientations.splice(index, 1);\n      this.updateMassProperties();\n      this.updateBoundingRadius();\n      this.aabbNeedsUpdate = true;\n      shape.body = null;\n      return this;\n    }\n    /**\n     * Update the bounding radius of the body. Should be done if any of the shapes are changed.\n     */\n  }, {\n    key: \"updateBoundingRadius\",\n    value: function updateBoundingRadius() {\n      var shapes = this.shapes;\n      var shapeOffsets = this.shapeOffsets;\n      var N = shapes.length;\n      var radius = 0;\n      for (var i = 0; i !== N; i++) {\n        var shape = shapes[i];\n        shape.updateBoundingSphereRadius();\n        var offset = shapeOffsets[i].length();\n        var r = shape.boundingSphereRadius;\n        if (offset + r > radius) {\n          radius = offset + r;\n        }\n      }\n      this.boundingRadius = radius;\n    }\n    /**\n     * Updates the .aabb\n     */\n  }, {\n    key: \"updateAABB\",\n    value: function updateAABB() {\n      var shapes = this.shapes;\n      var shapeOffsets = this.shapeOffsets;\n      var shapeOrientations = this.shapeOrientations;\n      var N = shapes.length;\n      var offset = tmpVec;\n      var orientation = tmpQuat;\n      var bodyQuat = this.quaternion;\n      var aabb = this.aabb;\n      var shapeAABB = updateAABB_shapeAABB;\n      for (var i = 0; i !== N; i++) {\n        var shape = shapes[i]; // Get shape world position\n\n        bodyQuat.vmult(shapeOffsets[i], offset);\n        offset.vadd(this.position, offset); // Get shape world quaternion\n\n        bodyQuat.mult(shapeOrientations[i], orientation); // Get shape AABB\n\n        shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);\n        if (i === 0) {\n          aabb.copy(shapeAABB);\n        } else {\n          aabb.extend(shapeAABB);\n        }\n      }\n      this.aabbNeedsUpdate = false;\n    }\n    /**\n     * Update `.inertiaWorld` and `.invInertiaWorld`\n     */\n  }, {\n    key: \"updateInertiaWorld\",\n    value: function updateInertiaWorld(force) {\n      var I = this.invInertia;\n      if (I.x === I.y && I.y === I.z && !force) ;else {\n        var m1 = uiw_m1;\n        var m2 = uiw_m2;\n        m1.setRotationFromQuaternion(this.quaternion);\n        m1.transpose(m2);\n        m1.scale(I, m1);\n        m1.mmult(m2, this.invInertiaWorld);\n      }\n    }\n    /**\n     * Apply force to a point of the body. This could for example be a point on the Body surface.\n     * Applying force this way will add to Body.force and Body.torque.\n     * @param force The amount of force to add.\n     * @param relativePoint A point relative to the center of mass to apply the force on.\n     */\n  }, {\n    key: \"applyForce\",\n    value: function applyForce(force, relativePoint) {\n      if (relativePoint === void 0) {\n        relativePoint = new Vec3$1();\n      }\n\n      // Needed?\n      if (this.type !== Body.DYNAMIC) {\n        return;\n      }\n      if (this.sleepState === Body.SLEEPING) {\n        this.wakeUp();\n      } // Compute produced rotational force\n\n      var rotForce = Body_applyForce_rotForce;\n      relativePoint.cross(force, rotForce); // Add linear force\n\n      this.force.vadd(force, this.force); // Add rotational force\n\n      this.torque.vadd(rotForce, this.torque);\n    }\n    /**\n     * Apply force to a local point in the body.\n     * @param force The force vector to apply, defined locally in the body frame.\n     * @param localPoint A local point in the body to apply the force on.\n     */\n  }, {\n    key: \"applyLocalForce\",\n    value: function applyLocalForce(localForce, localPoint) {\n      if (localPoint === void 0) {\n        localPoint = new Vec3$1();\n      }\n      if (this.type !== Body.DYNAMIC) {\n        return;\n      }\n      var worldForce = Body_applyLocalForce_worldForce;\n      var relativePointWorld = Body_applyLocalForce_relativePointWorld; // Transform the force vector to world space\n\n      this.vectorToWorldFrame(localForce, worldForce);\n      this.vectorToWorldFrame(localPoint, relativePointWorld);\n      this.applyForce(worldForce, relativePointWorld);\n    }\n    /**\n     * Apply torque to the body.\n     * @param torque The amount of torque to add.\n     */\n  }, {\n    key: \"applyTorque\",\n    value: function applyTorque(torque) {\n      if (this.type !== Body.DYNAMIC) {\n        return;\n      }\n      if (this.sleepState === Body.SLEEPING) {\n        this.wakeUp();\n      } // Add rotational force\n\n      this.torque.vadd(torque, this.torque);\n    }\n    /**\n     * Apply impulse to a point of the body. This could for example be a point on the Body surface.\n     * An impulse is a force added to a body during a short period of time (impulse = force * time).\n     * Impulses will be added to Body.velocity and Body.angularVelocity.\n     * @param impulse The amount of impulse to add.\n     * @param relativePoint A point relative to the center of mass to apply the force on.\n     */\n  }, {\n    key: \"applyImpulse\",\n    value: function applyImpulse(impulse, relativePoint) {\n      if (relativePoint === void 0) {\n        relativePoint = new Vec3$1();\n      }\n      if (this.type !== Body.DYNAMIC) {\n        return;\n      }\n      if (this.sleepState === Body.SLEEPING) {\n        this.wakeUp();\n      } // Compute point position relative to the body center\n\n      var r = relativePoint; // Compute produced central impulse velocity\n\n      var velo = Body_applyImpulse_velo;\n      velo.copy(impulse);\n      velo.scale(this.invMass, velo); // Add linear impulse\n\n      this.velocity.vadd(velo, this.velocity); // Compute produced rotational impulse velocity\n\n      var rotVelo = Body_applyImpulse_rotVelo;\n      r.cross(impulse, rotVelo);\n      /*\n       rotVelo.x *= this.invInertia.x;\n       rotVelo.y *= this.invInertia.y;\n       rotVelo.z *= this.invInertia.z;\n       */\n\n      this.invInertiaWorld.vmult(rotVelo, rotVelo); // Add rotational Impulse\n\n      this.angularVelocity.vadd(rotVelo, this.angularVelocity);\n    }\n    /**\n     * Apply locally-defined impulse to a local point in the body.\n     * @param force The force vector to apply, defined locally in the body frame.\n     * @param localPoint A local point in the body to apply the force on.\n     */\n  }, {\n    key: \"applyLocalImpulse\",\n    value: function applyLocalImpulse(localImpulse, localPoint) {\n      if (localPoint === void 0) {\n        localPoint = new Vec3$1();\n      }\n      if (this.type !== Body.DYNAMIC) {\n        return;\n      }\n      var worldImpulse = Body_applyLocalImpulse_worldImpulse;\n      var relativePointWorld = Body_applyLocalImpulse_relativePoint; // Transform the force vector to world space\n\n      this.vectorToWorldFrame(localImpulse, worldImpulse);\n      this.vectorToWorldFrame(localPoint, relativePointWorld);\n      this.applyImpulse(worldImpulse, relativePointWorld);\n    }\n    /**\n     * Should be called whenever you change the body shape or mass.\n     */\n  }, {\n    key: \"updateMassProperties\",\n    value: function updateMassProperties() {\n      var halfExtents = Body_updateMassProperties_halfExtents;\n      this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;\n      var I = this.inertia;\n      var fixed = this.fixedRotation; // Approximate with AABB box\n\n      this.updateAABB();\n      halfExtents.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);\n      Box.calculateInertia(halfExtents, this.mass, I);\n      this.invInertia.set(I.x > 0 && !fixed ? 1.0 / I.x : 0, I.y > 0 && !fixed ? 1.0 / I.y : 0, I.z > 0 && !fixed ? 1.0 / I.z : 0);\n      this.updateInertiaWorld(true);\n    }\n    /**\n     * Get world velocity of a point in the body.\n     * @param worldPoint\n     * @param result\n     * @return The result vector.\n     */\n  }, {\n    key: \"getVelocityAtWorldPoint\",\n    value: function getVelocityAtWorldPoint(worldPoint, result) {\n      var r = new Vec3$1();\n      worldPoint.vsub(this.position, r);\n      this.angularVelocity.cross(r, result);\n      this.velocity.vadd(result, result);\n      return result;\n    }\n    /**\n     * Move the body forward in time.\n     * @param dt Time step\n     * @param quatNormalize Set to true to normalize the body quaternion\n     * @param quatNormalizeFast If the quaternion should be normalized using \"fast\" quaternion normalization\n     */\n  }, {\n    key: \"integrate\",\n    value: function integrate(dt, quatNormalize, quatNormalizeFast) {\n      // Save previous position\n      this.previousPosition.copy(this.position);\n      this.previousQuaternion.copy(this.quaternion);\n      if (!(this.type === Body.DYNAMIC || this.type === Body.KINEMATIC) || this.sleepState === Body.SLEEPING) {\n        // Only for dynamic\n        return;\n      }\n      var velo = this.velocity;\n      var angularVelo = this.angularVelocity;\n      var pos = this.position;\n      var force = this.force;\n      var torque = this.torque;\n      var quat = this.quaternion;\n      var invMass = this.invMass;\n      var invInertia = this.invInertiaWorld;\n      var linearFactor = this.linearFactor;\n      var iMdt = invMass * dt;\n      velo.x += force.x * iMdt * linearFactor.x;\n      velo.y += force.y * iMdt * linearFactor.y;\n      velo.z += force.z * iMdt * linearFactor.z;\n      var e = invInertia.elements;\n      var angularFactor = this.angularFactor;\n      var tx = torque.x * angularFactor.x;\n      var ty = torque.y * angularFactor.y;\n      var tz = torque.z * angularFactor.z;\n      angularVelo.x += dt * (e[0] * tx + e[1] * ty + e[2] * tz);\n      angularVelo.y += dt * (e[3] * tx + e[4] * ty + e[5] * tz);\n      angularVelo.z += dt * (e[6] * tx + e[7] * ty + e[8] * tz); // Use new velocity  - leap frog\n\n      pos.x += velo.x * dt;\n      pos.y += velo.y * dt;\n      pos.z += velo.z * dt;\n      quat.integrate(this.angularVelocity, dt, this.angularFactor, quat);\n      if (quatNormalize) {\n        if (quatNormalizeFast) {\n          quat.normalizeFast();\n        } else {\n          quat.normalize();\n        }\n      }\n      this.aabbNeedsUpdate = true; // Update world inertia\n\n      this.updateInertiaWorld();\n    }\n  }]);\n  return Body;\n}(EventTarget);\nBody.idCounter = 0;\nBody.COLLIDE_EVENT_NAME = 'collide';\nBody.DYNAMIC = BODY_TYPES.DYNAMIC;\nBody.STATIC = BODY_TYPES.STATIC;\nBody.KINEMATIC = BODY_TYPES.KINEMATIC;\nBody.AWAKE = BODY_SLEEP_STATES.AWAKE;\nBody.SLEEPY = BODY_SLEEP_STATES.SLEEPY;\nBody.SLEEPING = BODY_SLEEP_STATES.SLEEPING;\nBody.wakeupEvent = {\n  type: 'wakeup'\n};\nBody.sleepyEvent = {\n  type: 'sleepy'\n};\nBody.sleepEvent = {\n  type: 'sleep'\n};\nvar tmpVec = new Vec3$1();\nvar tmpQuat = new Quaternion$1();\nvar updateAABB_shapeAABB = new AABB$1();\nvar uiw_m1 = new Mat3$1();\nvar uiw_m2 = new Mat3$1();\nnew Mat3$1();\nvar Body_applyForce_rotForce = new Vec3$1();\nvar Body_applyLocalForce_worldForce = new Vec3$1();\nvar Body_applyLocalForce_relativePointWorld = new Vec3$1();\nvar Body_applyImpulse_velo = new Vec3$1();\nvar Body_applyImpulse_rotVelo = new Vec3$1();\nvar Body_applyLocalImpulse_worldImpulse = new Vec3$1();\nvar Body_applyLocalImpulse_relativePoint = new Vec3$1();\nvar Body_updateMassProperties_halfExtents = new Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Quaternion$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\n\n/**\n * Storage for Ray casting data\n */\nvar RaycastResult$1 = /*#__PURE__*/function () {\n  /**\n   * rayFromWorld\n   */\n\n  /**\n   * rayToWorld\n   */\n\n  /**\n   * hitNormalWorld\n   */\n\n  /**\n   * hitPointWorld\n   */\n\n  /**\n   * hasHit\n   */\n\n  /**\n   * shape\n   */\n\n  /**\n   * body\n   */\n\n  /**\n   * The index of the hit triangle, if the hit shape was a trimesh\n   */\n\n  /**\n   * Distance to the hit. Will be set to -1 if there was no hit\n   */\n\n  /**\n   * If the ray should stop traversing the bodies\n   */\n  function RaycastResult$1() {\n    _classCallCheck(this, RaycastResult$1);\n    this.rayFromWorld = new Vec3$1();\n    this.rayToWorld = new Vec3$1();\n    this.hitNormalWorld = new Vec3$1();\n    this.hitPointWorld = new Vec3$1();\n    this.hasHit = false;\n    this.shape = null;\n    this.body = null;\n    this.hitFaceIndex = -1;\n    this.distance = -1;\n    this.shouldStop = false;\n  }\n  /**\n   * Reset all result data.\n   */\n  _createClass(RaycastResult$1, [{\n    key: \"reset\",\n    value: function reset() {\n      this.rayFromWorld.setZero();\n      this.rayToWorld.setZero();\n      this.hitNormalWorld.setZero();\n      this.hitPointWorld.setZero();\n      this.hasHit = false;\n      this.shape = null;\n      this.body = null;\n      this.hitFaceIndex = -1;\n      this.distance = -1;\n      this.shouldStop = false;\n    }\n    /**\n     * abort\n     */\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this.shouldStop = true;\n    }\n    /**\n     * Set result data.\n     */\n  }, {\n    key: \"set\",\n    value: function set(rayFromWorld, rayToWorld, hitNormalWorld, hitPointWorld, shape, body, distance) {\n      this.rayFromWorld.copy(rayFromWorld);\n      this.rayToWorld.copy(rayToWorld);\n      this.hitNormalWorld.copy(hitNormalWorld);\n      this.hitPointWorld.copy(hitPointWorld);\n      this.shape = shape;\n      this.body = body;\n      this.distance = distance;\n    }\n  }]);\n  return RaycastResult$1;\n}();\nvar _Shape$types$SPHERE$1, _Shape$types$PLANE$1, _Shape$types$BOX$1, _Shape$types$CYLINDER$1, _Shape$types$CONVEXPO$1, _Shape$types$HEIGHTFI$1, _Shape$types$TRIMESH$1;\n\n/**\n * RAY_MODES\n */\nvar RAY_MODES$1 = {\n  /** CLOSEST */\n  CLOSEST: 1,\n  /** ANY */\n  ANY: 2,\n  /** ALL */\n  ALL: 4\n};\n/**\n * RayMode\n */\n\n_Shape$types$SPHERE$1 = Shape$1.types.SPHERE;\n_Shape$types$PLANE$1 = Shape$1.types.PLANE;\n_Shape$types$BOX$1 = Shape$1.types.BOX;\n_Shape$types$CYLINDER$1 = Shape$1.types.CYLINDER;\n_Shape$types$CONVEXPO$1 = Shape$1.types.CONVEXPOLYHEDRON;\n_Shape$types$HEIGHTFI$1 = Shape$1.types.HEIGHTFIELD;\n_Shape$types$TRIMESH$1 = Shape$1.types.TRIMESH;\n\n/**\n * A line in 3D space that intersects bodies and return points.\n */\nvar Ray$1 = /*#__PURE__*/function (_Shape$types$SPHERE$, _Shape$types$PLANE$, _Shape$types$BOX$, _Shape$types$CYLINDER2, _Shape$types$CONVEXPO2, _Shape$types$HEIGHTFI2, _Shape$types$TRIMESH$) {\n  function Ray$1(from, to) {\n    _classCallCheck(this, Ray$1);\n    if (from === void 0) {\n      from = new Vec3$1();\n    }\n    if (to === void 0) {\n      to = new Vec3$1();\n    }\n    this.from = from.clone();\n    this.to = to.clone();\n    this.direction = new Vec3$1();\n    this.precision = 0.0001;\n    this.checkCollisionResponse = true;\n    this.skipBackfaces = false;\n    this.collisionFilterMask = -1;\n    this.collisionFilterGroup = -1;\n    this.mode = Ray$1.ANY;\n    this.result = new RaycastResult$1();\n    this.hasHit = false;\n    this.callback = function (result) {};\n  }\n  /**\n   * Do itersection against all bodies in the given World.\n   * @return True if the ray hit anything, otherwise false.\n   */\n  _createClass(Ray$1, [{\n    key: _Shape$types$SPHERE$,\n    get:\n    /**\n     * from\n     */\n\n    /**\n     * to\n     */\n\n    /**\n     * direction\n     */\n\n    /**\n     * The precision of the ray. Used when checking parallelity etc.\n     * @default 0.0001\n     */\n\n    /**\n     * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.\n     * @default true\n     */\n\n    /**\n     * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.\n     * @default false\n     */\n\n    /**\n     * collisionFilterMask\n     * @default -1\n     */\n\n    /**\n     * collisionFilterGroup\n     * @default -1\n     */\n\n    /**\n     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.\n     * @default RAY.ANY\n     */\n\n    /**\n     * Current result object.\n     */\n\n    /**\n     * Will be set to `true` during intersectWorld() if the ray hit anything.\n     */\n\n    /**\n     * User-provided result callback. Will be used if mode is Ray.ALL.\n     */\n\n    /**\n     * CLOSEST\n     */\n\n    /**\n     * ANY\n     */\n\n    /**\n     * ALL\n     */\n    function get() {\n      return this._intersectSphere;\n    }\n  }, {\n    key: _Shape$types$PLANE$,\n    get: function get() {\n      return this._intersectPlane;\n    }\n  }, {\n    key: _Shape$types$BOX$,\n    get: function get() {\n      return this._intersectBox;\n    }\n  }, {\n    key: _Shape$types$CYLINDER2,\n    get: function get() {\n      return this._intersectConvex;\n    }\n  }, {\n    key: _Shape$types$CONVEXPO2,\n    get: function get() {\n      return this._intersectConvex;\n    }\n  }, {\n    key: _Shape$types$HEIGHTFI2,\n    get: function get() {\n      return this._intersectHeightfield;\n    }\n  }, {\n    key: _Shape$types$TRIMESH$,\n    get: function get() {\n      return this._intersectTrimesh;\n    }\n  }, {\n    key: \"intersectWorld\",\n    value: function intersectWorld(world, options) {\n      this.mode = options.mode || Ray$1.ANY;\n      this.result = options.result || new RaycastResult$1();\n      this.skipBackfaces = !!options.skipBackfaces;\n      this.collisionFilterMask = typeof options.collisionFilterMask !== 'undefined' ? options.collisionFilterMask : -1;\n      this.collisionFilterGroup = typeof options.collisionFilterGroup !== 'undefined' ? options.collisionFilterGroup : -1;\n      this.checkCollisionResponse = typeof options.checkCollisionResponse !== 'undefined' ? options.checkCollisionResponse : true;\n      if (options.from) {\n        this.from.copy(options.from);\n      }\n      if (options.to) {\n        this.to.copy(options.to);\n      }\n      this.callback = options.callback || function () {};\n      this.hasHit = false;\n      this.result.reset();\n      this.updateDirection();\n      this.getAABB(tmpAABB$1$1);\n      tmpArray$1.length = 0;\n      world.broadphase.aabbQuery(world, tmpAABB$1$1, tmpArray$1);\n      this.intersectBodies(tmpArray$1);\n      return this.hasHit;\n    }\n    /**\n     * Shoot a ray at a body, get back information about the hit.\n     * @deprecated @param result set the result property of the Ray instead.\n     */\n  }, {\n    key: \"intersectBody\",\n    value: function intersectBody(body, result) {\n      if (result) {\n        this.result = result;\n        this.updateDirection();\n      }\n      var checkCollisionResponse = this.checkCollisionResponse;\n      if (checkCollisionResponse && !body.collisionResponse) {\n        return;\n      }\n      if ((this.collisionFilterGroup & body.collisionFilterMask) === 0 || (body.collisionFilterGroup & this.collisionFilterMask) === 0) {\n        return;\n      }\n      var xi = intersectBody_xi$1;\n      var qi = intersectBody_qi$1;\n      for (var i = 0, N = body.shapes.length; i < N; i++) {\n        var shape = body.shapes[i];\n        if (checkCollisionResponse && !shape.collisionResponse) {\n          continue; // Skip\n        }\n\n        body.quaternion.mult(body.shapeOrientations[i], qi);\n        body.quaternion.vmult(body.shapeOffsets[i], xi);\n        xi.vadd(body.position, xi);\n        this.intersectShape(shape, qi, xi, body);\n        if (this.result.shouldStop) {\n          break;\n        }\n      }\n    }\n    /**\n     * Shoot a ray at an array bodies, get back information about the hit.\n     * @param bodies An array of Body objects.\n     * @deprecated @param result set the result property of the Ray instead.\n     *\n     */\n  }, {\n    key: \"intersectBodies\",\n    value: function intersectBodies(bodies, result) {\n      if (result) {\n        this.result = result;\n        this.updateDirection();\n      }\n      for (var i = 0, l = bodies.length; !this.result.shouldStop && i < l; i++) {\n        this.intersectBody(bodies[i]);\n      }\n    }\n    /**\n     * Updates the direction vector.\n     */\n  }, {\n    key: \"updateDirection\",\n    value: function updateDirection() {\n      this.to.vsub(this.from, this.direction);\n      this.direction.normalize();\n    }\n  }, {\n    key: \"intersectShape\",\n    value: function intersectShape(shape, quat, position, body) {\n      var from = this.from; // Checking boundingSphere\n\n      var distance = distanceFromIntersection$1(from, this.direction, position);\n      if (distance > shape.boundingSphereRadius) {\n        return;\n      }\n      var intersectMethod = this[shape.type];\n      if (intersectMethod) {\n        intersectMethod.call(this, shape, quat, position, body, shape);\n      }\n    }\n  }, {\n    key: \"_intersectBox\",\n    value: function _intersectBox(box, quat, position, body, reportedShape) {\n      return this._intersectConvex(box.convexPolyhedronRepresentation, quat, position, body, reportedShape);\n    }\n  }, {\n    key: \"_intersectPlane\",\n    value: function _intersectPlane(shape, quat, position, body, reportedShape) {\n      var from = this.from;\n      var to = this.to;\n      var direction = this.direction; // Get plane normal\n\n      var worldNormal = new Vec3$1(0, 0, 1);\n      quat.vmult(worldNormal, worldNormal);\n      var len = new Vec3$1();\n      from.vsub(position, len);\n      var planeToFrom = len.dot(worldNormal);\n      to.vsub(position, len);\n      var planeToTo = len.dot(worldNormal);\n      if (planeToFrom * planeToTo > 0) {\n        // \"from\" and \"to\" are on the same side of the plane... bail out\n        return;\n      }\n      if (from.distanceTo(to) < planeToFrom) {\n        return;\n      }\n      var n_dot_dir = worldNormal.dot(direction);\n      if (Math.abs(n_dot_dir) < this.precision) {\n        // No intersection\n        return;\n      }\n      var planePointToFrom = new Vec3$1();\n      var dir_scaled_with_t = new Vec3$1();\n      var hitPointWorld = new Vec3$1();\n      from.vsub(position, planePointToFrom);\n      var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;\n      direction.scale(t, dir_scaled_with_t);\n      from.vadd(dir_scaled_with_t, hitPointWorld);\n      this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);\n    }\n    /**\n     * Get the world AABB of the ray.\n     */\n  }, {\n    key: \"getAABB\",\n    value: function getAABB(aabb) {\n      var lowerBound = aabb.lowerBound,\n        upperBound = aabb.upperBound;\n      var to = this.to;\n      var from = this.from;\n      lowerBound.x = Math.min(to.x, from.x);\n      lowerBound.y = Math.min(to.y, from.y);\n      lowerBound.z = Math.min(to.z, from.z);\n      upperBound.x = Math.max(to.x, from.x);\n      upperBound.y = Math.max(to.y, from.y);\n      upperBound.z = Math.max(to.z, from.z);\n    }\n  }, {\n    key: \"_intersectHeightfield\",\n    value: function _intersectHeightfield(shape, quat, position, body, reportedShape) {\n      shape.data;\n      shape.elementSize; // Convert the ray to local heightfield coordinates\n\n      var localRay = intersectHeightfield_localRay$1; //new Ray(this.from, this.to);\n\n      localRay.from.copy(this.from);\n      localRay.to.copy(this.to);\n      Transform$1.pointToLocalFrame(position, quat, localRay.from, localRay.from);\n      Transform$1.pointToLocalFrame(position, quat, localRay.to, localRay.to);\n      localRay.updateDirection(); // Get the index of the data points to test against\n\n      var index = intersectHeightfield_index$1;\n      var iMinX;\n      var iMinY;\n      var iMaxX;\n      var iMaxY; // Set to max\n\n      iMinX = iMinY = 0;\n      iMaxX = iMaxY = shape.data.length - 1;\n      var aabb = new AABB$1();\n      localRay.getAABB(aabb);\n      shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);\n      iMinX = Math.max(iMinX, index[0]);\n      iMinY = Math.max(iMinY, index[1]);\n      shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);\n      iMaxX = Math.min(iMaxX, index[0] + 1);\n      iMaxY = Math.min(iMaxY, index[1] + 1);\n      for (var i = iMinX; i < iMaxX; i++) {\n        for (var j = iMinY; j < iMaxY; j++) {\n          if (this.result.shouldStop) {\n            return;\n          }\n          shape.getAabbAtIndex(i, j, aabb);\n          if (!aabb.overlapsRay(localRay)) {\n            continue;\n          } // Lower triangle\n\n          shape.getConvexTrianglePillar(i, j, false);\n          Transform$1.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset$1);\n          this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset$1, body, reportedShape, intersectConvexOptions$1);\n          if (this.result.shouldStop) {\n            return;\n          } // Upper triangle\n\n          shape.getConvexTrianglePillar(i, j, true);\n          Transform$1.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset$1);\n          this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset$1, body, reportedShape, intersectConvexOptions$1);\n        }\n      }\n    }\n  }, {\n    key: \"_intersectSphere\",\n    value: function _intersectSphere(sphere, quat, position, body, reportedShape) {\n      var from = this.from;\n      var to = this.to;\n      var r = sphere.radius;\n      var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);\n      var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));\n      var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);\n      var delta = Math.pow(b, 2) - 4 * a * c;\n      var intersectionPoint = Ray_intersectSphere_intersectionPoint$1;\n      var normal = Ray_intersectSphere_normal$1;\n      if (delta < 0) {\n        // No intersection\n        return;\n      } else if (delta === 0) {\n        // single intersection point\n        from.lerp(to, delta, intersectionPoint);\n        intersectionPoint.vsub(position, normal);\n        normal.normalize();\n        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);\n      } else {\n        var d1 = (-b - Math.sqrt(delta)) / (2 * a);\n        var d2 = (-b + Math.sqrt(delta)) / (2 * a);\n        if (d1 >= 0 && d1 <= 1) {\n          from.lerp(to, d1, intersectionPoint);\n          intersectionPoint.vsub(position, normal);\n          normal.normalize();\n          this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);\n        }\n        if (this.result.shouldStop) {\n          return;\n        }\n        if (d2 >= 0 && d2 <= 1) {\n          from.lerp(to, d2, intersectionPoint);\n          intersectionPoint.vsub(position, normal);\n          normal.normalize();\n          this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);\n        }\n      }\n    }\n  }, {\n    key: \"_intersectConvex\",\n    value: function _intersectConvex(shape, quat, position, body, reportedShape, options) {\n      var normal = intersectConvex_normal$1;\n      var vector = intersectConvex_vector$1;\n      var faceList = options && options.faceList || null; // Checking faces\n\n      var faces = shape.faces;\n      var vertices = shape.vertices;\n      var normals = shape.faceNormals;\n      var direction = this.direction;\n      var from = this.from;\n      var to = this.to;\n      var fromToDistance = from.distanceTo(to);\n      var Nfaces = faceList ? faceList.length : faces.length;\n      var result = this.result;\n      for (var j = 0; !result.shouldStop && j < Nfaces; j++) {\n        var fi = faceList ? faceList[j] : j;\n        var face = faces[fi];\n        var faceNormal = normals[fi];\n        var _q = quat;\n        var x = position; // determine if ray intersects the plane of the face\n        // note: this works regardless of the direction of the face normal\n        // Get plane point in world coordinates...\n\n        vector.copy(vertices[face[0]]);\n        _q.vmult(vector, vector);\n        vector.vadd(x, vector); // ...but make it relative to the ray from. We'll fix this later.\n\n        vector.vsub(from, vector); // Get plane normal\n\n        _q.vmult(faceNormal, normal); // If this dot product is negative, we have something interesting\n\n        var dot = direction.dot(normal); // Bail out if ray and plane are parallel\n\n        if (Math.abs(dot) < this.precision) {\n          continue;\n        } // calc distance to plane\n\n        var scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray\n\n        if (scalar < 0) {\n          continue;\n        } // if (dot < 0) {\n        // Intersection point is from + direction * scalar\n\n        direction.scale(scalar, intersectPoint$1);\n        intersectPoint$1.vadd(from, intersectPoint$1); // a is the point we compare points b and c with.\n\n        a$1.copy(vertices[face[0]]);\n        _q.vmult(a$1, a$1);\n        x.vadd(a$1, a$1);\n        for (var i = 1; !result.shouldStop && i < face.length - 1; i++) {\n          // Transform 3 vertices to world coords\n          b$1.copy(vertices[face[i]]);\n          c$1.copy(vertices[face[i + 1]]);\n          _q.vmult(b$1, b$1);\n          _q.vmult(c$1, c$1);\n          x.vadd(b$1, b$1);\n          x.vadd(c$1, c$1);\n          var distance = intersectPoint$1.distanceTo(from);\n          if (!(Ray$1.pointInTriangle(intersectPoint$1, a$1, b$1, c$1) || Ray$1.pointInTriangle(intersectPoint$1, b$1, a$1, c$1)) || distance > fromToDistance) {\n            continue;\n          }\n          this.reportIntersection(normal, intersectPoint$1, reportedShape, body, fi);\n        } // }\n      }\n    }\n    /**\n     * @todo Optimize by transforming the world to local space first.\n     * @todo Use Octree lookup\n     */\n  }, {\n    key: \"_intersectTrimesh\",\n    value: function _intersectTrimesh(mesh, quat, position, body, reportedShape, options) {\n      var normal = intersectTrimesh_normal$1;\n      var triangles = intersectTrimesh_triangles$1;\n      var treeTransform = intersectTrimesh_treeTransform$1;\n      var vector = intersectConvex_vector$1;\n      var localDirection = intersectTrimesh_localDirection$1;\n      var localFrom = intersectTrimesh_localFrom$1;\n      var localTo = intersectTrimesh_localTo$1;\n      var worldIntersectPoint = intersectTrimesh_worldIntersectPoint$1;\n      var worldNormal = intersectTrimesh_worldNormal$1; // Checking faces\n\n      var indices = mesh.indices;\n      mesh.vertices; // const normals = mesh.faceNormals\n\n      var from = this.from;\n      var to = this.to;\n      var direction = this.direction;\n      treeTransform.position.copy(position);\n      treeTransform.quaternion.copy(quat); // Transform ray to local space!\n\n      Transform$1.vectorToLocalFrame(position, quat, direction, localDirection);\n      Transform$1.pointToLocalFrame(position, quat, from, localFrom);\n      Transform$1.pointToLocalFrame(position, quat, to, localTo);\n      localTo.x *= mesh.scale.x;\n      localTo.y *= mesh.scale.y;\n      localTo.z *= mesh.scale.z;\n      localFrom.x *= mesh.scale.x;\n      localFrom.y *= mesh.scale.y;\n      localFrom.z *= mesh.scale.z;\n      localTo.vsub(localFrom, localDirection);\n      localDirection.normalize();\n      var fromToDistanceSquared = localFrom.distanceSquared(localTo);\n      mesh.tree.rayQuery(this, treeTransform, triangles);\n      for (var i = 0, N = triangles.length; !this.result.shouldStop && i !== N; i++) {\n        var trianglesIndex = triangles[i];\n        mesh.getNormal(trianglesIndex, normal); // determine if ray intersects the plane of the face\n        // note: this works regardless of the direction of the face normal\n        // Get plane point in world coordinates...\n\n        mesh.getVertex(indices[trianglesIndex * 3], a$1); // ...but make it relative to the ray from. We'll fix this later.\n\n        a$1.vsub(localFrom, vector); // If this dot product is negative, we have something interesting\n\n        var dot = localDirection.dot(normal); // Bail out if ray and plane are parallel\n        // if (Math.abs( dot ) < this.precision){\n        //     continue;\n        // }\n        // calc distance to plane\n\n        var scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray\n\n        if (scalar < 0) {\n          continue;\n        } // Intersection point is from + direction * scalar\n\n        localDirection.scale(scalar, intersectPoint$1);\n        intersectPoint$1.vadd(localFrom, intersectPoint$1); // Get triangle vertices\n\n        mesh.getVertex(indices[trianglesIndex * 3 + 1], b$1);\n        mesh.getVertex(indices[trianglesIndex * 3 + 2], c$1);\n        var squaredDistance = intersectPoint$1.distanceSquared(localFrom);\n        if (!(Ray$1.pointInTriangle(intersectPoint$1, b$1, a$1, c$1) || Ray$1.pointInTriangle(intersectPoint$1, a$1, b$1, c$1)) || squaredDistance > fromToDistanceSquared) {\n          continue;\n        } // transform intersectpoint and normal to world\n\n        Transform$1.vectorToWorldFrame(quat, normal, worldNormal);\n        Transform$1.pointToWorldFrame(position, quat, intersectPoint$1, worldIntersectPoint);\n        this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);\n      }\n      triangles.length = 0;\n    }\n    /**\n     * @return True if the intersections should continue\n     */\n  }, {\n    key: \"reportIntersection\",\n    value: function reportIntersection(normal, hitPointWorld, shape, body, hitFaceIndex) {\n      var from = this.from;\n      var to = this.to;\n      var distance = from.distanceTo(hitPointWorld);\n      var result = this.result; // Skip back faces?\n\n      if (this.skipBackfaces && normal.dot(this.direction) > 0) {\n        return;\n      }\n      result.hitFaceIndex = typeof hitFaceIndex !== 'undefined' ? hitFaceIndex : -1;\n      switch (this.mode) {\n        case Ray$1.ALL:\n          this.hasHit = true;\n          result.set(from, to, normal, hitPointWorld, shape, body, distance);\n          result.hasHit = true;\n          this.callback(result);\n          break;\n        case Ray$1.CLOSEST:\n          // Store if closer than current closest\n          if (distance < result.distance || !result.hasHit) {\n            this.hasHit = true;\n            result.hasHit = true;\n            result.set(from, to, normal, hitPointWorld, shape, body, distance);\n          }\n          break;\n        case Ray$1.ANY:\n          // Report and stop.\n          this.hasHit = true;\n          result.hasHit = true;\n          result.set(from, to, normal, hitPointWorld, shape, body, distance);\n          result.shouldStop = true;\n          break;\n      }\n    }\n    /**\n     * As per \"Barycentric Technique\" as named\n     * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division\n     */\n  }], [{\n    key: \"pointInTriangle\",\n    value: function pointInTriangle(p, a, b, c) {\n      c.vsub(a, v0$1);\n      b.vsub(a, v1$1);\n      p.vsub(a, v2$1);\n      var dot00 = v0$1.dot(v0$1);\n      var dot01 = v0$1.dot(v1$1);\n      var dot02 = v0$1.dot(v2$1);\n      var dot11 = v1$1.dot(v1$1);\n      var dot12 = v1$1.dot(v2$1);\n      var u;\n      var v;\n      return (u = dot11 * dot02 - dot01 * dot12) >= 0 && (v = dot00 * dot12 - dot01 * dot02) >= 0 && u + v < dot00 * dot11 - dot01 * dot01;\n    }\n  }]);\n  return Ray$1;\n}(_Shape$types$SPHERE$1, _Shape$types$PLANE$1, _Shape$types$BOX$1, _Shape$types$CYLINDER$1, _Shape$types$CONVEXPO$1, _Shape$types$HEIGHTFI$1, _Shape$types$TRIMESH$1);\nRay$1.CLOSEST = RAY_MODES$1.CLOSEST;\nRay$1.ANY = RAY_MODES$1.ANY;\nRay$1.ALL = RAY_MODES$1.ALL;\nvar tmpAABB$1$1 = new AABB$1();\nvar tmpArray$1 = [];\nvar v1$1 = new Vec3$1();\nvar v2$1 = new Vec3$1();\nvar intersectBody_xi$1 = new Vec3$1();\nvar intersectBody_qi$1 = new Quaternion$1();\nvar intersectPoint$1 = new Vec3$1();\nvar a$1 = new Vec3$1();\nvar b$1 = new Vec3$1();\nvar c$1 = new Vec3$1();\nnew Vec3$1();\nnew RaycastResult$1();\nvar intersectConvexOptions$1 = {\n  faceList: [0]\n};\nvar worldPillarOffset$1 = new Vec3$1();\nvar intersectHeightfield_localRay$1 = new Ray$1();\nvar intersectHeightfield_index$1 = [];\nvar Ray_intersectSphere_intersectionPoint$1 = new Vec3$1();\nvar Ray_intersectSphere_normal$1 = new Vec3$1();\nvar intersectConvex_normal$1 = new Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nvar intersectConvex_vector$1 = new Vec3$1();\nvar intersectTrimesh_normal$1 = new Vec3$1();\nvar intersectTrimesh_localDirection$1 = new Vec3$1();\nvar intersectTrimesh_localFrom$1 = new Vec3$1();\nvar intersectTrimesh_localTo$1 = new Vec3$1();\nvar intersectTrimesh_worldNormal$1 = new Vec3$1();\nvar intersectTrimesh_worldIntersectPoint$1 = new Vec3$1();\nnew AABB$1();\nvar intersectTrimesh_triangles$1 = [];\nvar intersectTrimesh_treeTransform$1 = new Transform$1();\nvar v0$1 = new Vec3$1();\nvar intersect$1 = new Vec3$1();\nfunction distanceFromIntersection$1(from, direction, position) {\n  // v0 is vector from from to position\n  position.vsub(from, v0$1);\n  var dot = v0$1.dot(direction); // intersect = direction*dot + from\n\n  direction.scale(dot, intersect$1);\n  intersect$1.vadd(from, intersect$1);\n  var distance = position.distanceTo(intersect$1);\n  return distance;\n}\nvar Utils = /*#__PURE__*/function () {\n  function Utils() {\n    _classCallCheck(this, Utils);\n  }\n  _createClass(Utils, null, [{\n    key: \"defaults\",\n    value:\n    /**\n     * Extend an options object with default values.\n     * @param options The options object. May be falsy: in this case, a new object is created and returned.\n     * @param defaults An object containing default values.\n     * @return The modified options object.\n     */\n    function defaults(options, _defaults) {\n      if (options === void 0) {\n        options = {};\n      }\n      for (var key in _defaults) {\n        if (!(key in options)) {\n          options[key] = _defaults[key];\n        }\n      }\n      return options;\n    }\n  }]);\n  return Utils;\n}();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1(); // Temp vectors\n\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\n\n/**\n * Defines a physics material.\n */\nvar Material = /*#__PURE__*/_createClass(\n/**\n * Material name.\n * If options is a string, name will be set to that string.\n * @todo Deprecate this\n */\n\n/** Material id. */\n\n/**\n * Friction for this material.\n * If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.\n */\n\n/**\n * Restitution for this material.\n * If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.\n */\nfunction Material(options) {\n  _classCallCheck(this, Material);\n  if (options === void 0) {\n    options = {};\n  }\n  var name = ''; // Backwards compatibility fix\n\n  if (typeof options === 'string') {\n    //console.warn(`Passing a string to MaterialOptions is deprecated, and has no effect`)\n    name = options;\n    options = {};\n  }\n  this.name = name;\n  this.id = Material.idCounter++;\n  this.friction = typeof options.friction !== 'undefined' ? options.friction : -1;\n  this.restitution = typeof options.restitution !== 'undefined' ? options.restitution : -1;\n});\nMaterial.idCounter = 0;\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Ray$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\n[new Vec3$1(1, 0, 0), new Vec3$1(0, 1, 0), new Vec3$1(0, 0, 1)];\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1(); // bilateral constraint between two dynamic objects\n\n/**\n * Spherical shape\n * @example\n *     const radius = 1\n *     const sphereShape = new CANNON.Sphere(radius)\n *     const sphereBody = new CANNON.Body({ mass: 1, shape: sphereShape })\n *     world.addBody(sphereBody)\n */\nvar Sphere = /*#__PURE__*/function (_Shape$3) {\n  _inherits(Sphere, _Shape$3);\n  var _super5 = _createSuper(Sphere);\n  /**\n   * The radius of the sphere.\n   */\n\n  /**\n   *\n   * @param radius The radius of the sphere, a non-negative number.\n   */\n  function Sphere(radius) {\n    var _this6;\n    _classCallCheck(this, Sphere);\n    _this6 = _super5.call(this, {\n      type: Shape$1.types.SPHERE\n    });\n    _this6.radius = radius !== undefined ? radius : 1.0;\n    if (_this6.radius < 0) {\n      throw new Error('The sphere radius cannot be negative.');\n    }\n    _this6.updateBoundingSphereRadius();\n    return _this6;\n  }\n  /** calculateLocalInertia */\n  _createClass(Sphere, [{\n    key: \"calculateLocalInertia\",\n    value: function calculateLocalInertia(mass, target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      var I = 2.0 * mass * this.radius * this.radius / 5.0;\n      target.x = I;\n      target.y = I;\n      target.z = I;\n      return target;\n    }\n    /** volume */\n  }, {\n    key: \"volume\",\n    value: function volume() {\n      return 4.0 * Math.PI * Math.pow(this.radius, 3) / 3.0;\n    }\n  }, {\n    key: \"updateBoundingSphereRadius\",\n    value: function updateBoundingSphereRadius() {\n      this.boundingSphereRadius = this.radius;\n    }\n  }, {\n    key: \"calculateWorldAABB\",\n    value: function calculateWorldAABB(pos, quat, min, max) {\n      var r = this.radius;\n      var axes = ['x', 'y', 'z'];\n      for (var i = 0; i < axes.length; i++) {\n        var ax = axes[i];\n        min[ax] = pos[ax] - r;\n        max[ax] = pos[ax] + r;\n      }\n    }\n  }]);\n  return Sphere;\n}(Shape$1);\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1(); // Temp vectors for calculation\n\nnew Vec3$1(); // Relative velocity\n\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\n\n/**\n * Cylinder class.\n * @example\n *     const radiusTop = 0.5\n *     const radiusBottom = 0.5\n *     const height = 2\n *     const numSegments = 12\n *     const cylinderShape = new CANNON.Cylinder(radiusTop, radiusBottom, height, numSegments)\n *     const cylinderBody = new CANNON.Body({ mass: 1, shape: cylinderShape })\n *     world.addBody(cylinderBody)\n */\nvar Cylinder = /*#__PURE__*/function (_ConvexPolyhedron) {\n  _inherits(Cylinder, _ConvexPolyhedron);\n  var _super6 = _createSuper(Cylinder);\n  /** The radius of the top of the Cylinder. */\n\n  /** The radius of the bottom of the Cylinder. */\n\n  /** The height of the Cylinder. */\n\n  /** The number of segments to build the cylinder out of. */\n\n  /**\n   * @param radiusTop The radius of the top of the Cylinder.\n   * @param radiusBottom The radius of the bottom of the Cylinder.\n   * @param height The height of the Cylinder.\n   * @param numSegments The number of segments to build the cylinder out of.\n   */\n  function Cylinder(radiusTop, radiusBottom, height, numSegments) {\n    var _this7;\n    _classCallCheck(this, Cylinder);\n    if (radiusTop === void 0) {\n      radiusTop = 1;\n    }\n    if (radiusBottom === void 0) {\n      radiusBottom = 1;\n    }\n    if (height === void 0) {\n      height = 1;\n    }\n    if (numSegments === void 0) {\n      numSegments = 8;\n    }\n    if (radiusTop < 0) {\n      throw new Error('The cylinder radiusTop cannot be negative.');\n    }\n    if (radiusBottom < 0) {\n      throw new Error('The cylinder radiusBottom cannot be negative.');\n    }\n    var N = numSegments;\n    var vertices = [];\n    var axes = [];\n    var faces = [];\n    var bottomface = [];\n    var topface = [];\n    var cos = Math.cos;\n    var sin = Math.sin; // First bottom point\n\n    vertices.push(new Vec3$1(-radiusBottom * sin(0), -height * 0.5, radiusBottom * cos(0)));\n    bottomface.push(0); // First top point\n\n    vertices.push(new Vec3$1(-radiusTop * sin(0), height * 0.5, radiusTop * cos(0)));\n    topface.push(1);\n    for (var i = 0; i < N; i++) {\n      var theta = 2 * Math.PI / N * (i + 1);\n      var thetaN = 2 * Math.PI / N * (i + 0.5);\n      if (i < N - 1) {\n        // Bottom\n        vertices.push(new Vec3$1(-radiusBottom * sin(theta), -height * 0.5, radiusBottom * cos(theta)));\n        bottomface.push(2 * i + 2); // Top\n\n        vertices.push(new Vec3$1(-radiusTop * sin(theta), height * 0.5, radiusTop * cos(theta)));\n        topface.push(2 * i + 3); // Face\n\n        faces.push([2 * i, 2 * i + 1, 2 * i + 3, 2 * i + 2]);\n      } else {\n        faces.push([2 * i, 2 * i + 1, 1, 0]); // Connect\n      } // Axis: we can cut off half of them if we have even number of segments\n\n      if (N % 2 === 1 || i < N / 2) {\n        axes.push(new Vec3$1(-sin(thetaN), 0, cos(thetaN)));\n      }\n    }\n    faces.push(bottomface);\n    axes.push(new Vec3$1(0, 1, 0)); // Reorder top face\n\n    var temp = [];\n    for (var _i8 = 0; _i8 < topface.length; _i8++) {\n      temp.push(topface[topface.length - _i8 - 1]);\n    }\n    faces.push(temp);\n    _this7 = _super6.call(this, {\n      vertices: vertices,\n      faces: faces,\n      axes: axes\n    });\n    _this7.type = Shape$1.types.CYLINDER;\n    _this7.radiusTop = radiusTop;\n    _this7.radiusBottom = radiusBottom;\n    _this7.height = height;\n    _this7.numSegments = numSegments;\n    return _this7;\n  }\n  return _createClass(Cylinder);\n}(ConvexPolyhedron);\n/**\n * Particle shape.\n * @example\n *     const particleShape = new CANNON.Particle()\n *     const particleBody = new CANNON.Body({ mass: 1, shape: particleShape })\n *     world.addBody(particleBody)\n */\nvar Particle = /*#__PURE__*/function (_Shape$4) {\n  _inherits(Particle, _Shape$4);\n  var _super7 = _createSuper(Particle);\n  function Particle() {\n    _classCallCheck(this, Particle);\n    return _super7.call(this, {\n      type: Shape$1.types.PARTICLE\n    });\n  }\n  /**\n   * calculateLocalInertia\n   */\n  _createClass(Particle, [{\n    key: \"calculateLocalInertia\",\n    value: function calculateLocalInertia(mass, target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      target.set(0, 0, 0);\n      return target;\n    }\n  }, {\n    key: \"volume\",\n    value: function volume() {\n      return 0;\n    }\n  }, {\n    key: \"updateBoundingSphereRadius\",\n    value: function updateBoundingSphereRadius() {\n      this.boundingSphereRadius = 0;\n    }\n  }, {\n    key: \"calculateWorldAABB\",\n    value: function calculateWorldAABB(pos, quat, min, max) {\n      // Get each axis max\n      min.copy(pos);\n      max.copy(pos);\n    }\n  }]);\n  return Particle;\n}(Shape$1);\n/**\n * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a Body and rotate that body. See the demos.\n * @example\n *     const planeShape = new CANNON.Plane()\n *     const planeBody = new CANNON.Body({ mass: 0, shape:  planeShape })\n *     planeBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0) // make it face up\n *     world.addBody(planeBody)\n */\nvar Plane = /*#__PURE__*/function (_Shape$5) {\n  _inherits(Plane, _Shape$5);\n  var _super8 = _createSuper(Plane);\n  /** worldNormal */\n\n  /** worldNormalNeedsUpdate */\n  function Plane() {\n    var _this8;\n    _classCallCheck(this, Plane);\n    _this8 = _super8.call(this, {\n      type: Shape$1.types.PLANE\n    }); // World oriented normal\n\n    _this8.worldNormal = new Vec3$1();\n    _this8.worldNormalNeedsUpdate = true;\n    _this8.boundingSphereRadius = Number.MAX_VALUE;\n    return _this8;\n  }\n  /** computeWorldNormal */\n  _createClass(Plane, [{\n    key: \"computeWorldNormal\",\n    value: function computeWorldNormal(quat) {\n      var n = this.worldNormal;\n      n.set(0, 0, 1);\n      quat.vmult(n, n);\n      this.worldNormalNeedsUpdate = false;\n    }\n  }, {\n    key: \"calculateLocalInertia\",\n    value: function calculateLocalInertia(mass, target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      return target;\n    }\n  }, {\n    key: \"volume\",\n    value: function volume() {\n      return (\n        // The plane is infinite...\n        Number.MAX_VALUE\n      );\n    }\n  }, {\n    key: \"calculateWorldAABB\",\n    value: function calculateWorldAABB(pos, quat, min, max) {\n      // The plane AABB is infinite, except if the normal is pointing along any axis\n      tempNormal.set(0, 0, 1); // Default plane normal is z\n\n      quat.vmult(tempNormal, tempNormal);\n      var maxVal = Number.MAX_VALUE;\n      min.set(-maxVal, -maxVal, -maxVal);\n      max.set(maxVal, maxVal, maxVal);\n      if (tempNormal.x === 1) {\n        max.x = pos.x;\n      } else if (tempNormal.x === -1) {\n        min.x = pos.x;\n      }\n      if (tempNormal.y === 1) {\n        max.y = pos.y;\n      } else if (tempNormal.y === -1) {\n        min.y = pos.y;\n      }\n      if (tempNormal.z === 1) {\n        max.z = pos.z;\n      } else if (tempNormal.z === -1) {\n        min.z = pos.z;\n      }\n    }\n  }, {\n    key: \"updateBoundingSphereRadius\",\n    value: function updateBoundingSphereRadius() {\n      this.boundingSphereRadius = Number.MAX_VALUE;\n    }\n  }]);\n  return Plane;\n}(Shape$1);\nvar tempNormal = new Vec3$1();\n\n/**\n * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.\n * @todo Should be possible to use along all axes, not just y\n * @todo should be possible to scale along all axes\n * @todo Refactor elementSize to elementSizeX and elementSizeY\n *\n * @example\n *     // Generate some height data (y-values).\n *     const data = []\n *     for (let i = 0; i < 1000; i++) {\n *         const y = 0.5 * Math.cos(0.2 * i)\n *         data.push(y)\n *     }\n *\n *     // Create the heightfield shape\n *     const heightfieldShape = new CANNON.Heightfield(data, {\n *         elementSize: 1 // Distance between the data points in X and Y directions\n *     })\n *     const heightfieldBody = new CANNON.Body({ shape: heightfieldShape })\n *     world.addBody(heightfieldBody)\n */\nvar Heightfield = /*#__PURE__*/function (_Shape$6) {\n  _inherits(Heightfield, _Shape$6);\n  var _super9 = _createSuper(Heightfield);\n  /**\n   * An array of numbers, or height values, that are spread out along the x axis.\n   */\n\n  /**\n   * Max value of the data points in the data array.\n   */\n\n  /**\n   * Minimum value of the data points in the data array.\n   */\n\n  /**\n   * World spacing between the data points in X and Y direction.\n   * @todo elementSizeX and Y\n   * @default 1\n   */\n\n  /**\n   * @default true\n   */\n\n  /**\n   * @param data An array of numbers, or height values, that are spread out along the x axis.\n   */\n  function Heightfield(data, options) {\n    var _this9;\n    _classCallCheck(this, Heightfield);\n    if (options === void 0) {\n      options = {};\n    }\n    options = Utils.defaults(options, {\n      maxValue: null,\n      minValue: null,\n      elementSize: 1\n    });\n    _this9 = _super9.call(this, {\n      type: Shape$1.types.HEIGHTFIELD\n    });\n    _this9.data = data;\n    _this9.maxValue = options.maxValue;\n    _this9.minValue = options.minValue;\n    _this9.elementSize = options.elementSize;\n    if (options.minValue === null) {\n      _this9.updateMinValue();\n    }\n    if (options.maxValue === null) {\n      _this9.updateMaxValue();\n    }\n    _this9.cacheEnabled = true;\n    _this9.pillarConvex = new ConvexPolyhedron();\n    _this9.pillarOffset = new Vec3$1();\n    _this9.updateBoundingSphereRadius(); // \"i_j_isUpper\" => { convex: ..., offset: ... }\n    // for example:\n    // _cachedPillars[\"0_2_1\"]\n\n    _this9._cachedPillars = {};\n    return _this9;\n  }\n  /**\n   * Call whenever you change the data array.\n   */\n  _createClass(Heightfield, [{\n    key: \"update\",\n    value: function update() {\n      this._cachedPillars = {};\n    }\n    /**\n     * Update the `minValue` property\n     */\n  }, {\n    key: \"updateMinValue\",\n    value: function updateMinValue() {\n      var data = this.data;\n      var minValue = data[0][0];\n      for (var i = 0; i !== data.length; i++) {\n        for (var j = 0; j !== data[i].length; j++) {\n          var _v7 = data[i][j];\n          if (_v7 < minValue) {\n            minValue = _v7;\n          }\n        }\n      }\n      this.minValue = minValue;\n    }\n    /**\n     * Update the `maxValue` property\n     */\n  }, {\n    key: \"updateMaxValue\",\n    value: function updateMaxValue() {\n      var data = this.data;\n      var maxValue = data[0][0];\n      for (var i = 0; i !== data.length; i++) {\n        for (var j = 0; j !== data[i].length; j++) {\n          var _v8 = data[i][j];\n          if (_v8 > maxValue) {\n            maxValue = _v8;\n          }\n        }\n      }\n      this.maxValue = maxValue;\n    }\n    /**\n     * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.\n     */\n  }, {\n    key: \"setHeightValueAtIndex\",\n    value: function setHeightValueAtIndex(xi, yi, value) {\n      var data = this.data;\n      data[xi][yi] = value; // Invalidate cache\n\n      this.clearCachedConvexTrianglePillar(xi, yi, false);\n      if (xi > 0) {\n        this.clearCachedConvexTrianglePillar(xi - 1, yi, true);\n        this.clearCachedConvexTrianglePillar(xi - 1, yi, false);\n      }\n      if (yi > 0) {\n        this.clearCachedConvexTrianglePillar(xi, yi - 1, true);\n        this.clearCachedConvexTrianglePillar(xi, yi - 1, false);\n      }\n      if (yi > 0 && xi > 0) {\n        this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);\n      }\n    }\n    /**\n     * Get max/min in a rectangle in the matrix data\n     * @param result An array to store the results in.\n     * @return The result array, if it was passed in. Minimum will be at position 0 and max at 1.\n     */\n  }, {\n    key: \"getRectMinMax\",\n    value: function getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, result) {\n      if (result === void 0) {\n        result = [];\n      }\n\n      // Get max and min of the data\n      var data = this.data; // Set first value\n\n      var max = this.minValue;\n      for (var i = iMinX; i <= iMaxX; i++) {\n        for (var j = iMinY; j <= iMaxY; j++) {\n          var height = data[i][j];\n          if (height > max) {\n            max = height;\n          }\n        }\n      }\n      result[0] = this.minValue;\n      result[1] = max;\n    }\n    /**\n     * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.\n     * @param result Two-element array\n     * @param clamp If the position should be clamped to the heightfield edge.\n     */\n  }, {\n    key: \"getIndexOfPosition\",\n    value: function getIndexOfPosition(x, y, result, clamp) {\n      // Get the index of the data points to test against\n      var w = this.elementSize;\n      var data = this.data;\n      var xi = Math.floor(x / w);\n      var yi = Math.floor(y / w);\n      result[0] = xi;\n      result[1] = yi;\n      if (clamp) {\n        // Clamp index to edges\n        if (xi < 0) {\n          xi = 0;\n        }\n        if (yi < 0) {\n          yi = 0;\n        }\n        if (xi >= data.length - 1) {\n          xi = data.length - 1;\n        }\n        if (yi >= data[0].length - 1) {\n          yi = data[0].length - 1;\n        }\n      } // Bail out if we are out of the terrain\n\n      if (xi < 0 || yi < 0 || xi >= data.length - 1 || yi >= data[0].length - 1) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"getTriangleAt\",\n    value: function getTriangleAt(x, y, edgeClamp, a, b, c) {\n      var idx = getHeightAt_idx;\n      this.getIndexOfPosition(x, y, idx, edgeClamp);\n      var xi = idx[0];\n      var yi = idx[1];\n      var data = this.data;\n      if (edgeClamp) {\n        xi = Math.min(data.length - 2, Math.max(0, xi));\n        yi = Math.min(data[0].length - 2, Math.max(0, yi));\n      }\n      var elementSize = this.elementSize;\n      var lowerDist2 = Math.pow(x / elementSize - xi, 2) + Math.pow(y / elementSize - yi, 2);\n      var upperDist2 = Math.pow(x / elementSize - (xi + 1), 2) + Math.pow(y / elementSize - (yi + 1), 2);\n      var upper = lowerDist2 > upperDist2;\n      this.getTriangle(xi, yi, upper, a, b, c);\n      return upper;\n    }\n  }, {\n    key: \"getNormalAt\",\n    value: function getNormalAt(x, y, edgeClamp, result) {\n      var a = getNormalAt_a;\n      var b = getNormalAt_b;\n      var c = getNormalAt_c;\n      var e0 = getNormalAt_e0;\n      var e1 = getNormalAt_e1;\n      this.getTriangleAt(x, y, edgeClamp, a, b, c);\n      b.vsub(a, e0);\n      c.vsub(a, e1);\n      e0.cross(e1, result);\n      result.normalize();\n    }\n    /**\n     * Get an AABB of a square in the heightfield\n     * @param xi\n     * @param yi\n     * @param result\n     */\n  }, {\n    key: \"getAabbAtIndex\",\n    value: function getAabbAtIndex(xi, yi, _ref) {\n      var lowerBound = _ref.lowerBound,\n        upperBound = _ref.upperBound;\n      var data = this.data;\n      var elementSize = this.elementSize;\n      lowerBound.set(xi * elementSize, yi * elementSize, data[xi][yi]);\n      upperBound.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);\n    }\n    /**\n     * Get the height in the heightfield at a given position\n     */\n  }, {\n    key: \"getHeightAt\",\n    value: function getHeightAt(x, y, edgeClamp) {\n      var data = this.data;\n      var a = getHeightAt_a;\n      var b = getHeightAt_b;\n      var c = getHeightAt_c;\n      var idx = getHeightAt_idx;\n      this.getIndexOfPosition(x, y, idx, edgeClamp);\n      var xi = idx[0];\n      var yi = idx[1];\n      if (edgeClamp) {\n        xi = Math.min(data.length - 2, Math.max(0, xi));\n        yi = Math.min(data[0].length - 2, Math.max(0, yi));\n      }\n      var upper = this.getTriangleAt(x, y, edgeClamp, a, b, c);\n      barycentricWeights(x, y, a.x, a.y, b.x, b.y, c.x, c.y, getHeightAt_weights);\n      var w = getHeightAt_weights;\n      if (upper) {\n        // Top triangle verts\n        return data[xi + 1][yi + 1] * w.x + data[xi][yi + 1] * w.y + data[xi + 1][yi] * w.z;\n      } else {\n        // Top triangle verts\n        return data[xi][yi] * w.x + data[xi + 1][yi] * w.y + data[xi][yi + 1] * w.z;\n      }\n    }\n  }, {\n    key: \"getCacheConvexTrianglePillarKey\",\n    value: function getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle) {\n      return \"\".concat(xi, \"_\").concat(yi, \"_\").concat(getUpperTriangle ? 1 : 0);\n    }\n  }, {\n    key: \"getCachedConvexTrianglePillar\",\n    value: function getCachedConvexTrianglePillar(xi, yi, getUpperTriangle) {\n      return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];\n    }\n  }, {\n    key: \"setCachedConvexTrianglePillar\",\n    value: function setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, convex, offset) {\n      this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {\n        convex: convex,\n        offset: offset\n      };\n    }\n  }, {\n    key: \"clearCachedConvexTrianglePillar\",\n    value: function clearCachedConvexTrianglePillar(xi, yi, getUpperTriangle) {\n      delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];\n    }\n    /**\n     * Get a triangle from the heightfield\n     */\n  }, {\n    key: \"getTriangle\",\n    value: function getTriangle(xi, yi, upper, a, b, c) {\n      var data = this.data;\n      var elementSize = this.elementSize;\n      if (upper) {\n        // Top triangle verts\n        a.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);\n        b.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);\n        c.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);\n      } else {\n        // Top triangle verts\n        a.set(xi * elementSize, yi * elementSize, data[xi][yi]);\n        b.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);\n        c.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);\n      }\n    }\n    /**\n     * Get a triangle in the terrain in the form of a triangular convex shape.\n     */\n  }, {\n    key: \"getConvexTrianglePillar\",\n    value: function getConvexTrianglePillar(xi, yi, getUpperTriangle) {\n      var result = this.pillarConvex;\n      var offsetResult = this.pillarOffset;\n      if (this.cacheEnabled) {\n        var _data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);\n        if (_data) {\n          this.pillarConvex = _data.convex;\n          this.pillarOffset = _data.offset;\n          return;\n        }\n        result = new ConvexPolyhedron();\n        offsetResult = new Vec3$1();\n        this.pillarConvex = result;\n        this.pillarOffset = offsetResult;\n      }\n      var data = this.data;\n      var elementSize = this.elementSize;\n      var faces = result.faces; // Reuse verts if possible\n\n      result.vertices.length = 6;\n      for (var i = 0; i < 6; i++) {\n        if (!result.vertices[i]) {\n          result.vertices[i] = new Vec3$1();\n        }\n      } // Reuse faces if possible\n\n      faces.length = 5;\n      for (var _i9 = 0; _i9 < 5; _i9++) {\n        if (!faces[_i9]) {\n          faces[_i9] = [];\n        }\n      }\n      var verts = result.vertices;\n      var h = (Math.min(data[xi][yi], data[xi + 1][yi], data[xi][yi + 1], data[xi + 1][yi + 1]) - this.minValue) / 2 + this.minValue;\n      if (!getUpperTriangle) {\n        // Center of the triangle pillar - all polygons are given relative to this one\n        offsetResult.set((xi + 0.25) * elementSize,\n        // sort of center of a triangle\n        (yi + 0.25) * elementSize, h // vertical center\n        ); // Top triangle verts\n\n        verts[0].set(-0.25 * elementSize, -0.25 * elementSize, data[xi][yi] - h);\n        verts[1].set(0.75 * elementSize, -0.25 * elementSize, data[xi + 1][yi] - h);\n        verts[2].set(-0.25 * elementSize, 0.75 * elementSize, data[xi][yi + 1] - h); // bottom triangle verts\n\n        verts[3].set(-0.25 * elementSize, -0.25 * elementSize, -Math.abs(h) - 1);\n        verts[4].set(0.75 * elementSize, -0.25 * elementSize, -Math.abs(h) - 1);\n        verts[5].set(-0.25 * elementSize, 0.75 * elementSize, -Math.abs(h) - 1); // top triangle\n\n        faces[0][0] = 0;\n        faces[0][1] = 1;\n        faces[0][2] = 2; // bottom triangle\n\n        faces[1][0] = 5;\n        faces[1][1] = 4;\n        faces[1][2] = 3; // -x facing quad\n\n        faces[2][0] = 0;\n        faces[2][1] = 2;\n        faces[2][2] = 5;\n        faces[2][3] = 3; // -y facing quad\n\n        faces[3][0] = 1;\n        faces[3][1] = 0;\n        faces[3][2] = 3;\n        faces[3][3] = 4; // +xy facing quad\n\n        faces[4][0] = 4;\n        faces[4][1] = 5;\n        faces[4][2] = 2;\n        faces[4][3] = 1;\n      } else {\n        // Center of the triangle pillar - all polygons are given relative to this one\n        offsetResult.set((xi + 0.75) * elementSize,\n        // sort of center of a triangle\n        (yi + 0.75) * elementSize, h // vertical center\n        ); // Top triangle verts\n\n        verts[0].set(0.25 * elementSize, 0.25 * elementSize, data[xi + 1][yi + 1] - h);\n        verts[1].set(-0.75 * elementSize, 0.25 * elementSize, data[xi][yi + 1] - h);\n        verts[2].set(0.25 * elementSize, -0.75 * elementSize, data[xi + 1][yi] - h); // bottom triangle verts\n\n        verts[3].set(0.25 * elementSize, 0.25 * elementSize, -Math.abs(h) - 1);\n        verts[4].set(-0.75 * elementSize, 0.25 * elementSize, -Math.abs(h) - 1);\n        verts[5].set(0.25 * elementSize, -0.75 * elementSize, -Math.abs(h) - 1); // Top triangle\n\n        faces[0][0] = 0;\n        faces[0][1] = 1;\n        faces[0][2] = 2; // bottom triangle\n\n        faces[1][0] = 5;\n        faces[1][1] = 4;\n        faces[1][2] = 3; // +x facing quad\n\n        faces[2][0] = 2;\n        faces[2][1] = 5;\n        faces[2][2] = 3;\n        faces[2][3] = 0; // +y facing quad\n\n        faces[3][0] = 3;\n        faces[3][1] = 4;\n        faces[3][2] = 1;\n        faces[3][3] = 0; // -xy facing quad\n\n        faces[4][0] = 1;\n        faces[4][1] = 4;\n        faces[4][2] = 5;\n        faces[4][3] = 2;\n      }\n      result.computeNormals();\n      result.computeEdges();\n      result.updateBoundingSphereRadius();\n      this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);\n    }\n  }, {\n    key: \"calculateLocalInertia\",\n    value: function calculateLocalInertia(mass, target) {\n      if (target === void 0) {\n        target = new Vec3$1();\n      }\n      target.set(0, 0, 0);\n      return target;\n    }\n  }, {\n    key: \"volume\",\n    value: function volume() {\n      return (\n        // The terrain is infinite\n        Number.MAX_VALUE\n      );\n    }\n  }, {\n    key: \"calculateWorldAABB\",\n    value: function calculateWorldAABB(pos, quat, min, max) {\n      /** @TODO do it properly */\n      min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n      max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    }\n  }, {\n    key: \"updateBoundingSphereRadius\",\n    value: function updateBoundingSphereRadius() {\n      // Use the bounding box of the min/max values\n      var data = this.data;\n      var s = this.elementSize;\n      this.boundingSphereRadius = new Vec3$1(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).length();\n    }\n    /**\n     * Sets the height values from an image. Currently only supported in browser.\n     */\n  }, {\n    key: \"setHeightsFromImage\",\n    value: function setHeightsFromImage(image, scale) {\n      var x = scale.x,\n        z = scale.z,\n        y = scale.y;\n      var canvas = document.createElement('canvas');\n      canvas.width = image.width;\n      canvas.height = image.height;\n      var context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0);\n      var imageData = context.getImageData(0, 0, image.width, image.height);\n      var matrix = this.data;\n      matrix.length = 0;\n      this.elementSize = Math.abs(x) / imageData.width;\n      for (var i = 0; i < imageData.height; i++) {\n        var row = [];\n        for (var j = 0; j < imageData.width; j++) {\n          var _a3 = imageData.data[(i * imageData.height + j) * 4];\n          var _b3 = imageData.data[(i * imageData.height + j) * 4 + 1];\n          var _c = imageData.data[(i * imageData.height + j) * 4 + 2];\n          var height = (_a3 + _b3 + _c) / 4 / 255 * z;\n          if (x < 0) {\n            row.push(height);\n          } else {\n            row.unshift(height);\n          }\n        }\n        if (y < 0) {\n          matrix.unshift(row);\n        } else {\n          matrix.push(row);\n        }\n      }\n      this.updateMaxValue();\n      this.updateMinValue();\n      this.update();\n    }\n  }]);\n  return Heightfield;\n}(Shape$1);\nvar getHeightAt_idx = [];\nvar getHeightAt_weights = new Vec3$1();\nvar getHeightAt_a = new Vec3$1();\nvar getHeightAt_b = new Vec3$1();\nvar getHeightAt_c = new Vec3$1();\nvar getNormalAt_a = new Vec3$1();\nvar getNormalAt_b = new Vec3$1();\nvar getNormalAt_c = new Vec3$1();\nvar getNormalAt_e0 = new Vec3$1();\nvar getNormalAt_e1 = new Vec3$1(); // from https://en.wikipedia.org/wiki/Barycentric_coordinate_system\n\nfunction barycentricWeights(x, y, ax, ay, bx, by, cx, cy, result) {\n  result.x = ((by - cy) * (x - cx) + (cx - bx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));\n  result.y = ((cy - ay) * (x - cx) + (ax - cx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));\n  result.z = 1 - result.x - result.y;\n}\n\n/**\n * OctreeNode\n */\nvar OctreeNode = /*#__PURE__*/function () {\n  /** The root node */\n\n  /** Boundary of this node */\n\n  /** Contained data at the current node level */\n\n  /** Children to this node */\n  function OctreeNode(options) {\n    _classCallCheck(this, OctreeNode);\n    if (options === void 0) {\n      options = {};\n    }\n    this.root = options.root || null;\n    this.aabb = options.aabb ? options.aabb.clone() : new AABB$1();\n    this.data = [];\n    this.children = [];\n  }\n  /**\n   * reset\n   */\n  _createClass(OctreeNode, [{\n    key: \"reset\",\n    value: function reset() {\n      this.children.length = this.data.length = 0;\n    }\n    /**\n     * Insert data into this node\n     * @return True if successful, otherwise false\n     */\n  }, {\n    key: \"insert\",\n    value: function insert(aabb, elementData, level) {\n      if (level === void 0) {\n        level = 0;\n      }\n      var nodeData = this.data; // Ignore objects that do not belong in this node\n\n      if (!this.aabb.contains(aabb)) {\n        return false; // object cannot be added\n      }\n\n      var children = this.children;\n      var maxDepth = this.maxDepth || this.root.maxDepth;\n      if (level < maxDepth) {\n        // Subdivide if there are no children yet\n        var subdivided = false;\n        if (!children.length) {\n          this.subdivide();\n          subdivided = true;\n        } // add to whichever node will accept it\n\n        for (var i = 0; i !== 8; i++) {\n          if (children[i].insert(aabb, elementData, level + 1)) {\n            return true;\n          }\n        }\n        if (subdivided) {\n          // No children accepted! Might as well just remove em since they contain none\n          children.length = 0;\n        }\n      } // Too deep, or children didnt want it. add it in current node\n\n      nodeData.push(elementData);\n      return true;\n    }\n    /**\n     * Create 8 equally sized children nodes and put them in the `children` array.\n     */\n  }, {\n    key: \"subdivide\",\n    value: function subdivide() {\n      var aabb = this.aabb;\n      var l = aabb.lowerBound;\n      var u = aabb.upperBound;\n      var children = this.children;\n      children.push(new OctreeNode({\n        aabb: new AABB$1({\n          lowerBound: new Vec3$1(0, 0, 0)\n        })\n      }), new OctreeNode({\n        aabb: new AABB$1({\n          lowerBound: new Vec3$1(1, 0, 0)\n        })\n      }), new OctreeNode({\n        aabb: new AABB$1({\n          lowerBound: new Vec3$1(1, 1, 0)\n        })\n      }), new OctreeNode({\n        aabb: new AABB$1({\n          lowerBound: new Vec3$1(1, 1, 1)\n        })\n      }), new OctreeNode({\n        aabb: new AABB$1({\n          lowerBound: new Vec3$1(0, 1, 1)\n        })\n      }), new OctreeNode({\n        aabb: new AABB$1({\n          lowerBound: new Vec3$1(0, 0, 1)\n        })\n      }), new OctreeNode({\n        aabb: new AABB$1({\n          lowerBound: new Vec3$1(1, 0, 1)\n        })\n      }), new OctreeNode({\n        aabb: new AABB$1({\n          lowerBound: new Vec3$1(0, 1, 0)\n        })\n      }));\n      u.vsub(l, halfDiagonal);\n      halfDiagonal.scale(0.5, halfDiagonal);\n      var root = this.root || this;\n      for (var i = 0; i !== 8; i++) {\n        var child = children[i]; // Set current node as root\n\n        child.root = root; // Compute bounds\n\n        var lowerBound = child.aabb.lowerBound;\n        lowerBound.x *= halfDiagonal.x;\n        lowerBound.y *= halfDiagonal.y;\n        lowerBound.z *= halfDiagonal.z;\n        lowerBound.vadd(l, lowerBound); // Upper bound is always lower bound + halfDiagonal\n\n        lowerBound.vadd(halfDiagonal, child.aabb.upperBound);\n      }\n    }\n    /**\n     * Get all data, potentially within an AABB\n     * @return The \"result\" object\n     */\n  }, {\n    key: \"aabbQuery\",\n    value: function aabbQuery(aabb, result) {\n      this.data; // abort if the range does not intersect this node\n      // if (!this.aabb.overlaps(aabb)){\n      //     return result;\n      // }\n      // Add objects at this level\n      // Array.prototype.push.apply(result, nodeData);\n      // Add child data\n      // @todo unwrap recursion into a queue / loop, that's faster in JS\n\n      this.children; // for (let i = 0, N = this.children.length; i !== N; i++) {\n      //     children[i].aabbQuery(aabb, result);\n      // }\n\n      var queue = [this];\n      while (queue.length) {\n        var node = queue.pop();\n        if (node.aabb.overlaps(aabb)) {\n          Array.prototype.push.apply(result, node.data);\n        }\n        Array.prototype.push.apply(queue, node.children);\n      }\n      return result;\n    }\n    /**\n     * Get all data, potentially intersected by a ray.\n     * @return The \"result\" object\n     */\n  }, {\n    key: \"rayQuery\",\n    value: function rayQuery(ray, treeTransform, result) {\n      // Use aabb query for now.\n\n      /** @todo implement real ray query which needs less lookups */\n      ray.getAABB(tmpAABB);\n      tmpAABB.toLocalFrame(treeTransform, tmpAABB);\n      this.aabbQuery(tmpAABB, result);\n      return result;\n    }\n    /**\n     * removeEmptyNodes\n     */\n  }, {\n    key: \"removeEmptyNodes\",\n    value: function removeEmptyNodes() {\n      for (var i = this.children.length - 1; i >= 0; i--) {\n        this.children[i].removeEmptyNodes();\n        if (!this.children[i].children.length && !this.children[i].data.length) {\n          this.children.splice(i, 1);\n        }\n      }\n    }\n  }]);\n  return OctreeNode;\n}();\n/**\n * Octree\n */\nvar Octree = /*#__PURE__*/function (_OctreeNode) {\n  _inherits(Octree, _OctreeNode);\n  var _super10 = _createSuper(Octree);\n  /**\n   * Maximum subdivision depth\n   * @default 8\n   */\n\n  /**\n   * @param aabb The total AABB of the tree\n   */\n  function Octree(aabb, options) {\n    var _this10;\n    _classCallCheck(this, Octree);\n    if (options === void 0) {\n      options = {};\n    }\n    _this10 = _super10.call(this, {\n      root: null,\n      aabb: aabb\n    });\n    _this10.maxDepth = typeof options.maxDepth !== 'undefined' ? options.maxDepth : 8;\n    return _this10;\n  }\n  return _createClass(Octree);\n}(OctreeNode);\nvar halfDiagonal = new Vec3$1();\nvar tmpAABB = new AABB$1();\n\n/**\n * Trimesh.\n * @example\n *     // How to make a mesh with a single triangle\n *     const vertices = [\n *         0, 0, 0, // vertex 0\n *         1, 0, 0, // vertex 1\n *         0, 1, 0  // vertex 2\n *     ]\n *     const indices = [\n *         0, 1, 2  // triangle 0\n *     ]\n *     const trimeshShape = new CANNON.Trimesh(vertices, indices)\n */\nvar Trimesh = /*#__PURE__*/function (_Shape$7) {\n  _inherits(Trimesh, _Shape$7);\n  var _super11 = _createSuper(Trimesh);\n  /**\n   * vertices\n   */\n\n  /**\n   * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.\n   */\n\n  /**\n   * The normals data.\n   */\n\n  /**\n   * The local AABB of the mesh.\n   */\n\n  /**\n   * References to vertex pairs, making up all unique edges in the trimesh.\n   */\n\n  /**\n   * Local scaling of the mesh. Use .setScale() to set it.\n   */\n\n  /**\n   * The indexed triangles. Use .updateTree() to update it.\n   */\n  function Trimesh(vertices, indices) {\n    var _this11;\n    _classCallCheck(this, Trimesh);\n    _this11 = _super11.call(this, {\n      type: Shape$1.types.TRIMESH\n    });\n    _this11.vertices = new Float32Array(vertices);\n    _this11.indices = new Int16Array(indices);\n    _this11.normals = new Float32Array(indices.length);\n    _this11.aabb = new AABB$1();\n    _this11.edges = null;\n    _this11.scale = new Vec3$1(1, 1, 1);\n    _this11.tree = new Octree();\n    _this11.updateEdges();\n    _this11.updateNormals();\n    _this11.updateAABB();\n    _this11.updateBoundingSphereRadius();\n    _this11.updateTree();\n    return _this11;\n  }\n  /**\n   * updateTree\n   */\n  _createClass(Trimesh, [{\n    key: \"updateTree\",\n    value: function updateTree() {\n      var tree = this.tree;\n      tree.reset();\n      tree.aabb.copy(this.aabb);\n      var scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled\n\n      tree.aabb.lowerBound.x *= 1 / scale.x;\n      tree.aabb.lowerBound.y *= 1 / scale.y;\n      tree.aabb.lowerBound.z *= 1 / scale.z;\n      tree.aabb.upperBound.x *= 1 / scale.x;\n      tree.aabb.upperBound.y *= 1 / scale.y;\n      tree.aabb.upperBound.z *= 1 / scale.z; // Insert all triangles\n\n      var triangleAABB = new AABB$1();\n      var a = new Vec3$1();\n      var b = new Vec3$1();\n      var c = new Vec3$1();\n      var points = [a, b, c];\n      for (var i = 0; i < this.indices.length / 3; i++) {\n        //this.getTriangleVertices(i, a, b, c);\n        // Get unscaled triangle verts\n        var i3 = i * 3;\n        this._getUnscaledVertex(this.indices[i3], a);\n        this._getUnscaledVertex(this.indices[i3 + 1], b);\n        this._getUnscaledVertex(this.indices[i3 + 2], c);\n        triangleAABB.setFromPoints(points);\n        tree.insert(triangleAABB, i);\n      }\n      tree.removeEmptyNodes();\n    }\n    /**\n     * Get triangles in a local AABB from the trimesh.\n     * @param result An array of integers, referencing the queried triangles.\n     */\n  }, {\n    key: \"getTrianglesInAABB\",\n    value: function getTrianglesInAABB(aabb, result) {\n      unscaledAABB.copy(aabb); // Scale it to local\n\n      var scale = this.scale;\n      var isx = scale.x;\n      var isy = scale.y;\n      var isz = scale.z;\n      var l = unscaledAABB.lowerBound;\n      var u = unscaledAABB.upperBound;\n      l.x /= isx;\n      l.y /= isy;\n      l.z /= isz;\n      u.x /= isx;\n      u.y /= isy;\n      u.z /= isz;\n      return this.tree.aabbQuery(unscaledAABB, result);\n    }\n    /**\n     * setScale\n     */\n  }, {\n    key: \"setScale\",\n    value: function setScale(scale) {\n      var wasUniform = this.scale.x === this.scale.y && this.scale.y === this.scale.z;\n      var isUniform = scale.x === scale.y && scale.y === scale.z;\n      if (!(wasUniform && isUniform)) {\n        // Non-uniform scaling. Need to update normals.\n        this.updateNormals();\n      }\n      this.scale.copy(scale);\n      this.updateAABB();\n      this.updateBoundingSphereRadius();\n    }\n    /**\n     * Compute the normals of the faces. Will save in the `.normals` array.\n     */\n  }, {\n    key: \"updateNormals\",\n    value: function updateNormals() {\n      var n = computeNormals_n; // Generate normals\n\n      var normals = this.normals;\n      for (var i = 0; i < this.indices.length / 3; i++) {\n        var i3 = i * 3;\n        var _a4 = this.indices[i3];\n        var _b4 = this.indices[i3 + 1];\n        var _c2 = this.indices[i3 + 2];\n        this.getVertex(_a4, va);\n        this.getVertex(_b4, vb);\n        this.getVertex(_c2, vc);\n        Trimesh.computeNormal(vb, va, vc, n);\n        normals[i3] = n.x;\n        normals[i3 + 1] = n.y;\n        normals[i3 + 2] = n.z;\n      }\n    }\n    /**\n     * Update the `.edges` property\n     */\n  }, {\n    key: \"updateEdges\",\n    value: function updateEdges() {\n      var edges = {};\n      var add = function add(a, b) {\n        var key = a < b ? \"\".concat(a, \"_\").concat(b) : \"\".concat(b, \"_\").concat(a);\n        edges[key] = true;\n      };\n      for (var i = 0; i < this.indices.length / 3; i++) {\n        var i3 = i * 3;\n        var _a5 = this.indices[i3];\n        var _b5 = this.indices[i3 + 1];\n        var _c3 = this.indices[i3 + 2];\n        add(_a5, _b5);\n        add(_b5, _c3);\n        add(_c3, _a5);\n      }\n      var keys = Object.keys(edges);\n      this.edges = new Int16Array(keys.length * 2);\n      for (var _i10 = 0; _i10 < keys.length; _i10++) {\n        var indices = keys[_i10].split('_');\n        this.edges[2 * _i10] = parseInt(indices[0], 10);\n        this.edges[2 * _i10 + 1] = parseInt(indices[1], 10);\n      }\n    }\n    /**\n     * Get an edge vertex\n     * @param firstOrSecond 0 or 1, depending on which one of the vertices you need.\n     * @param vertexStore Where to store the result\n     */\n  }, {\n    key: \"getEdgeVertex\",\n    value: function getEdgeVertex(edgeIndex, firstOrSecond, vertexStore) {\n      var vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];\n      this.getVertex(vertexIndex, vertexStore);\n    }\n    /**\n     * Get a vector along an edge.\n     */\n  }, {\n    key: \"getEdgeVector\",\n    value: function getEdgeVector(edgeIndex, vectorStore) {\n      var va = getEdgeVector_va;\n      var vb = getEdgeVector_vb;\n      this.getEdgeVertex(edgeIndex, 0, va);\n      this.getEdgeVertex(edgeIndex, 1, vb);\n      vb.vsub(va, vectorStore);\n    }\n    /**\n     * Get face normal given 3 vertices\n     */\n  }, {\n    key: \"getVertex\",\n    value:\n    /**\n     * Get vertex i.\n     * @return The \"out\" vector object\n     */\n\n    function getVertex(i, out) {\n      var scale = this.scale;\n      this._getUnscaledVertex(i, out);\n      out.x *= scale.x;\n      out.y *= scale.y;\n      out.z *= scale.z;\n      return out;\n    }\n    /**\n     * Get raw vertex i\n     * @return The \"out\" vector object\n     */\n  }, {\n    key: \"_getUnscaledVertex\",\n    value: function _getUnscaledVertex(i, out) {\n      var i3 = i * 3;\n      var vertices = this.vertices;\n      return out.set(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);\n    }\n    /**\n     * Get a vertex from the trimesh,transformed by the given position and quaternion.\n     * @return The \"out\" vector object\n     */\n  }, {\n    key: \"getWorldVertex\",\n    value: function getWorldVertex(i, pos, quat, out) {\n      this.getVertex(i, out);\n      Transform$1.pointToWorldFrame(pos, quat, out, out);\n      return out;\n    }\n    /**\n     * Get the three vertices for triangle i.\n     */\n  }, {\n    key: \"getTriangleVertices\",\n    value: function getTriangleVertices(i, a, b, c) {\n      var i3 = i * 3;\n      this.getVertex(this.indices[i3], a);\n      this.getVertex(this.indices[i3 + 1], b);\n      this.getVertex(this.indices[i3 + 2], c);\n    }\n    /**\n     * Compute the normal of triangle i.\n     * @return The \"target\" vector object\n     */\n  }, {\n    key: \"getNormal\",\n    value: function getNormal(i, target) {\n      var i3 = i * 3;\n      return target.set(this.normals[i3], this.normals[i3 + 1], this.normals[i3 + 2]);\n    }\n    /**\n     * @return The \"target\" vector object\n     */\n  }, {\n    key: \"calculateLocalInertia\",\n    value: function calculateLocalInertia(mass, target) {\n      // Approximate with box inertia\n      // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it\n      this.computeLocalAABB(cli_aabb);\n      var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x;\n      var y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y;\n      var z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;\n      return target.set(1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x));\n    }\n    /**\n     * Compute the local AABB for the trimesh\n     */\n  }, {\n    key: \"computeLocalAABB\",\n    value: function computeLocalAABB(aabb) {\n      var l = aabb.lowerBound;\n      var u = aabb.upperBound;\n      var n = this.vertices.length;\n      this.vertices;\n      var v = computeLocalAABB_worldVert;\n      this.getVertex(0, v);\n      l.copy(v);\n      u.copy(v);\n      for (var i = 0; i !== n; i++) {\n        this.getVertex(i, v);\n        if (v.x < l.x) {\n          l.x = v.x;\n        } else if (v.x > u.x) {\n          u.x = v.x;\n        }\n        if (v.y < l.y) {\n          l.y = v.y;\n        } else if (v.y > u.y) {\n          u.y = v.y;\n        }\n        if (v.z < l.z) {\n          l.z = v.z;\n        } else if (v.z > u.z) {\n          u.z = v.z;\n        }\n      }\n    }\n    /**\n     * Update the `.aabb` property\n     */\n  }, {\n    key: \"updateAABB\",\n    value: function updateAABB() {\n      this.computeLocalAABB(this.aabb);\n    }\n    /**\n     * Will update the `.boundingSphereRadius` property\n     */\n  }, {\n    key: \"updateBoundingSphereRadius\",\n    value: function updateBoundingSphereRadius() {\n      // Assume points are distributed with local (0,0,0) as center\n      var max2 = 0;\n      var vertices = this.vertices;\n      var v = new Vec3$1();\n      for (var i = 0, N = vertices.length / 3; i !== N; i++) {\n        this.getVertex(i, v);\n        var norm2 = v.lengthSquared();\n        if (norm2 > max2) {\n          max2 = norm2;\n        }\n      }\n      this.boundingSphereRadius = Math.sqrt(max2);\n    }\n    /**\n     * calculateWorldAABB\n     */\n  }, {\n    key: \"calculateWorldAABB\",\n    value: function calculateWorldAABB(pos, quat, min, max) {\n      /*\n          const n = this.vertices.length / 3,\n              verts = this.vertices;\n          const minx,miny,minz,maxx,maxy,maxz;\n           const v = tempWorldVertex;\n          for(let i=0; i<n; i++){\n              this.getVertex(i, v);\n              quat.vmult(v, v);\n              pos.vadd(v, v);\n              if (v.x < minx || minx===undefined){\n                  minx = v.x;\n              } else if(v.x > maxx || maxx===undefined){\n                  maxx = v.x;\n              }\n               if (v.y < miny || miny===undefined){\n                  miny = v.y;\n              } else if(v.y > maxy || maxy===undefined){\n                  maxy = v.y;\n              }\n               if (v.z < minz || minz===undefined){\n                  minz = v.z;\n              } else if(v.z > maxz || maxz===undefined){\n                  maxz = v.z;\n              }\n          }\n          min.set(minx,miny,minz);\n          max.set(maxx,maxy,maxz);\n          */\n      // Faster approximation using local AABB\n      var frame = calculateWorldAABB_frame;\n      var result = calculateWorldAABB_aabb;\n      frame.position = pos;\n      frame.quaternion = quat;\n      this.aabb.toWorldFrame(frame, result);\n      min.copy(result.lowerBound);\n      max.copy(result.upperBound);\n    }\n    /**\n     * Get approximate volume\n     */\n  }, {\n    key: \"volume\",\n    value: function volume() {\n      return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;\n    }\n    /**\n     * Create a Trimesh instance, shaped as a torus.\n     */\n  }], [{\n    key: \"computeNormal\",\n    value: function computeNormal(va, vb, vc, target) {\n      vb.vsub(va, ab);\n      vc.vsub(vb, cb);\n      cb.cross(ab, target);\n      if (!target.isZero()) {\n        target.normalize();\n      }\n    }\n  }, {\n    key: \"createTorus\",\n    value: function createTorus(radius, tube, radialSegments, tubularSegments, arc) {\n      if (radius === void 0) {\n        radius = 1;\n      }\n      if (tube === void 0) {\n        tube = 0.5;\n      }\n      if (radialSegments === void 0) {\n        radialSegments = 8;\n      }\n      if (tubularSegments === void 0) {\n        tubularSegments = 6;\n      }\n      if (arc === void 0) {\n        arc = Math.PI * 2;\n      }\n      var vertices = [];\n      var indices = [];\n      for (var j = 0; j <= radialSegments; j++) {\n        for (var i = 0; i <= tubularSegments; i++) {\n          var u = i / tubularSegments * arc;\n          var _v9 = j / radialSegments * Math.PI * 2;\n          var x = (radius + tube * Math.cos(_v9)) * Math.cos(u);\n          var y = (radius + tube * Math.cos(_v9)) * Math.sin(u);\n          var z = tube * Math.sin(_v9);\n          vertices.push(x, y, z);\n        }\n      }\n      for (var _j2 = 1; _j2 <= radialSegments; _j2++) {\n        for (var _i11 = 1; _i11 <= tubularSegments; _i11++) {\n          var _a6 = (tubularSegments + 1) * _j2 + _i11 - 1;\n          var _b6 = (tubularSegments + 1) * (_j2 - 1) + _i11 - 1;\n          var _c4 = (tubularSegments + 1) * (_j2 - 1) + _i11;\n          var d = (tubularSegments + 1) * _j2 + _i11;\n          indices.push(_a6, _b6, d);\n          indices.push(_b6, _c4, d);\n        }\n      }\n      return new Trimesh(vertices, indices);\n    }\n  }]);\n  return Trimesh;\n}(Shape$1);\nvar computeNormals_n = new Vec3$1();\nvar unscaledAABB = new AABB$1();\nvar getEdgeVector_va = new Vec3$1();\nvar getEdgeVector_vb = new Vec3$1();\nvar cb = new Vec3$1();\nvar ab = new Vec3$1();\nvar va = new Vec3$1();\nvar vb = new Vec3$1();\nvar vc = new Vec3$1();\nvar cli_aabb = new AABB$1();\nvar computeLocalAABB_worldVert = new Vec3$1();\nvar calculateWorldAABB_frame = new Transform$1();\nvar calculateWorldAABB_aabb = new AABB$1();\n\n// Naming rule: based of the order in SHAPE_TYPES,\n// the first part of the method is formed by the\n// shape type that comes before, in the second part\n// there is the shape type that comes after in the SHAPE_TYPES list\n({\n  sphereSphere: Shape$1.types.SPHERE,\n  spherePlane: Shape$1.types.SPHERE | Shape$1.types.PLANE,\n  boxBox: Shape$1.types.BOX | Shape$1.types.BOX,\n  sphereBox: Shape$1.types.SPHERE | Shape$1.types.BOX,\n  planeBox: Shape$1.types.PLANE | Shape$1.types.BOX,\n  convexConvex: Shape$1.types.CONVEXPOLYHEDRON,\n  sphereConvex: Shape$1.types.SPHERE | Shape$1.types.CONVEXPOLYHEDRON,\n  planeConvex: Shape$1.types.PLANE | Shape$1.types.CONVEXPOLYHEDRON,\n  boxConvex: Shape$1.types.BOX | Shape$1.types.CONVEXPOLYHEDRON,\n  sphereHeightfield: Shape$1.types.SPHERE | Shape$1.types.HEIGHTFIELD,\n  boxHeightfield: Shape$1.types.BOX | Shape$1.types.HEIGHTFIELD,\n  convexHeightfield: Shape$1.types.CONVEXPOLYHEDRON | Shape$1.types.HEIGHTFIELD,\n  sphereParticle: Shape$1.types.PARTICLE | Shape$1.types.SPHERE,\n  planeParticle: Shape$1.types.PLANE | Shape$1.types.PARTICLE,\n  boxParticle: Shape$1.types.BOX | Shape$1.types.PARTICLE,\n  convexParticle: Shape$1.types.PARTICLE | Shape$1.types.CONVEXPOLYHEDRON,\n  cylinderCylinder: Shape$1.types.CYLINDER,\n  sphereCylinder: Shape$1.types.SPHERE | Shape$1.types.CYLINDER,\n  planeCylinder: Shape$1.types.PLANE | Shape$1.types.CYLINDER,\n  boxCylinder: Shape$1.types.BOX | Shape$1.types.CYLINDER,\n  convexCylinder: Shape$1.types.CONVEXPOLYHEDRON | Shape$1.types.CYLINDER,\n  heightfieldCylinder: Shape$1.types.HEIGHTFIELD | Shape$1.types.CYLINDER,\n  particleCylinder: Shape$1.types.PARTICLE | Shape$1.types.CYLINDER,\n  sphereTrimesh: Shape$1.types.SPHERE | Shape$1.types.TRIMESH,\n  planeTrimesh: Shape$1.types.PLANE | Shape$1.types.TRIMESH\n});\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Quaternion$1();\nnew Quaternion$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew AABB$1();\nnew Vec3$1();\nnew Vec3$1(); // See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html\n\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\n[new Vec3$1(), new Vec3$1(), new Vec3$1(), new Vec3$1(), new Vec3$1(), new Vec3$1()];\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1(); // WIP\n\nnew Quaternion$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew Vec3$1();\nnew AABB$1();\nnew Ray$1(); // performance.now() fallback on Date.now()\n\nvar performance$1 = globalThis.performance || {};\nif (!performance$1.now) {\n  var nowOffset = Date.now();\n  if (performance$1.timing && performance$1.timing.navigationStart) {\n    nowOffset = performance$1.timing.navigationStart;\n  }\n  performance$1.now = function () {\n    return Date.now() - nowOffset;\n  };\n}\nnew Vec3$1(); // Dispatched after the world has stepped forward in time.\n\n/**\n * @typedef { import('cannon-es').MaterialOptions } MaterialOptions\n */\n\nvar makeVec3 = function makeVec3(_ref) {\n  var _ref55 = _slicedToArray(_ref, 3),\n    x = _ref55[0],\n    y = _ref55[1],\n    z = _ref55[2];\n  return new Vec3$1(x, y, z);\n};\nvar prepareSphere = function prepareSphere(args) {\n  return Array.isArray(args) ? args : [args];\n};\nvar prepareConvexPolyhedron = function prepareConvexPolyhedron(_ref2) {\n  var _ref56 = _slicedToArray(_ref2, 5),\n    v = _ref56[0],\n    faces = _ref56[1],\n    n = _ref56[2],\n    a = _ref56[3],\n    boundingSphereRadius = _ref56[4];\n  return [{\n    axes: a ? a.map(makeVec3) : undefined,\n    boundingSphereRadius: boundingSphereRadius,\n    faces: faces,\n    normals: n ? n.map(makeVec3) : undefined,\n    vertices: v ? v.map(makeVec3) : undefined\n  }];\n};\nfunction createShape(type, args) {\n  switch (type) {\n    case 'Box':\n      return new Box(_construct(Vec3$1, _toConsumableArray(args.map(function (v) {\n        return v / 2;\n      }))));\n    // extents => halfExtents\n    case 'ConvexPolyhedron':\n      return _construct(ConvexPolyhedron, _toConsumableArray(prepareConvexPolyhedron(args)));\n    case 'Cylinder':\n      return _construct(Cylinder, _toConsumableArray(args));\n    // [ radiusTop, radiusBottom, height, numSegments ] = args\n    case 'Heightfield':\n      return _construct(Heightfield, _toConsumableArray(args));\n    // [ Array data, options: {minValue, maxValue, elementSize}  ] = args\n    case 'Particle':\n      return new Particle();\n    // no args\n    case 'Plane':\n      return new Plane();\n    // no args, infinite x and y\n    case 'Sphere':\n      return _construct(Sphere, _toConsumableArray(prepareSphere(args)));\n    // radius = args\n    case 'Trimesh':\n      return _construct(Trimesh, _toConsumableArray(args));\n    // [vertices, indices] = args\n  }\n}\n\n/**\n * @function\n * @param {Object} options\n * @param {string} options.uuid\n * @param {BodyProps} options.props\n * @param {BodyShapeType} options.type\n * @param {(materialOptions: MaterialOptions) => Material =} options.createMaterial\n * @returns {Body}\n */\nvar propsToBody = function propsToBody(options) {\n  var uuid = options.uuid,\n    props = options.props,\n    type = options.type,\n    _options$createMateri = options.createMaterial,\n    createMaterial = _options$createMateri === void 0 ? function (materialOptions) {\n      return new Material(materialOptions);\n    } : _options$createMateri;\n  var _props$angularFactor = props.angularFactor,\n    angularFactor = _props$angularFactor === void 0 ? [1, 1, 1] : _props$angularFactor,\n    _props$angularVelocit = props.angularVelocity,\n    angularVelocity = _props$angularVelocit === void 0 ? [0, 0, 0] : _props$angularVelocit,\n    _props$args = props.args,\n    args = _props$args === void 0 ? [] : _props$args,\n    collisionResponse = props.collisionResponse,\n    _props$linearFactor = props.linearFactor,\n    linearFactor = _props$linearFactor === void 0 ? [1, 1, 1] : _props$linearFactor,\n    mass = props.mass,\n    material = props.material,\n    onCollide = props.onCollide,\n    _props$position = props.position,\n    position = _props$position === void 0 ? [0, 0, 0] : _props$position,\n    _props$rotation = props.rotation,\n    rotation = _props$rotation === void 0 ? [0, 0, 0] : _props$rotation,\n    shapes = props.shapes,\n    bodyType = props.type,\n    _props$velocity = props.velocity,\n    velocity = _props$velocity === void 0 ? [0, 0, 0] : _props$velocity,\n    extra = _objectWithoutProperties(props, _excluded);\n  var body = new Body(_objectSpread(_objectSpread({}, extra), {}, {\n    mass: bodyType === 'Static' ? 0 : mass,\n    material: material ? createMaterial(material) : undefined,\n    type: bodyType ? Body[bodyType.toUpperCase()] : undefined\n  }));\n  body.uuid = uuid;\n  if (collisionResponse !== undefined) {\n    body.collisionResponse = collisionResponse;\n  }\n  if (type === 'Compound') {\n    shapes.forEach(function (_ref3) {\n      var _Quaternion$;\n      var type = _ref3.type,\n        args = _ref3.args,\n        position = _ref3.position,\n        rotation = _ref3.rotation,\n        material = _ref3.material,\n        extra = _objectWithoutProperties(_ref3, _excluded2);\n      var shapeBody = body.addShape(createShape(type, args), position ? _construct(Vec3$1, _toConsumableArray(position)) : undefined, rotation ? (_Quaternion$ = new Quaternion$1()).setFromEuler.apply(_Quaternion$, _toConsumableArray(rotation)) : undefined);\n      if (material) shapeBody.material = createMaterial(material);\n      Object.assign(shapeBody, extra);\n    });\n  } else {\n    body.addShape(createShape(type, args));\n  }\n  body.position.set(position[0], position[1], position[2]);\n  body.quaternion.setFromEuler(rotation[0], rotation[1], rotation[2]);\n  body.velocity.set(velocity[0], velocity[1], velocity[2]);\n  body.angularVelocity.set(angularVelocity[0], angularVelocity[1], angularVelocity[2]);\n  body.linearFactor.set(linearFactor[0], linearFactor[1], linearFactor[2]);\n  body.angularFactor.set(angularFactor[0], angularFactor[1], angularFactor[2]);\n  return body;\n};\n\n/**\n * Records what objects are colliding with each other\n */\n\n/**\n * A 3x3 matrix.\n * Authored by {@link http://github.com/schteppe/ schteppe}\n */\nvar Mat3 = /*#__PURE__*/function () {\n  /**\n   * A vector of length 9, containing all matrix elements.\n   */\n\n  /**\n   * @param elements A vector of length 9, containing all matrix elements.\n   */\n  function Mat3(elements) {\n    _classCallCheck(this, Mat3);\n    if (elements === void 0) {\n      elements = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n    this.elements = elements;\n  }\n  /**\n   * Sets the matrix to identity\n   * @todo Should perhaps be renamed to `setIdentity()` to be more clear.\n   * @todo Create another function that immediately creates an identity matrix eg. `eye()`\n   */\n  _createClass(Mat3, [{\n    key: \"identity\",\n    value: function identity() {\n      var e = this.elements;\n      e[0] = 1;\n      e[1] = 0;\n      e[2] = 0;\n      e[3] = 0;\n      e[4] = 1;\n      e[5] = 0;\n      e[6] = 0;\n      e[7] = 0;\n      e[8] = 1;\n    }\n    /**\n     * Set all elements to zero\n     */\n  }, {\n    key: \"setZero\",\n    value: function setZero() {\n      var e = this.elements;\n      e[0] = 0;\n      e[1] = 0;\n      e[2] = 0;\n      e[3] = 0;\n      e[4] = 0;\n      e[5] = 0;\n      e[6] = 0;\n      e[7] = 0;\n      e[8] = 0;\n    }\n    /**\n     * Sets the matrix diagonal elements from a Vec3\n     */\n  }, {\n    key: \"setTrace\",\n    value: function setTrace(vector) {\n      var e = this.elements;\n      e[0] = vector.x;\n      e[4] = vector.y;\n      e[8] = vector.z;\n    }\n    /**\n     * Gets the matrix diagonal elements\n     */\n  }, {\n    key: \"getTrace\",\n    value: function getTrace(target) {\n      if (target === void 0) {\n        target = new Vec3();\n      }\n      var e = this.elements;\n      target.x = e[0];\n      target.y = e[4];\n      target.z = e[8];\n      return target;\n    }\n    /**\n     * Matrix-Vector multiplication\n     * @param v The vector to multiply with\n     * @param target Optional, target to save the result in.\n     */\n  }, {\n    key: \"vmult\",\n    value: function vmult(v, target) {\n      if (target === void 0) {\n        target = new Vec3();\n      }\n      var e = this.elements;\n      var x = v.x;\n      var y = v.y;\n      var z = v.z;\n      target.x = e[0] * x + e[1] * y + e[2] * z;\n      target.y = e[3] * x + e[4] * y + e[5] * z;\n      target.z = e[6] * x + e[7] * y + e[8] * z;\n      return target;\n    }\n    /**\n     * Matrix-scalar multiplication\n     */\n  }, {\n    key: \"smult\",\n    value: function smult(s) {\n      for (var i = 0; i < this.elements.length; i++) {\n        this.elements[i] *= s;\n      }\n    }\n    /**\n     * Matrix multiplication\n     * @param matrix Matrix to multiply with from left side.\n     */\n  }, {\n    key: \"mmult\",\n    value: function mmult(matrix, target) {\n      if (target === void 0) {\n        target = new Mat3();\n      }\n      var A = this.elements;\n      var B = matrix.elements;\n      var T = target.elements;\n      var a11 = A[0],\n        a12 = A[1],\n        a13 = A[2],\n        a21 = A[3],\n        a22 = A[4],\n        a23 = A[5],\n        a31 = A[6],\n        a32 = A[7],\n        a33 = A[8];\n      var b11 = B[0],\n        b12 = B[1],\n        b13 = B[2],\n        b21 = B[3],\n        b22 = B[4],\n        b23 = B[5],\n        b31 = B[6],\n        b32 = B[7],\n        b33 = B[8];\n      T[0] = a11 * b11 + a12 * b21 + a13 * b31;\n      T[1] = a11 * b12 + a12 * b22 + a13 * b32;\n      T[2] = a11 * b13 + a12 * b23 + a13 * b33;\n      T[3] = a21 * b11 + a22 * b21 + a23 * b31;\n      T[4] = a21 * b12 + a22 * b22 + a23 * b32;\n      T[5] = a21 * b13 + a22 * b23 + a23 * b33;\n      T[6] = a31 * b11 + a32 * b21 + a33 * b31;\n      T[7] = a31 * b12 + a32 * b22 + a33 * b32;\n      T[8] = a31 * b13 + a32 * b23 + a33 * b33;\n      return target;\n    }\n    /**\n     * Scale each column of the matrix\n     */\n  }, {\n    key: \"scale\",\n    value: function scale(vector, target) {\n      if (target === void 0) {\n        target = new Mat3();\n      }\n      var e = this.elements;\n      var t = target.elements;\n      for (var i = 0; i !== 3; i++) {\n        t[3 * i + 0] = vector.x * e[3 * i + 0];\n        t[3 * i + 1] = vector.y * e[3 * i + 1];\n        t[3 * i + 2] = vector.z * e[3 * i + 2];\n      }\n      return target;\n    }\n    /**\n     * Solve Ax=b\n     * @param b The right hand side\n     * @param target Optional. Target vector to save in.\n     * @return The solution x\n     * @todo should reuse arrays\n     */\n  }, {\n    key: \"solve\",\n    value: function solve(b, target) {\n      if (target === void 0) {\n        target = new Vec3();\n      }\n\n      // Construct equations\n      var nr = 3; // num rows\n\n      var nc = 4; // num cols\n\n      var eqns = [];\n      var i;\n      var j;\n      for (i = 0; i < nr * nc; i++) {\n        eqns.push(0);\n      }\n      for (i = 0; i < 3; i++) {\n        for (j = 0; j < 3; j++) {\n          eqns[i + nc * j] = this.elements[i + 3 * j];\n        }\n      }\n      eqns[3 + 4 * 0] = b.x;\n      eqns[3 + 4 * 1] = b.y;\n      eqns[3 + 4 * 2] = b.z; // Compute right upper triangular version of the matrix - Gauss elimination\n\n      var n = 3;\n      var k = n;\n      var np;\n      var kp = 4; // num rows\n\n      var p;\n      do {\n        i = k - n;\n        if (eqns[i + nc * i] === 0) {\n          // the pivot is null, swap lines\n          for (j = i + 1; j < k; j++) {\n            if (eqns[i + nc * j] !== 0) {\n              np = kp;\n              do {\n                // do ligne( i ) = ligne( i ) + ligne( k )\n                p = kp - np;\n                eqns[p + nc * i] += eqns[p + nc * j];\n              } while (--np);\n              break;\n            }\n          }\n        }\n        if (eqns[i + nc * i] !== 0) {\n          for (j = i + 1; j < k; j++) {\n            var multiplier = eqns[i + nc * j] / eqns[i + nc * i];\n            np = kp;\n            do {\n              // do ligne( k ) = ligne( k ) - multiplier * ligne( i )\n              p = kp - np;\n              eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;\n            } while (--np);\n          }\n        }\n      } while (--n); // Get the solution\n\n      target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];\n      target.y = (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) / eqns[1 * nc + 1];\n      target.x = (eqns[0 * nc + 3] - eqns[0 * nc + 2] * target.z - eqns[0 * nc + 1] * target.y) / eqns[0 * nc + 0];\n      if (isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x === Infinity || target.y === Infinity || target.z === Infinity) {\n        throw \"Could not solve equation! Got x=[\".concat(target.toString(), \"], b=[\").concat(b.toString(), \"], A=[\").concat(this.toString(), \"]\");\n      }\n      return target;\n    }\n    /**\n     * Get an element in the matrix by index. Index starts at 0, not 1!!!\n     * @param value If provided, the matrix element will be set to this value.\n     */\n  }, {\n    key: \"e\",\n    value: function e(row, column, value) {\n      if (value === undefined) {\n        return this.elements[column + 3 * row];\n      } else {\n        // Set value\n        this.elements[column + 3 * row] = value;\n      }\n    }\n    /**\n     * Copy another matrix into this matrix object.\n     */\n  }, {\n    key: \"copy\",\n    value: function copy(matrix) {\n      for (var i = 0; i < matrix.elements.length; i++) {\n        this.elements[i] = matrix.elements[i];\n      }\n      return this;\n    }\n    /**\n     * Returns a string representation of the matrix.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var r = '';\n      var sep = ',';\n      for (var i = 0; i < 9; i++) {\n        r += this.elements[i] + sep;\n      }\n      return r;\n    }\n    /**\n     * reverse the matrix\n     * @param target Target matrix to save in.\n     * @return The solution x\n     */\n  }, {\n    key: \"reverse\",\n    value: function reverse(target) {\n      if (target === void 0) {\n        target = new Mat3();\n      }\n\n      // Construct equations\n      var nr = 3; // num rows\n\n      var nc = 6; // num cols\n\n      var eqns = reverse_eqns;\n      var i;\n      var j;\n      for (i = 0; i < 3; i++) {\n        for (j = 0; j < 3; j++) {\n          eqns[i + nc * j] = this.elements[i + 3 * j];\n        }\n      }\n      eqns[3 + 6 * 0] = 1;\n      eqns[3 + 6 * 1] = 0;\n      eqns[3 + 6 * 2] = 0;\n      eqns[4 + 6 * 0] = 0;\n      eqns[4 + 6 * 1] = 1;\n      eqns[4 + 6 * 2] = 0;\n      eqns[5 + 6 * 0] = 0;\n      eqns[5 + 6 * 1] = 0;\n      eqns[5 + 6 * 2] = 1; // Compute right upper triangular version of the matrix - Gauss elimination\n\n      var n = 3;\n      var k = n;\n      var np;\n      var kp = nc; // num rows\n\n      var p;\n      do {\n        i = k - n;\n        if (eqns[i + nc * i] === 0) {\n          // the pivot is null, swap lines\n          for (j = i + 1; j < k; j++) {\n            if (eqns[i + nc * j] !== 0) {\n              np = kp;\n              do {\n                // do line( i ) = line( i ) + line( k )\n                p = kp - np;\n                eqns[p + nc * i] += eqns[p + nc * j];\n              } while (--np);\n              break;\n            }\n          }\n        }\n        if (eqns[i + nc * i] !== 0) {\n          for (j = i + 1; j < k; j++) {\n            var multiplier = eqns[i + nc * j] / eqns[i + nc * i];\n            np = kp;\n            do {\n              // do line( k ) = line( k ) - multiplier * line( i )\n              p = kp - np;\n              eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;\n            } while (--np);\n          }\n        }\n      } while (--n); // eliminate the upper left triangle of the matrix\n\n      i = 2;\n      do {\n        j = i - 1;\n        do {\n          var _multiplier3 = eqns[i + nc * j] / eqns[i + nc * i];\n          np = nc;\n          do {\n            p = nc - np;\n            eqns[p + nc * j] = eqns[p + nc * j] - eqns[p + nc * i] * _multiplier3;\n          } while (--np);\n        } while (j--);\n      } while (--i); // operations on the diagonal\n\n      i = 2;\n      do {\n        var _multiplier4 = 1 / eqns[i + nc * i];\n        np = nc;\n        do {\n          p = nc - np;\n          eqns[p + nc * i] = eqns[p + nc * i] * _multiplier4;\n        } while (--np);\n      } while (i--);\n      i = 2;\n      do {\n        j = 2;\n        do {\n          p = eqns[nr + j + nc * i];\n          if (isNaN(p) || p === Infinity) {\n            throw \"Could not reverse! A=[\".concat(this.toString(), \"]\");\n          }\n          target.e(i, j, p);\n        } while (j--);\n      } while (i--);\n      return target;\n    }\n    /**\n     * Set the matrix from a quaterion\n     */\n  }, {\n    key: \"setRotationFromQuaternion\",\n    value: function setRotationFromQuaternion(q) {\n      var x = q.x;\n      var y = q.y;\n      var z = q.z;\n      var w = q.w;\n      var x2 = x + x;\n      var y2 = y + y;\n      var z2 = z + z;\n      var xx = x * x2;\n      var xy = x * y2;\n      var xz = x * z2;\n      var yy = y * y2;\n      var yz = y * z2;\n      var zz = z * z2;\n      var wx = w * x2;\n      var wy = w * y2;\n      var wz = w * z2;\n      var e = this.elements;\n      e[3 * 0 + 0] = 1 - (yy + zz);\n      e[3 * 0 + 1] = xy - wz;\n      e[3 * 0 + 2] = xz + wy;\n      e[3 * 1 + 0] = xy + wz;\n      e[3 * 1 + 1] = 1 - (xx + zz);\n      e[3 * 1 + 2] = yz - wx;\n      e[3 * 2 + 0] = xz - wy;\n      e[3 * 2 + 1] = yz + wx;\n      e[3 * 2 + 2] = 1 - (xx + yy);\n      return this;\n    }\n    /**\n     * Transpose the matrix\n     * @param target Optional. Where to store the result.\n     * @return The target Mat3, or a new Mat3 if target was omitted.\n     */\n  }, {\n    key: \"transpose\",\n    value: function transpose(target) {\n      if (target === void 0) {\n        target = new Mat3();\n      }\n      var M = this.elements;\n      var T = target.elements;\n      var tmp; //Set diagonals\n\n      T[0] = M[0];\n      T[4] = M[4];\n      T[8] = M[8];\n      tmp = M[1];\n      T[1] = M[3];\n      T[3] = tmp;\n      tmp = M[2];\n      T[2] = M[6];\n      T[6] = tmp;\n      tmp = M[5];\n      T[5] = M[7];\n      T[7] = tmp;\n      return target;\n    }\n  }]);\n  return Mat3;\n}();\nvar reverse_eqns = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n/**\n * 3-dimensional vector\n * @example\n *     const v = new Vec3(1, 2, 3)\n *     console.log('x=' + v.x) // x=1\n */\nvar Vec3 = /*#__PURE__*/function () {\n  function Vec3(x, y, z) {\n    _classCallCheck(this, Vec3);\n    if (x === void 0) {\n      x = 0.0;\n    }\n    if (y === void 0) {\n      y = 0.0;\n    }\n    if (z === void 0) {\n      z = 0.0;\n    }\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  /**\n   * Vector cross product\n   * @param target Optional target to save in.\n   */\n  _createClass(Vec3, [{\n    key: \"cross\",\n    value: function cross(vector, target) {\n      if (target === void 0) {\n        target = new Vec3();\n      }\n      var vx = vector.x;\n      var vy = vector.y;\n      var vz = vector.z;\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      target.x = y * vz - z * vy;\n      target.y = z * vx - x * vz;\n      target.z = x * vy - y * vx;\n      return target;\n    }\n    /**\n     * Set the vectors' 3 elements\n     */\n  }, {\n    key: \"set\",\n    value: function set(x, y, z) {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      return this;\n    }\n    /**\n     * Set all components of the vector to zero.\n     */\n  }, {\n    key: \"setZero\",\n    value: function setZero() {\n      this.x = this.y = this.z = 0;\n    }\n    /**\n     * Vector addition\n     */\n  }, {\n    key: \"vadd\",\n    value: function vadd(vector, target) {\n      if (target) {\n        target.x = vector.x + this.x;\n        target.y = vector.y + this.y;\n        target.z = vector.z + this.z;\n      } else {\n        return new Vec3(this.x + vector.x, this.y + vector.y, this.z + vector.z);\n      }\n    }\n    /**\n     * Vector subtraction\n     * @param target Optional target to save in.\n     */\n  }, {\n    key: \"vsub\",\n    value: function vsub(vector, target) {\n      if (target) {\n        target.x = this.x - vector.x;\n        target.y = this.y - vector.y;\n        target.z = this.z - vector.z;\n      } else {\n        return new Vec3(this.x - vector.x, this.y - vector.y, this.z - vector.z);\n      }\n    }\n    /**\n     * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c\n     *\n     * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Umeå University Lecture}\n     */\n  }, {\n    key: \"crossmat\",\n    value: function crossmat() {\n      return new Mat3([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);\n    }\n    /**\n     * Normalize the vector. Note that this changes the values in the vector.\n      * @return Returns the norm of the vector\n     */\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      var n = Math.sqrt(x * x + y * y + z * z);\n      if (n > 0.0) {\n        var invN = 1 / n;\n        this.x *= invN;\n        this.y *= invN;\n        this.z *= invN;\n      } else {\n        // Make something up\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n      }\n      return n;\n    }\n    /**\n     * Get the version of this vector that is of length 1.\n     * @param target Optional target to save in\n     * @return Returns the unit vector\n     */\n  }, {\n    key: \"unit\",\n    value: function unit(target) {\n      if (target === void 0) {\n        target = new Vec3();\n      }\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      var ninv = Math.sqrt(x * x + y * y + z * z);\n      if (ninv > 0.0) {\n        ninv = 1.0 / ninv;\n        target.x = x * ninv;\n        target.y = y * ninv;\n        target.z = z * ninv;\n      } else {\n        target.x = 1;\n        target.y = 0;\n        target.z = 0;\n      }\n      return target;\n    }\n    /**\n     * Get the length of the vector\n     */\n  }, {\n    key: \"length\",\n    value: function length() {\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      return Math.sqrt(x * x + y * y + z * z);\n    }\n    /**\n     * Get the squared length of the vector.\n     */\n  }, {\n    key: \"lengthSquared\",\n    value: function lengthSquared() {\n      return this.dot(this);\n    }\n    /**\n     * Get distance from this point to another point\n     */\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(p) {\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      var px = p.x;\n      var py = p.y;\n      var pz = p.z;\n      return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z));\n    }\n    /**\n     * Get squared distance from this point to another point\n     */\n  }, {\n    key: \"distanceSquared\",\n    value: function distanceSquared(p) {\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      var px = p.x;\n      var py = p.y;\n      var pz = p.z;\n      return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);\n    }\n    /**\n     * Multiply all the components of the vector with a scalar.\n     * @param target The vector to save the result in.\n     */\n  }, {\n    key: \"scale\",\n    value: function scale(scalar, target) {\n      if (target === void 0) {\n        target = new Vec3();\n      }\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      target.x = scalar * x;\n      target.y = scalar * y;\n      target.z = scalar * z;\n      return target;\n    }\n    /**\n     * Multiply the vector with an other vector, component-wise.\n     * @param target The vector to save the result in.\n     */\n  }, {\n    key: \"vmul\",\n    value: function vmul(vector, target) {\n      if (target === void 0) {\n        target = new Vec3();\n      }\n      target.x = vector.x * this.x;\n      target.y = vector.y * this.y;\n      target.z = vector.z * this.z;\n      return target;\n    }\n    /**\n     * Scale a vector and add it to this vector. Save the result in \"target\". (target = this + vector * scalar)\n     * @param target The vector to save the result in.\n     */\n  }, {\n    key: \"addScaledVector\",\n    value: function addScaledVector(scalar, vector, target) {\n      if (target === void 0) {\n        target = new Vec3();\n      }\n      target.x = this.x + scalar * vector.x;\n      target.y = this.y + scalar * vector.y;\n      target.z = this.z + scalar * vector.z;\n      return target;\n    }\n    /**\n     * Calculate dot product\n     * @param vector\n     */\n  }, {\n    key: \"dot\",\n    value: function dot(vector) {\n      return this.x * vector.x + this.y * vector.y + this.z * vector.z;\n    }\n  }, {\n    key: \"isZero\",\n    value: function isZero() {\n      return this.x === 0 && this.y === 0 && this.z === 0;\n    }\n    /**\n     * Make the vector point in the opposite direction.\n     * @param target Optional target to save in\n     */\n  }, {\n    key: \"negate\",\n    value: function negate(target) {\n      if (target === void 0) {\n        target = new Vec3();\n      }\n      target.x = -this.x;\n      target.y = -this.y;\n      target.z = -this.z;\n      return target;\n    }\n    /**\n     * Compute two artificial tangents to the vector\n     * @param t1 Vector object to save the first tangent in\n     * @param t2 Vector object to save the second tangent in\n     */\n  }, {\n    key: \"tangents\",\n    value: function tangents(t1, t2) {\n      var norm = this.length();\n      if (norm > 0.0) {\n        var n = Vec3_tangents_n;\n        var inorm = 1 / norm;\n        n.set(this.x * inorm, this.y * inorm, this.z * inorm);\n        var randVec = Vec3_tangents_randVec;\n        if (Math.abs(n.x) < 0.9) {\n          randVec.set(1, 0, 0);\n          n.cross(randVec, t1);\n        } else {\n          randVec.set(0, 1, 0);\n          n.cross(randVec, t1);\n        }\n        n.cross(t1, t2);\n      } else {\n        // The normal length is zero, make something up\n        t1.set(1, 0, 0);\n        t2.set(0, 1, 0);\n      }\n    }\n    /**\n     * Converts to a more readable format\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.x, \",\").concat(this.y, \",\").concat(this.z);\n    }\n    /**\n     * Converts to an array\n     */\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return [this.x, this.y, this.z];\n    }\n    /**\n     * Copies value of source to this vector.\n     */\n  }, {\n    key: \"copy\",\n    value: function copy(vector) {\n      this.x = vector.x;\n      this.y = vector.y;\n      this.z = vector.z;\n      return this;\n    }\n    /**\n     * Do a linear interpolation between two vectors\n     * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.\n     */\n  }, {\n    key: \"lerp\",\n    value: function lerp(vector, t, target) {\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      target.x = x + (vector.x - x) * t;\n      target.y = y + (vector.y - y) * t;\n      target.z = z + (vector.z - z) * t;\n    }\n    /**\n     * Check if a vector equals is almost equal to another one.\n     */\n  }, {\n    key: \"almostEquals\",\n    value: function almostEquals(vector, precision) {\n      if (precision === void 0) {\n        precision = 1e-6;\n      }\n      if (Math.abs(this.x - vector.x) > precision || Math.abs(this.y - vector.y) > precision || Math.abs(this.z - vector.z) > precision) {\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Check if a vector is almost zero\n     */\n  }, {\n    key: \"almostZero\",\n    value: function almostZero(precision) {\n      if (precision === void 0) {\n        precision = 1e-6;\n      }\n      if (Math.abs(this.x) > precision || Math.abs(this.y) > precision || Math.abs(this.z) > precision) {\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Check if the vector is anti-parallel to another vector.\n     * @param precision Set to zero for exact comparisons\n     */\n  }, {\n    key: \"isAntiparallelTo\",\n    value: function isAntiparallelTo(vector, precision) {\n      this.negate(antip_neg);\n      return antip_neg.almostEquals(vector, precision);\n    }\n    /**\n     * Clone the vector\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Vec3(this.x, this.y, this.z);\n    }\n  }]);\n  return Vec3;\n}();\nVec3.ZERO = new Vec3(0, 0, 0);\nVec3.UNIT_X = new Vec3(1, 0, 0);\nVec3.UNIT_Y = new Vec3(0, 1, 0);\nVec3.UNIT_Z = new Vec3(0, 0, 1);\nvar Vec3_tangents_n = new Vec3();\nvar Vec3_tangents_randVec = new Vec3();\nvar antip_neg = new Vec3();\n\n/**\n * Axis aligned bounding box class.\n */\nvar AABB = /*#__PURE__*/function () {\n  /**\n   * The lower bound of the bounding box\n   */\n\n  /**\n   * The upper bound of the bounding box\n   */\n  function AABB(options) {\n    _classCallCheck(this, AABB);\n    if (options === void 0) {\n      options = {};\n    }\n    this.lowerBound = new Vec3();\n    this.upperBound = new Vec3();\n    if (options.lowerBound) {\n      this.lowerBound.copy(options.lowerBound);\n    }\n    if (options.upperBound) {\n      this.upperBound.copy(options.upperBound);\n    }\n  }\n  /**\n   * Set the AABB bounds from a set of points.\n   * @param points An array of Vec3's.\n   * @return The self object\n   */\n  _createClass(AABB, [{\n    key: \"setFromPoints\",\n    value: function setFromPoints(points, position, quaternion, skinSize) {\n      var l = this.lowerBound;\n      var u = this.upperBound;\n      var q = quaternion; // Set to the first point\n\n      l.copy(points[0]);\n      if (q) {\n        q.vmult(l, l);\n      }\n      u.copy(l);\n      for (var i = 1; i < points.length; i++) {\n        var p = points[i];\n        if (q) {\n          q.vmult(p, tmp$1);\n          p = tmp$1;\n        }\n        if (p.x > u.x) {\n          u.x = p.x;\n        }\n        if (p.x < l.x) {\n          l.x = p.x;\n        }\n        if (p.y > u.y) {\n          u.y = p.y;\n        }\n        if (p.y < l.y) {\n          l.y = p.y;\n        }\n        if (p.z > u.z) {\n          u.z = p.z;\n        }\n        if (p.z < l.z) {\n          l.z = p.z;\n        }\n      } // Add offset\n\n      if (position) {\n        position.vadd(l, l);\n        position.vadd(u, u);\n      }\n      if (skinSize) {\n        l.x -= skinSize;\n        l.y -= skinSize;\n        l.z -= skinSize;\n        u.x += skinSize;\n        u.y += skinSize;\n        u.z += skinSize;\n      }\n      return this;\n    }\n    /**\n     * Copy bounds from an AABB to this AABB\n     * @param aabb Source to copy from\n     * @return The this object, for chainability\n     */\n  }, {\n    key: \"copy\",\n    value: function copy(aabb) {\n      this.lowerBound.copy(aabb.lowerBound);\n      this.upperBound.copy(aabb.upperBound);\n      return this;\n    }\n    /**\n     * Clone an AABB\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new AABB().copy(this);\n    }\n    /**\n     * Extend this AABB so that it covers the given AABB too.\n     */\n  }, {\n    key: \"extend\",\n    value: function extend(aabb) {\n      this.lowerBound.x = Math.min(this.lowerBound.x, aabb.lowerBound.x);\n      this.upperBound.x = Math.max(this.upperBound.x, aabb.upperBound.x);\n      this.lowerBound.y = Math.min(this.lowerBound.y, aabb.lowerBound.y);\n      this.upperBound.y = Math.max(this.upperBound.y, aabb.upperBound.y);\n      this.lowerBound.z = Math.min(this.lowerBound.z, aabb.lowerBound.z);\n      this.upperBound.z = Math.max(this.upperBound.z, aabb.upperBound.z);\n    }\n    /**\n     * Returns true if the given AABB overlaps this AABB.\n     */\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(aabb) {\n      var l1 = this.lowerBound;\n      var u1 = this.upperBound;\n      var l2 = aabb.lowerBound;\n      var u2 = aabb.upperBound; //      l2        u2\n      //      |---------|\n      // |--------|\n      // l1       u1\n\n      var overlapsX = l2.x <= u1.x && u1.x <= u2.x || l1.x <= u2.x && u2.x <= u1.x;\n      var overlapsY = l2.y <= u1.y && u1.y <= u2.y || l1.y <= u2.y && u2.y <= u1.y;\n      var overlapsZ = l2.z <= u1.z && u1.z <= u2.z || l1.z <= u2.z && u2.z <= u1.z;\n      return overlapsX && overlapsY && overlapsZ;\n    } // Mostly for debugging\n  }, {\n    key: \"volume\",\n    value: function volume() {\n      var l = this.lowerBound;\n      var u = this.upperBound;\n      return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);\n    }\n    /**\n     * Returns true if the given AABB is fully contained in this AABB.\n     */\n  }, {\n    key: \"contains\",\n    value: function contains(aabb) {\n      var l1 = this.lowerBound;\n      var u1 = this.upperBound;\n      var l2 = aabb.lowerBound;\n      var u2 = aabb.upperBound; //      l2        u2\n      //      |---------|\n      // |---------------|\n      // l1              u1\n\n      return l1.x <= l2.x && u1.x >= u2.x && l1.y <= l2.y && u1.y >= u2.y && l1.z <= l2.z && u1.z >= u2.z;\n    }\n  }, {\n    key: \"getCorners\",\n    value: function getCorners(a, b, c, d, e, f, g, h) {\n      var l = this.lowerBound;\n      var u = this.upperBound;\n      a.copy(l);\n      b.set(u.x, l.y, l.z);\n      c.set(u.x, u.y, l.z);\n      d.set(l.x, u.y, u.z);\n      e.set(u.x, l.y, u.z);\n      f.set(l.x, u.y, l.z);\n      g.set(l.x, l.y, u.z);\n      h.copy(u);\n    }\n    /**\n     * Get the representation of an AABB in another frame.\n     * @return The \"target\" AABB object.\n     */\n  }, {\n    key: \"toLocalFrame\",\n    value: function toLocalFrame(frame, target) {\n      var corners = transformIntoFrame_corners;\n      var a = corners[0];\n      var b = corners[1];\n      var c = corners[2];\n      var d = corners[3];\n      var e = corners[4];\n      var f = corners[5];\n      var g = corners[6];\n      var h = corners[7]; // Get corners in current frame\n\n      this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame\n\n      for (var i = 0; i !== 8; i++) {\n        var corner = corners[i];\n        frame.pointToLocal(corner, corner);\n      }\n      return target.setFromPoints(corners);\n    }\n    /**\n     * Get the representation of an AABB in the global frame.\n     * @return The \"target\" AABB object.\n     */\n  }, {\n    key: \"toWorldFrame\",\n    value: function toWorldFrame(frame, target) {\n      var corners = transformIntoFrame_corners;\n      var a = corners[0];\n      var b = corners[1];\n      var c = corners[2];\n      var d = corners[3];\n      var e = corners[4];\n      var f = corners[5];\n      var g = corners[6];\n      var h = corners[7]; // Get corners in current frame\n\n      this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame\n\n      for (var i = 0; i !== 8; i++) {\n        var corner = corners[i];\n        frame.pointToWorld(corner, corner);\n      }\n      return target.setFromPoints(corners);\n    }\n    /**\n     * Check if the AABB is hit by a ray.\n     */\n  }, {\n    key: \"overlapsRay\",\n    value: function overlapsRay(ray) {\n      var direction = ray.direction,\n        from = ray.from; // const t = 0\n      // ray.direction is unit direction vector of ray\n\n      var dirFracX = 1 / direction.x;\n      var dirFracY = 1 / direction.y;\n      var dirFracZ = 1 / direction.z; // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner\n\n      var t1 = (this.lowerBound.x - from.x) * dirFracX;\n      var t2 = (this.upperBound.x - from.x) * dirFracX;\n      var t3 = (this.lowerBound.y - from.y) * dirFracY;\n      var t4 = (this.upperBound.y - from.y) * dirFracY;\n      var t5 = (this.lowerBound.z - from.z) * dirFracZ;\n      var t6 = (this.upperBound.z - from.z) * dirFracZ; // const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));\n      // const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));\n\n      var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));\n      var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6)); // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us\n\n      if (tmax < 0) {\n        //t = tmax;\n        return false;\n      } // if tmin > tmax, ray doesn't intersect AABB\n\n      if (tmin > tmax) {\n        //t = tmax;\n        return false;\n      }\n      return true;\n    }\n  }]);\n  return AABB;\n}();\nvar tmp$1 = new Vec3();\nvar transformIntoFrame_corners = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n\n/**\n * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.\n * @param x Multiplier of the imaginary basis vector i.\n * @param y Multiplier of the imaginary basis vector j.\n * @param z Multiplier of the imaginary basis vector k.\n * @param w Multiplier of the real part.\n * @see http://en.wikipedia.org/wiki/Quaternion\n */\nvar Quaternion = /*#__PURE__*/function () {\n  function Quaternion(x, y, z, w) {\n    _classCallCheck(this, Quaternion);\n    if (x === void 0) {\n      x = 0;\n    }\n    if (y === void 0) {\n      y = 0;\n    }\n    if (z === void 0) {\n      z = 0;\n    }\n    if (w === void 0) {\n      w = 1;\n    }\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n  /**\n   * Set the value of the quaternion.\n   */\n  _createClass(Quaternion, [{\n    key: \"set\",\n    value: function set(x, y, z, w) {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n      return this;\n    }\n    /**\n     * Convert to a readable format\n     * @return \"x,y,z,w\"\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.x, \",\").concat(this.y, \",\").concat(this.z, \",\").concat(this.w);\n    }\n    /**\n     * Convert to an Array\n     * @return [x, y, z, w]\n     */\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return [this.x, this.y, this.z, this.w];\n    }\n    /**\n     * Set the quaternion components given an axis and an angle in radians.\n     */\n  }, {\n    key: \"setFromAxisAngle\",\n    value: function setFromAxisAngle(vector, angle) {\n      var s = Math.sin(angle * 0.5);\n      this.x = vector.x * s;\n      this.y = vector.y * s;\n      this.z = vector.z * s;\n      this.w = Math.cos(angle * 0.5);\n      return this;\n    }\n    /**\n     * Converts the quaternion to [ axis, angle ] representation.\n     * @param targetAxis A vector object to reuse for storing the axis.\n     * @return An array, first element is the axis and the second is the angle in radians.\n     */\n  }, {\n    key: \"toAxisAngle\",\n    value: function toAxisAngle(targetAxis) {\n      if (targetAxis === void 0) {\n        targetAxis = new Vec3();\n      }\n      this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised\n\n      var angle = 2 * Math.acos(this.w);\n      var s = Math.sqrt(1 - this.w * this.w); // assuming quaternion normalised then w is less than 1, so term always positive.\n\n      if (s < 0.001) {\n        // test to avoid divide by zero, s is always positive due to sqrt\n        // if s close to zero then direction of axis not important\n        targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;\n\n        targetAxis.y = this.y;\n        targetAxis.z = this.z;\n      } else {\n        targetAxis.x = this.x / s; // normalise axis\n\n        targetAxis.y = this.y / s;\n        targetAxis.z = this.z / s;\n      }\n      return [targetAxis, angle];\n    }\n    /**\n     * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.\n     */\n  }, {\n    key: \"setFromVectors\",\n    value: function setFromVectors(u, v) {\n      if (u.isAntiparallelTo(v)) {\n        var t1 = sfv_t1;\n        var t2 = sfv_t2;\n        u.tangents(t1, t2);\n        this.setFromAxisAngle(t1, Math.PI);\n      } else {\n        var _a7 = u.cross(v);\n        this.x = _a7.x;\n        this.y = _a7.y;\n        this.z = _a7.z;\n        this.w = Math.sqrt(Math.pow(u.length(), 2) * Math.pow(v.length(), 2)) + u.dot(v);\n        this.normalize();\n      }\n      return this;\n    }\n    /**\n     * Multiply the quaternion with an other quaternion.\n     */\n  }, {\n    key: \"mult\",\n    value: function mult(quat, target) {\n      if (target === void 0) {\n        target = new Quaternion();\n      }\n      var ax = this.x;\n      var ay = this.y;\n      var az = this.z;\n      var aw = this.w;\n      var bx = quat.x;\n      var by = quat.y;\n      var bz = quat.z;\n      var bw = quat.w;\n      target.x = ax * bw + aw * bx + ay * bz - az * by;\n      target.y = ay * bw + aw * by + az * bx - ax * bz;\n      target.z = az * bw + aw * bz + ax * by - ay * bx;\n      target.w = aw * bw - ax * bx - ay * by - az * bz;\n      return target;\n    }\n    /**\n     * Get the inverse quaternion rotation.\n     */\n  }, {\n    key: \"inverse\",\n    value: function inverse(target) {\n      if (target === void 0) {\n        target = new Quaternion();\n      }\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      var w = this.w;\n      this.conjugate(target);\n      var inorm2 = 1 / (x * x + y * y + z * z + w * w);\n      target.x *= inorm2;\n      target.y *= inorm2;\n      target.z *= inorm2;\n      target.w *= inorm2;\n      return target;\n    }\n    /**\n     * Get the quaternion conjugate\n     */\n  }, {\n    key: \"conjugate\",\n    value: function conjugate(target) {\n      if (target === void 0) {\n        target = new Quaternion();\n      }\n      target.x = -this.x;\n      target.y = -this.y;\n      target.z = -this.z;\n      target.w = this.w;\n      return target;\n    }\n    /**\n     * Normalize the quaternion. Note that this changes the values of the quaternion.\n     */\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n      if (l === 0) {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n      } else {\n        l = 1 / l;\n        this.x *= l;\n        this.y *= l;\n        this.z *= l;\n        this.w *= l;\n      }\n      return this;\n    }\n    /**\n     * Approximation of quaternion normalization. Works best when quat is already almost-normalized.\n     * @author unphased, https://github.com/unphased\n     */\n  }, {\n    key: \"normalizeFast\",\n    value: function normalizeFast() {\n      var f = (3.0 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2.0;\n      if (f === 0) {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n      } else {\n        this.x *= f;\n        this.y *= f;\n        this.z *= f;\n        this.w *= f;\n      }\n      return this;\n    }\n    /**\n     * Multiply the quaternion by a vector\n     */\n  }, {\n    key: \"vmult\",\n    value: function vmult(v, target) {\n      if (target === void 0) {\n        target = new Vec3();\n      }\n      var x = v.x;\n      var y = v.y;\n      var z = v.z;\n      var qx = this.x;\n      var qy = this.y;\n      var qz = this.z;\n      var qw = this.w; // q*v\n\n      var ix = qw * x + qy * z - qz * y;\n      var iy = qw * y + qz * x - qx * z;\n      var iz = qw * z + qx * y - qy * x;\n      var iw = -qx * x - qy * y - qz * z;\n      target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n      target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n      target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n      return target;\n    }\n    /**\n     * Copies value of source to this quaternion.\n     * @return this\n     */\n  }, {\n    key: \"copy\",\n    value: function copy(quat) {\n      this.x = quat.x;\n      this.y = quat.y;\n      this.z = quat.z;\n      this.w = quat.w;\n      return this;\n    }\n    /**\n     * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm\n     * @param order Three-character string, defaults to \"YZX\"\n     */\n  }, {\n    key: \"toEuler\",\n    value: function toEuler(target, order) {\n      if (order === void 0) {\n        order = 'YZX';\n      }\n      var heading;\n      var attitude;\n      var bank;\n      var x = this.x;\n      var y = this.y;\n      var z = this.z;\n      var w = this.w;\n      switch (order) {\n        case 'YZX':\n          var test = x * y + z * w;\n          if (test > 0.499) {\n            // singularity at north pole\n            heading = 2 * Math.atan2(x, w);\n            attitude = Math.PI / 2;\n            bank = 0;\n          }\n          if (test < -0.499) {\n            // singularity at south pole\n            heading = -2 * Math.atan2(x, w);\n            attitude = -Math.PI / 2;\n            bank = 0;\n          }\n          if (heading === undefined) {\n            var sqx = x * x;\n            var sqy = y * y;\n            var sqz = z * z;\n            heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz); // Heading\n\n            attitude = Math.asin(2 * test); // attitude\n\n            bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz); // bank\n          }\n\n          break;\n        default:\n          throw new Error(\"Euler order \".concat(order, \" not supported yet.\"));\n      }\n      target.y = heading;\n      target.z = attitude;\n      target.x = bank;\n    }\n    /**\n     * Set the quaternion components given Euler angle representation.\n     *\n     * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.\n     *\n     * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference\n     */\n  }, {\n    key: \"setFromEuler\",\n    value: function setFromEuler(x, y, z, order) {\n      if (order === void 0) {\n        order = 'XYZ';\n      }\n      var c1 = Math.cos(x / 2);\n      var c2 = Math.cos(y / 2);\n      var c3 = Math.cos(z / 2);\n      var s1 = Math.sin(x / 2);\n      var s2 = Math.sin(y / 2);\n      var s3 = Math.sin(z / 2);\n      if (order === 'XYZ') {\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n      } else if (order === 'YXZ') {\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 - s1 * s2 * c3;\n        this.w = c1 * c2 * c3 + s1 * s2 * s3;\n      } else if (order === 'ZXY') {\n        this.x = s1 * c2 * c3 - c1 * s2 * s3;\n        this.y = c1 * s2 * c3 + s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n      } else if (order === 'ZYX') {\n        this.x = s1 * c2 * c3 - c1 * s2 * s3;\n        this.y = c1 * s2 * c3 + s1 * c2 * s3;\n        this.z = c1 * c2 * s3 - s1 * s2 * c3;\n        this.w = c1 * c2 * c3 + s1 * s2 * s3;\n      } else if (order === 'YZX') {\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 + s1 * c2 * s3;\n        this.z = c1 * c2 * s3 - s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n      } else if (order === 'XZY') {\n        this.x = s1 * c2 * c3 - c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 + s1 * s2 * s3;\n      }\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Quaternion(this.x, this.y, this.z, this.w);\n    }\n    /**\n     * Performs a spherical linear interpolation between two quat\n     *\n     * @param toQuat second operand\n     * @param t interpolation amount between the self quaternion and toQuat\n     * @param target A quaternion to store the result in. If not provided, a new one will be created.\n     * @returns {Quaternion} The \"target\" object\n     */\n  }, {\n    key: \"slerp\",\n    value: function slerp(toQuat, t, target) {\n      if (target === void 0) {\n        target = new Quaternion();\n      }\n      var ax = this.x;\n      var ay = this.y;\n      var az = this.z;\n      var aw = this.w;\n      var bx = toQuat.x;\n      var by = toQuat.y;\n      var bz = toQuat.z;\n      var bw = toQuat.w;\n      var omega;\n      var cosom;\n      var sinom;\n      var scale0;\n      var scale1; // calc cosine\n\n      cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n      if (cosom < 0.0) {\n        cosom = -cosom;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n      } // calculate coefficients\n\n      if (1.0 - cosom > 0.000001) {\n        // standard case (slerp)\n        omega = Math.acos(cosom);\n        sinom = Math.sin(omega);\n        scale0 = Math.sin((1.0 - t) * omega) / sinom;\n        scale1 = Math.sin(t * omega) / sinom;\n      } else {\n        // \"from\" and \"to\" quaternions are very close\n        //  ... so we can do a linear interpolation\n        scale0 = 1.0 - t;\n        scale1 = t;\n      } // calculate final values\n\n      target.x = scale0 * ax + scale1 * bx;\n      target.y = scale0 * ay + scale1 * by;\n      target.z = scale0 * az + scale1 * bz;\n      target.w = scale0 * aw + scale1 * bw;\n      return target;\n    }\n    /**\n     * Rotate an absolute orientation quaternion given an angular velocity and a time step.\n     */\n  }, {\n    key: \"integrate\",\n    value: function integrate(angularVelocity, dt, angularFactor, target) {\n      if (target === void 0) {\n        target = new Quaternion();\n      }\n      var ax = angularVelocity.x * angularFactor.x,\n        ay = angularVelocity.y * angularFactor.y,\n        az = angularVelocity.z * angularFactor.z,\n        bx = this.x,\n        by = this.y,\n        bz = this.z,\n        bw = this.w;\n      var half_dt = dt * 0.5;\n      target.x += half_dt * (ax * bw + ay * bz - az * by);\n      target.y += half_dt * (ay * bw + az * bx - ax * bz);\n      target.z += half_dt * (az * bw + ax * by - ay * bx);\n      target.w += half_dt * (-ax * bx - ay * by - az * bz);\n      return target;\n    }\n  }]);\n  return Quaternion;\n}();\nvar sfv_t1 = new Vec3();\nvar sfv_t2 = new Vec3();\n\n/**\n * The available shape types.\n */\nvar SHAPE_TYPES = {\n  /** SPHERE */\n  SPHERE: 1,\n  /** PLANE */\n  PLANE: 2,\n  /** BOX */\n  BOX: 4,\n  /** COMPOUND */\n  COMPOUND: 8,\n  /** CONVEXPOLYHEDRON */\n  CONVEXPOLYHEDRON: 16,\n  /** HEIGHTFIELD */\n  HEIGHTFIELD: 32,\n  /** PARTICLE */\n  PARTICLE: 64,\n  /** CYLINDER */\n  CYLINDER: 128,\n  /** TRIMESH */\n  TRIMESH: 256\n};\n/**\n * ShapeType\n */\n\n/**\n * Base class for shapes\n */\nvar Shape = /*#__PURE__*/function () {\n  /**\n   * Identifier of the Shape.\n   */\n\n  /**\n   * The type of this shape. Must be set to an int > 0 by subclasses.\n   */\n\n  /**\n   * The local bounding sphere radius of this shape.\n   */\n\n  /**\n   * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.\n   * @default true\n   */\n\n  /**\n   * @default 1\n   */\n\n  /**\n   * @default -1\n   */\n\n  /**\n   * Optional material of the shape that regulates contact properties.\n   */\n\n  /**\n   * The body to which the shape is added to.\n   */\n\n  /**\n   * All the Shape types.\n   */\n  function Shape(options) {\n    _classCallCheck(this, Shape);\n    if (options === void 0) {\n      options = {};\n    }\n    this.id = Shape.idCounter++;\n    this.type = options.type || 0;\n    this.boundingSphereRadius = 0;\n    this.collisionResponse = options.collisionResponse ? options.collisionResponse : true;\n    this.collisionFilterGroup = options.collisionFilterGroup !== undefined ? options.collisionFilterGroup : 1;\n    this.collisionFilterMask = options.collisionFilterMask !== undefined ? options.collisionFilterMask : -1;\n    this.material = options.material ? options.material : null;\n    this.body = null;\n  }\n  /**\n   * Computes the bounding sphere radius.\n   * The result is stored in the property `.boundingSphereRadius`\n   */\n  _createClass(Shape, [{\n    key: \"updateBoundingSphereRadius\",\n    value: function updateBoundingSphereRadius() {\n      throw \"computeBoundingSphereRadius() not implemented for shape type \".concat(this.type);\n    }\n    /**\n     * Get the volume of this shape\n     */\n  }, {\n    key: \"volume\",\n    value: function volume() {\n      throw \"volume() not implemented for shape type \".concat(this.type);\n    }\n    /**\n     * Calculates the inertia in the local frame for this shape.\n     * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia\n     */\n  }, {\n    key: \"calculateLocalInertia\",\n    value: function calculateLocalInertia(mass, target) {\n      throw \"calculateLocalInertia() not implemented for shape type \".concat(this.type);\n    }\n    /**\n     * @todo use abstract for these kind of methods\n     */\n  }, {\n    key: \"calculateWorldAABB\",\n    value: function calculateWorldAABB(pos, quat, min, max) {\n      throw \"calculateWorldAABB() not implemented for shape type \".concat(this.type);\n    }\n  }]);\n  return Shape;\n}();\nShape.idCounter = 0;\nShape.types = SHAPE_TYPES;\n\n/**\n * Transformation utilities.\n */\nvar Transform = /*#__PURE__*/function () {\n  /**\n   * position\n   */\n\n  /**\n   * quaternion\n   */\n  function Transform(options) {\n    _classCallCheck(this, Transform);\n    if (options === void 0) {\n      options = {};\n    }\n    this.position = new Vec3();\n    this.quaternion = new Quaternion();\n    if (options.position) {\n      this.position.copy(options.position);\n    }\n    if (options.quaternion) {\n      this.quaternion.copy(options.quaternion);\n    }\n  }\n  /**\n   * Get a global point in local transform coordinates.\n   */\n  _createClass(Transform, [{\n    key: \"pointToLocal\",\n    value: function pointToLocal(worldPoint, result) {\n      return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);\n    }\n    /**\n     * Get a local point in global transform coordinates.\n     */\n  }, {\n    key: \"pointToWorld\",\n    value: function pointToWorld(localPoint, result) {\n      return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);\n    }\n    /**\n     * vectorToWorldFrame\n     */\n  }, {\n    key: \"vectorToWorldFrame\",\n    value: function vectorToWorldFrame(localVector, result) {\n      if (result === void 0) {\n        result = new Vec3();\n      }\n      this.quaternion.vmult(localVector, result);\n      return result;\n    }\n    /**\n     * pointToLocalFrame\n     */\n  }], [{\n    key: \"pointToLocalFrame\",\n    value: function pointToLocalFrame(position, quaternion, worldPoint, result) {\n      if (result === void 0) {\n        result = new Vec3();\n      }\n      worldPoint.vsub(position, result);\n      quaternion.conjugate(tmpQuat$1);\n      tmpQuat$1.vmult(result, result);\n      return result;\n    }\n    /**\n     * pointToWorldFrame\n     */\n  }, {\n    key: \"pointToWorldFrame\",\n    value: function pointToWorldFrame(position, quaternion, localPoint, result) {\n      if (result === void 0) {\n        result = new Vec3();\n      }\n      quaternion.vmult(localPoint, result);\n      result.vadd(position, result);\n      return result;\n    }\n    /**\n     * vectorToWorldFrame\n     */\n  }, {\n    key: \"vectorToWorldFrame\",\n    value: function vectorToWorldFrame(quaternion, localVector, result) {\n      if (result === void 0) {\n        result = new Vec3();\n      }\n      quaternion.vmult(localVector, result);\n      return result;\n    }\n    /**\n     * vectorToLocalFrame\n     */\n  }, {\n    key: \"vectorToLocalFrame\",\n    value: function vectorToLocalFrame(position, quaternion, worldVector, result) {\n      if (result === void 0) {\n        result = new Vec3();\n      }\n      quaternion.w *= -1;\n      quaternion.vmult(worldVector, result);\n      quaternion.w *= -1;\n      return result;\n    }\n  }]);\n  return Transform;\n}();\nvar tmpQuat$1 = new Quaternion();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\n[new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\nnew Vec3();\nnew Quaternion();\nnew AABB();\nnew Mat3();\nnew Mat3();\nnew Mat3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Quaternion();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\n\n/**\n * Storage for Ray casting data\n */\nvar RaycastResult = /*#__PURE__*/function () {\n  /**\n   * rayFromWorld\n   */\n\n  /**\n   * rayToWorld\n   */\n\n  /**\n   * hitNormalWorld\n   */\n\n  /**\n   * hitPointWorld\n   */\n\n  /**\n   * hasHit\n   */\n\n  /**\n   * shape\n   */\n\n  /**\n   * body\n   */\n\n  /**\n   * The index of the hit triangle, if the hit shape was a trimesh\n   */\n\n  /**\n   * Distance to the hit. Will be set to -1 if there was no hit\n   */\n\n  /**\n   * If the ray should stop traversing the bodies\n   */\n  function RaycastResult() {\n    _classCallCheck(this, RaycastResult);\n    this.rayFromWorld = new Vec3();\n    this.rayToWorld = new Vec3();\n    this.hitNormalWorld = new Vec3();\n    this.hitPointWorld = new Vec3();\n    this.hasHit = false;\n    this.shape = null;\n    this.body = null;\n    this.hitFaceIndex = -1;\n    this.distance = -1;\n    this.shouldStop = false;\n  }\n  /**\n   * Reset all result data.\n   */\n  _createClass(RaycastResult, [{\n    key: \"reset\",\n    value: function reset() {\n      this.rayFromWorld.setZero();\n      this.rayToWorld.setZero();\n      this.hitNormalWorld.setZero();\n      this.hitPointWorld.setZero();\n      this.hasHit = false;\n      this.shape = null;\n      this.body = null;\n      this.hitFaceIndex = -1;\n      this.distance = -1;\n      this.shouldStop = false;\n    }\n    /**\n     * abort\n     */\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this.shouldStop = true;\n    }\n    /**\n     * Set result data.\n     */\n  }, {\n    key: \"set\",\n    value: function set(rayFromWorld, rayToWorld, hitNormalWorld, hitPointWorld, shape, body, distance) {\n      this.rayFromWorld.copy(rayFromWorld);\n      this.rayToWorld.copy(rayToWorld);\n      this.hitNormalWorld.copy(hitNormalWorld);\n      this.hitPointWorld.copy(hitPointWorld);\n      this.shape = shape;\n      this.body = body;\n      this.distance = distance;\n    }\n  }]);\n  return RaycastResult;\n}();\nvar _Shape$types$SPHERE, _Shape$types$PLANE, _Shape$types$BOX, _Shape$types$CYLINDER, _Shape$types$CONVEXPO, _Shape$types$HEIGHTFI, _Shape$types$TRIMESH;\n\n/**\n * RAY_MODES\n */\nvar RAY_MODES = {\n  /** CLOSEST */\n  CLOSEST: 1,\n  /** ANY */\n  ANY: 2,\n  /** ALL */\n  ALL: 4\n};\n/**\n * RayMode\n */\n\n_Shape$types$SPHERE = Shape.types.SPHERE;\n_Shape$types$PLANE = Shape.types.PLANE;\n_Shape$types$BOX = Shape.types.BOX;\n_Shape$types$CYLINDER = Shape.types.CYLINDER;\n_Shape$types$CONVEXPO = Shape.types.CONVEXPOLYHEDRON;\n_Shape$types$HEIGHTFI = Shape.types.HEIGHTFIELD;\n_Shape$types$TRIMESH = Shape.types.TRIMESH;\n\n/**\n * A line in 3D space that intersects bodies and return points.\n */\nvar Ray = /*#__PURE__*/function (_Shape$types$SPHERE2, _Shape$types$PLANE2, _Shape$types$BOX2, _Shape$types$CYLINDER3, _Shape$types$CONVEXPO3, _Shape$types$HEIGHTFI3, _Shape$types$TRIMESH2) {\n  function Ray(from, to) {\n    _classCallCheck(this, Ray);\n    if (from === void 0) {\n      from = new Vec3();\n    }\n    if (to === void 0) {\n      to = new Vec3();\n    }\n    this.from = from.clone();\n    this.to = to.clone();\n    this.direction = new Vec3();\n    this.precision = 0.0001;\n    this.checkCollisionResponse = true;\n    this.skipBackfaces = false;\n    this.collisionFilterMask = -1;\n    this.collisionFilterGroup = -1;\n    this.mode = Ray.ANY;\n    this.result = new RaycastResult();\n    this.hasHit = false;\n    this.callback = function (result) {};\n  }\n  /**\n   * Do itersection against all bodies in the given World.\n   * @return True if the ray hit anything, otherwise false.\n   */\n  _createClass(Ray, [{\n    key: _Shape$types$SPHERE2,\n    get:\n    /**\n     * from\n     */\n\n    /**\n     * to\n     */\n\n    /**\n     * direction\n     */\n\n    /**\n     * The precision of the ray. Used when checking parallelity etc.\n     * @default 0.0001\n     */\n\n    /**\n     * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.\n     * @default true\n     */\n\n    /**\n     * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.\n     * @default false\n     */\n\n    /**\n     * collisionFilterMask\n     * @default -1\n     */\n\n    /**\n     * collisionFilterGroup\n     * @default -1\n     */\n\n    /**\n     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.\n     * @default RAY.ANY\n     */\n\n    /**\n     * Current result object.\n     */\n\n    /**\n     * Will be set to `true` during intersectWorld() if the ray hit anything.\n     */\n\n    /**\n     * User-provided result callback. Will be used if mode is Ray.ALL.\n     */\n\n    /**\n     * CLOSEST\n     */\n\n    /**\n     * ANY\n     */\n\n    /**\n     * ALL\n     */\n    function get() {\n      return this._intersectSphere;\n    }\n  }, {\n    key: _Shape$types$PLANE2,\n    get: function get() {\n      return this._intersectPlane;\n    }\n  }, {\n    key: _Shape$types$BOX2,\n    get: function get() {\n      return this._intersectBox;\n    }\n  }, {\n    key: _Shape$types$CYLINDER3,\n    get: function get() {\n      return this._intersectConvex;\n    }\n  }, {\n    key: _Shape$types$CONVEXPO3,\n    get: function get() {\n      return this._intersectConvex;\n    }\n  }, {\n    key: _Shape$types$HEIGHTFI3,\n    get: function get() {\n      return this._intersectHeightfield;\n    }\n  }, {\n    key: _Shape$types$TRIMESH2,\n    get: function get() {\n      return this._intersectTrimesh;\n    }\n  }, {\n    key: \"intersectWorld\",\n    value: function intersectWorld(world, options) {\n      this.mode = options.mode || Ray.ANY;\n      this.result = options.result || new RaycastResult();\n      this.skipBackfaces = !!options.skipBackfaces;\n      this.collisionFilterMask = typeof options.collisionFilterMask !== 'undefined' ? options.collisionFilterMask : -1;\n      this.collisionFilterGroup = typeof options.collisionFilterGroup !== 'undefined' ? options.collisionFilterGroup : -1;\n      this.checkCollisionResponse = typeof options.checkCollisionResponse !== 'undefined' ? options.checkCollisionResponse : true;\n      if (options.from) {\n        this.from.copy(options.from);\n      }\n      if (options.to) {\n        this.to.copy(options.to);\n      }\n      this.callback = options.callback || function () {};\n      this.hasHit = false;\n      this.result.reset();\n      this.updateDirection();\n      this.getAABB(tmpAABB$1);\n      tmpArray.length = 0;\n      world.broadphase.aabbQuery(world, tmpAABB$1, tmpArray);\n      this.intersectBodies(tmpArray);\n      return this.hasHit;\n    }\n    /**\n     * Shoot a ray at a body, get back information about the hit.\n     * @deprecated @param result set the result property of the Ray instead.\n     */\n  }, {\n    key: \"intersectBody\",\n    value: function intersectBody(body, result) {\n      if (result) {\n        this.result = result;\n        this.updateDirection();\n      }\n      var checkCollisionResponse = this.checkCollisionResponse;\n      if (checkCollisionResponse && !body.collisionResponse) {\n        return;\n      }\n      if ((this.collisionFilterGroup & body.collisionFilterMask) === 0 || (body.collisionFilterGroup & this.collisionFilterMask) === 0) {\n        return;\n      }\n      var xi = intersectBody_xi;\n      var qi = intersectBody_qi;\n      for (var i = 0, N = body.shapes.length; i < N; i++) {\n        var shape = body.shapes[i];\n        if (checkCollisionResponse && !shape.collisionResponse) {\n          continue; // Skip\n        }\n\n        body.quaternion.mult(body.shapeOrientations[i], qi);\n        body.quaternion.vmult(body.shapeOffsets[i], xi);\n        xi.vadd(body.position, xi);\n        this.intersectShape(shape, qi, xi, body);\n        if (this.result.shouldStop) {\n          break;\n        }\n      }\n    }\n    /**\n     * Shoot a ray at an array bodies, get back information about the hit.\n     * @param bodies An array of Body objects.\n     * @deprecated @param result set the result property of the Ray instead.\n     *\n     */\n  }, {\n    key: \"intersectBodies\",\n    value: function intersectBodies(bodies, result) {\n      if (result) {\n        this.result = result;\n        this.updateDirection();\n      }\n      for (var i = 0, l = bodies.length; !this.result.shouldStop && i < l; i++) {\n        this.intersectBody(bodies[i]);\n      }\n    }\n    /**\n     * Updates the direction vector.\n     */\n  }, {\n    key: \"updateDirection\",\n    value: function updateDirection() {\n      this.to.vsub(this.from, this.direction);\n      this.direction.normalize();\n    }\n  }, {\n    key: \"intersectShape\",\n    value: function intersectShape(shape, quat, position, body) {\n      var from = this.from; // Checking boundingSphere\n\n      var distance = distanceFromIntersection(from, this.direction, position);\n      if (distance > shape.boundingSphereRadius) {\n        return;\n      }\n      var intersectMethod = this[shape.type];\n      if (intersectMethod) {\n        intersectMethod.call(this, shape, quat, position, body, shape);\n      }\n    }\n  }, {\n    key: \"_intersectBox\",\n    value: function _intersectBox(box, quat, position, body, reportedShape) {\n      return this._intersectConvex(box.convexPolyhedronRepresentation, quat, position, body, reportedShape);\n    }\n  }, {\n    key: \"_intersectPlane\",\n    value: function _intersectPlane(shape, quat, position, body, reportedShape) {\n      var from = this.from;\n      var to = this.to;\n      var direction = this.direction; // Get plane normal\n\n      var worldNormal = new Vec3(0, 0, 1);\n      quat.vmult(worldNormal, worldNormal);\n      var len = new Vec3();\n      from.vsub(position, len);\n      var planeToFrom = len.dot(worldNormal);\n      to.vsub(position, len);\n      var planeToTo = len.dot(worldNormal);\n      if (planeToFrom * planeToTo > 0) {\n        // \"from\" and \"to\" are on the same side of the plane... bail out\n        return;\n      }\n      if (from.distanceTo(to) < planeToFrom) {\n        return;\n      }\n      var n_dot_dir = worldNormal.dot(direction);\n      if (Math.abs(n_dot_dir) < this.precision) {\n        // No intersection\n        return;\n      }\n      var planePointToFrom = new Vec3();\n      var dir_scaled_with_t = new Vec3();\n      var hitPointWorld = new Vec3();\n      from.vsub(position, planePointToFrom);\n      var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;\n      direction.scale(t, dir_scaled_with_t);\n      from.vadd(dir_scaled_with_t, hitPointWorld);\n      this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);\n    }\n    /**\n     * Get the world AABB of the ray.\n     */\n  }, {\n    key: \"getAABB\",\n    value: function getAABB(aabb) {\n      var lowerBound = aabb.lowerBound,\n        upperBound = aabb.upperBound;\n      var to = this.to;\n      var from = this.from;\n      lowerBound.x = Math.min(to.x, from.x);\n      lowerBound.y = Math.min(to.y, from.y);\n      lowerBound.z = Math.min(to.z, from.z);\n      upperBound.x = Math.max(to.x, from.x);\n      upperBound.y = Math.max(to.y, from.y);\n      upperBound.z = Math.max(to.z, from.z);\n    }\n  }, {\n    key: \"_intersectHeightfield\",\n    value: function _intersectHeightfield(shape, quat, position, body, reportedShape) {\n      shape.data;\n      shape.elementSize; // Convert the ray to local heightfield coordinates\n\n      var localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);\n\n      localRay.from.copy(this.from);\n      localRay.to.copy(this.to);\n      Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);\n      Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);\n      localRay.updateDirection(); // Get the index of the data points to test against\n\n      var index = intersectHeightfield_index;\n      var iMinX;\n      var iMinY;\n      var iMaxX;\n      var iMaxY; // Set to max\n\n      iMinX = iMinY = 0;\n      iMaxX = iMaxY = shape.data.length - 1;\n      var aabb = new AABB();\n      localRay.getAABB(aabb);\n      shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);\n      iMinX = Math.max(iMinX, index[0]);\n      iMinY = Math.max(iMinY, index[1]);\n      shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);\n      iMaxX = Math.min(iMaxX, index[0] + 1);\n      iMaxY = Math.min(iMaxY, index[1] + 1);\n      for (var i = iMinX; i < iMaxX; i++) {\n        for (var j = iMinY; j < iMaxY; j++) {\n          if (this.result.shouldStop) {\n            return;\n          }\n          shape.getAabbAtIndex(i, j, aabb);\n          if (!aabb.overlapsRay(localRay)) {\n            continue;\n          } // Lower triangle\n\n          shape.getConvexTrianglePillar(i, j, false);\n          Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);\n          this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);\n          if (this.result.shouldStop) {\n            return;\n          } // Upper triangle\n\n          shape.getConvexTrianglePillar(i, j, true);\n          Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);\n          this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);\n        }\n      }\n    }\n  }, {\n    key: \"_intersectSphere\",\n    value: function _intersectSphere(sphere, quat, position, body, reportedShape) {\n      var from = this.from;\n      var to = this.to;\n      var r = sphere.radius;\n      var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);\n      var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));\n      var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);\n      var delta = Math.pow(b, 2) - 4 * a * c;\n      var intersectionPoint = Ray_intersectSphere_intersectionPoint;\n      var normal = Ray_intersectSphere_normal;\n      if (delta < 0) {\n        // No intersection\n        return;\n      } else if (delta === 0) {\n        // single intersection point\n        from.lerp(to, delta, intersectionPoint);\n        intersectionPoint.vsub(position, normal);\n        normal.normalize();\n        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);\n      } else {\n        var d1 = (-b - Math.sqrt(delta)) / (2 * a);\n        var d2 = (-b + Math.sqrt(delta)) / (2 * a);\n        if (d1 >= 0 && d1 <= 1) {\n          from.lerp(to, d1, intersectionPoint);\n          intersectionPoint.vsub(position, normal);\n          normal.normalize();\n          this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);\n        }\n        if (this.result.shouldStop) {\n          return;\n        }\n        if (d2 >= 0 && d2 <= 1) {\n          from.lerp(to, d2, intersectionPoint);\n          intersectionPoint.vsub(position, normal);\n          normal.normalize();\n          this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);\n        }\n      }\n    }\n  }, {\n    key: \"_intersectConvex\",\n    value: function _intersectConvex(shape, quat, position, body, reportedShape, options) {\n      var normal = intersectConvex_normal;\n      var vector = intersectConvex_vector;\n      var faceList = options && options.faceList || null; // Checking faces\n\n      var faces = shape.faces;\n      var vertices = shape.vertices;\n      var normals = shape.faceNormals;\n      var direction = this.direction;\n      var from = this.from;\n      var to = this.to;\n      var fromToDistance = from.distanceTo(to);\n      var Nfaces = faceList ? faceList.length : faces.length;\n      var result = this.result;\n      for (var j = 0; !result.shouldStop && j < Nfaces; j++) {\n        var fi = faceList ? faceList[j] : j;\n        var face = faces[fi];\n        var faceNormal = normals[fi];\n        var _q2 = quat;\n        var x = position; // determine if ray intersects the plane of the face\n        // note: this works regardless of the direction of the face normal\n        // Get plane point in world coordinates...\n\n        vector.copy(vertices[face[0]]);\n        _q2.vmult(vector, vector);\n        vector.vadd(x, vector); // ...but make it relative to the ray from. We'll fix this later.\n\n        vector.vsub(from, vector); // Get plane normal\n\n        _q2.vmult(faceNormal, normal); // If this dot product is negative, we have something interesting\n\n        var dot = direction.dot(normal); // Bail out if ray and plane are parallel\n\n        if (Math.abs(dot) < this.precision) {\n          continue;\n        } // calc distance to plane\n\n        var scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray\n\n        if (scalar < 0) {\n          continue;\n        } // if (dot < 0) {\n        // Intersection point is from + direction * scalar\n\n        direction.scale(scalar, intersectPoint);\n        intersectPoint.vadd(from, intersectPoint); // a is the point we compare points b and c with.\n\n        a.copy(vertices[face[0]]);\n        _q2.vmult(a, a);\n        x.vadd(a, a);\n        for (var i = 1; !result.shouldStop && i < face.length - 1; i++) {\n          // Transform 3 vertices to world coords\n          b.copy(vertices[face[i]]);\n          c.copy(vertices[face[i + 1]]);\n          _q2.vmult(b, b);\n          _q2.vmult(c, c);\n          x.vadd(b, b);\n          x.vadd(c, c);\n          var distance = intersectPoint.distanceTo(from);\n          if (!(Ray.pointInTriangle(intersectPoint, a, b, c) || Ray.pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance) {\n            continue;\n          }\n          this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);\n        } // }\n      }\n    }\n    /**\n     * @todo Optimize by transforming the world to local space first.\n     * @todo Use Octree lookup\n     */\n  }, {\n    key: \"_intersectTrimesh\",\n    value: function _intersectTrimesh(mesh, quat, position, body, reportedShape, options) {\n      var normal = intersectTrimesh_normal;\n      var triangles = intersectTrimesh_triangles;\n      var treeTransform = intersectTrimesh_treeTransform;\n      var vector = intersectConvex_vector;\n      var localDirection = intersectTrimesh_localDirection;\n      var localFrom = intersectTrimesh_localFrom;\n      var localTo = intersectTrimesh_localTo;\n      var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;\n      var worldNormal = intersectTrimesh_worldNormal; // Checking faces\n\n      var indices = mesh.indices;\n      mesh.vertices; // const normals = mesh.faceNormals\n\n      var from = this.from;\n      var to = this.to;\n      var direction = this.direction;\n      treeTransform.position.copy(position);\n      treeTransform.quaternion.copy(quat); // Transform ray to local space!\n\n      Transform.vectorToLocalFrame(position, quat, direction, localDirection);\n      Transform.pointToLocalFrame(position, quat, from, localFrom);\n      Transform.pointToLocalFrame(position, quat, to, localTo);\n      localTo.x *= mesh.scale.x;\n      localTo.y *= mesh.scale.y;\n      localTo.z *= mesh.scale.z;\n      localFrom.x *= mesh.scale.x;\n      localFrom.y *= mesh.scale.y;\n      localFrom.z *= mesh.scale.z;\n      localTo.vsub(localFrom, localDirection);\n      localDirection.normalize();\n      var fromToDistanceSquared = localFrom.distanceSquared(localTo);\n      mesh.tree.rayQuery(this, treeTransform, triangles);\n      for (var i = 0, N = triangles.length; !this.result.shouldStop && i !== N; i++) {\n        var trianglesIndex = triangles[i];\n        mesh.getNormal(trianglesIndex, normal); // determine if ray intersects the plane of the face\n        // note: this works regardless of the direction of the face normal\n        // Get plane point in world coordinates...\n\n        mesh.getVertex(indices[trianglesIndex * 3], a); // ...but make it relative to the ray from. We'll fix this later.\n\n        a.vsub(localFrom, vector); // If this dot product is negative, we have something interesting\n\n        var dot = localDirection.dot(normal); // Bail out if ray and plane are parallel\n        // if (Math.abs( dot ) < this.precision){\n        //     continue;\n        // }\n        // calc distance to plane\n\n        var scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray\n\n        if (scalar < 0) {\n          continue;\n        } // Intersection point is from + direction * scalar\n\n        localDirection.scale(scalar, intersectPoint);\n        intersectPoint.vadd(localFrom, intersectPoint); // Get triangle vertices\n\n        mesh.getVertex(indices[trianglesIndex * 3 + 1], b);\n        mesh.getVertex(indices[trianglesIndex * 3 + 2], c);\n        var squaredDistance = intersectPoint.distanceSquared(localFrom);\n        if (!(Ray.pointInTriangle(intersectPoint, b, a, c) || Ray.pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared) {\n          continue;\n        } // transform intersectpoint and normal to world\n\n        Transform.vectorToWorldFrame(quat, normal, worldNormal);\n        Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);\n        this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);\n      }\n      triangles.length = 0;\n    }\n    /**\n     * @return True if the intersections should continue\n     */\n  }, {\n    key: \"reportIntersection\",\n    value: function reportIntersection(normal, hitPointWorld, shape, body, hitFaceIndex) {\n      var from = this.from;\n      var to = this.to;\n      var distance = from.distanceTo(hitPointWorld);\n      var result = this.result; // Skip back faces?\n\n      if (this.skipBackfaces && normal.dot(this.direction) > 0) {\n        return;\n      }\n      result.hitFaceIndex = typeof hitFaceIndex !== 'undefined' ? hitFaceIndex : -1;\n      switch (this.mode) {\n        case Ray.ALL:\n          this.hasHit = true;\n          result.set(from, to, normal, hitPointWorld, shape, body, distance);\n          result.hasHit = true;\n          this.callback(result);\n          break;\n        case Ray.CLOSEST:\n          // Store if closer than current closest\n          if (distance < result.distance || !result.hasHit) {\n            this.hasHit = true;\n            result.hasHit = true;\n            result.set(from, to, normal, hitPointWorld, shape, body, distance);\n          }\n          break;\n        case Ray.ANY:\n          // Report and stop.\n          this.hasHit = true;\n          result.hasHit = true;\n          result.set(from, to, normal, hitPointWorld, shape, body, distance);\n          result.shouldStop = true;\n          break;\n      }\n    }\n    /**\n     * As per \"Barycentric Technique\" as named\n     * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division\n     */\n  }], [{\n    key: \"pointInTriangle\",\n    value: function pointInTriangle(p, a, b, c) {\n      c.vsub(a, v0);\n      b.vsub(a, v1);\n      p.vsub(a, v2);\n      var dot00 = v0.dot(v0);\n      var dot01 = v0.dot(v1);\n      var dot02 = v0.dot(v2);\n      var dot11 = v1.dot(v1);\n      var dot12 = v1.dot(v2);\n      var u;\n      var v;\n      return (u = dot11 * dot02 - dot01 * dot12) >= 0 && (v = dot00 * dot12 - dot01 * dot02) >= 0 && u + v < dot00 * dot11 - dot01 * dot01;\n    }\n  }]);\n  return Ray;\n}(_Shape$types$SPHERE, _Shape$types$PLANE, _Shape$types$BOX, _Shape$types$CYLINDER, _Shape$types$CONVEXPO, _Shape$types$HEIGHTFI, _Shape$types$TRIMESH);\nRay.CLOSEST = RAY_MODES.CLOSEST;\nRay.ANY = RAY_MODES.ANY;\nRay.ALL = RAY_MODES.ALL;\nvar tmpAABB$1 = new AABB();\nvar tmpArray = [];\nvar v1 = new Vec3();\nvar v2 = new Vec3();\nvar intersectBody_xi = new Vec3();\nvar intersectBody_qi = new Quaternion();\nvar intersectPoint = new Vec3();\nvar a = new Vec3();\nvar b = new Vec3();\nvar c = new Vec3();\nnew Vec3();\nnew RaycastResult();\nvar intersectConvexOptions = {\n  faceList: [0]\n};\nvar worldPillarOffset = new Vec3();\nvar intersectHeightfield_localRay = new Ray();\nvar intersectHeightfield_index = [];\nvar Ray_intersectSphere_intersectionPoint = new Vec3();\nvar Ray_intersectSphere_normal = new Vec3();\nvar intersectConvex_normal = new Vec3();\nnew Vec3();\nnew Vec3();\nvar intersectConvex_vector = new Vec3();\nvar intersectTrimesh_normal = new Vec3();\nvar intersectTrimesh_localDirection = new Vec3();\nvar intersectTrimesh_localFrom = new Vec3();\nvar intersectTrimesh_localTo = new Vec3();\nvar intersectTrimesh_worldNormal = new Vec3();\nvar intersectTrimesh_worldIntersectPoint = new Vec3();\nnew AABB();\nvar intersectTrimesh_triangles = [];\nvar intersectTrimesh_treeTransform = new Transform();\nvar v0 = new Vec3();\nvar intersect = new Vec3();\nfunction distanceFromIntersection(from, direction, position) {\n  // v0 is vector from from to position\n  position.vsub(from, v0);\n  var dot = v0.dot(direction); // intersect = direction*dot + from\n\n  direction.scale(dot, intersect);\n  intersect.vadd(from, intersect);\n  var distance = position.distanceTo(intersect);\n  return distance;\n}\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3(); // Temp vectors\n\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Ray();\nnew Vec3();\nnew Vec3();\nnew Vec3();\n[new Vec3(1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, 0, 1)];\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3(); // bilateral constraint between two dynamic objects\nnew Vec3();\nnew Vec3();\nnew Vec3(); // Temp vectors for calculation\n\nnew Vec3(); // Relative velocity\n\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3(); // from https://en.wikipedia.org/wiki/Barycentric_coordinate_system\nnew Vec3();\nnew AABB();\nnew Vec3();\nnew AABB();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew AABB();\nnew Vec3();\nnew Transform();\nnew AABB();\n\n// Naming rule: based of the order in SHAPE_TYPES,\n// the first part of the method is formed by the\n// shape type that comes before, in the second part\n// there is the shape type that comes after in the SHAPE_TYPES list\n({\n  sphereSphere: Shape.types.SPHERE,\n  spherePlane: Shape.types.SPHERE | Shape.types.PLANE,\n  boxBox: Shape.types.BOX | Shape.types.BOX,\n  sphereBox: Shape.types.SPHERE | Shape.types.BOX,\n  planeBox: Shape.types.PLANE | Shape.types.BOX,\n  convexConvex: Shape.types.CONVEXPOLYHEDRON,\n  sphereConvex: Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON,\n  planeConvex: Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON,\n  boxConvex: Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON,\n  sphereHeightfield: Shape.types.SPHERE | Shape.types.HEIGHTFIELD,\n  boxHeightfield: Shape.types.BOX | Shape.types.HEIGHTFIELD,\n  convexHeightfield: Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD,\n  sphereParticle: Shape.types.PARTICLE | Shape.types.SPHERE,\n  planeParticle: Shape.types.PLANE | Shape.types.PARTICLE,\n  boxParticle: Shape.types.BOX | Shape.types.PARTICLE,\n  convexParticle: Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON,\n  cylinderCylinder: Shape.types.CYLINDER,\n  sphereCylinder: Shape.types.SPHERE | Shape.types.CYLINDER,\n  planeCylinder: Shape.types.PLANE | Shape.types.CYLINDER,\n  boxCylinder: Shape.types.BOX | Shape.types.CYLINDER,\n  convexCylinder: Shape.types.CONVEXPOLYHEDRON | Shape.types.CYLINDER,\n  heightfieldCylinder: Shape.types.HEIGHTFIELD | Shape.types.CYLINDER,\n  particleCylinder: Shape.types.PARTICLE | Shape.types.CYLINDER,\n  sphereTrimesh: Shape.types.SPHERE | Shape.types.TRIMESH,\n  planeTrimesh: Shape.types.PLANE | Shape.types.TRIMESH\n});\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Quaternion();\nnew Quaternion();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew AABB();\nnew Vec3();\nnew Vec3(); // See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html\n\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\n[new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3(); // WIP\n\nnew Quaternion();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew Vec3();\nnew AABB();\nnew Ray(); // performance.now() fallback on Date.now()\n\nvar performance = globalThis.performance || {};\nif (!performance.now) {\n  var _nowOffset = Date.now();\n  if (performance.timing && performance.timing.navigationStart) {\n    _nowOffset = performance.timing.navigationStart;\n  }\n  performance.now = function () {\n    return Date.now() - _nowOffset;\n  };\n}\nnew Vec3(); // Dispatched after the world has stepped forward in time.\n\nfunction CannonDebugger(scene, world, _temp) {\n  var _ref57 = _temp === void 0 ? {} : _temp,\n    _ref57$color = _ref57.color,\n    color = _ref57$color === void 0 ? 0x00ff00 : _ref57$color,\n    _ref57$scale = _ref57.scale,\n    scale = _ref57$scale === void 0 ? 1 : _ref57$scale,\n    onInit = _ref57.onInit,\n    onUpdate = _ref57.onUpdate;\n  var _meshes = [];\n  var _material = new MeshBasicMaterial({\n    color: color != null ? color : 0x00ff00,\n    wireframe: true\n  });\n  var _tempVec0 = new Vec3();\n  var _tempVec1 = new Vec3();\n  var _tempVec2 = new Vec3();\n  var _tempQuat0 = new Quaternion();\n  var _sphereGeometry = new SphereGeometry(1);\n  var _boxGeometry = new BoxGeometry(1, 1, 1);\n  var _planeGeometry = new PlaneGeometry(10, 10, 10, 10); // Move the planeGeometry forward a little bit to prevent z-fighting\n\n  _planeGeometry.translate(0, 0, 0.0001);\n  function createConvexPolyhedronGeometry(shape) {\n    var geometry = new BufferGeometry(); // Add vertices\n\n    var positions = [];\n    for (var i = 0; i < shape.vertices.length; i++) {\n      var vertex = shape.vertices[i];\n      positions.push(vertex.x, vertex.y, vertex.z);\n    }\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3)); // Add faces\n\n    var indices = [];\n    for (var _i12 = 0; _i12 < shape.faces.length; _i12++) {\n      var face = shape.faces[_i12];\n      var _a8 = face[0];\n      for (var j = 1; j < face.length - 1; j++) {\n        var _b7 = face[j];\n        var _c5 = face[j + 1];\n        indices.push(_a8, _b7, _c5);\n      }\n    }\n    geometry.setIndex(indices);\n    geometry.computeBoundingSphere();\n    geometry.computeVertexNormals();\n    return geometry;\n  }\n  function createTrimeshGeometry(shape) {\n    var geometry = new BufferGeometry();\n    var positions = [];\n    var v0 = _tempVec0;\n    var v1 = _tempVec1;\n    var v2 = _tempVec2;\n    for (var i = 0; i < shape.indices.length / 3; i++) {\n      shape.getTriangleVertices(i, v0, v1, v2);\n      positions.push(v0.x, v0.y, v0.z);\n      positions.push(v1.x, v1.y, v1.z);\n      positions.push(v2.x, v2.y, v2.z);\n    }\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    geometry.computeBoundingSphere();\n    geometry.computeVertexNormals();\n    return geometry;\n  }\n  function createHeightfieldGeometry(shape) {\n    var geometry = new BufferGeometry();\n    var s = shape.elementSize || 1; // assumes square heightfield, else i*x, j*y\n\n    var positions = shape.data.flatMap(function (row, i) {\n      return row.flatMap(function (z, j) {\n        return [i * s, j * s, z];\n      });\n    });\n    var indices = [];\n    for (var xi = 0; xi < shape.data.length - 1; xi++) {\n      for (var yi = 0; yi < shape.data[xi].length - 1; yi++) {\n        var stride = shape.data[xi].length;\n        var index = xi * stride + yi;\n        indices.push(index + 1, index + stride, index + stride + 1);\n        indices.push(index + stride, index + 1, index);\n      }\n    }\n    geometry.setIndex(indices);\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    geometry.computeBoundingSphere();\n    geometry.computeVertexNormals();\n    return geometry;\n  }\n  function createMesh(shape) {\n    var mesh = new Mesh();\n    var _Shape$types = Shape.types,\n      SPHERE = _Shape$types.SPHERE,\n      BOX = _Shape$types.BOX,\n      PLANE = _Shape$types.PLANE,\n      CYLINDER = _Shape$types.CYLINDER,\n      CONVEXPOLYHEDRON = _Shape$types.CONVEXPOLYHEDRON,\n      TRIMESH = _Shape$types.TRIMESH,\n      HEIGHTFIELD = _Shape$types.HEIGHTFIELD;\n    switch (shape.type) {\n      case SPHERE:\n        {\n          mesh = new Mesh(_sphereGeometry, _material);\n          break;\n        }\n      case BOX:\n        {\n          mesh = new Mesh(_boxGeometry, _material);\n          break;\n        }\n      case PLANE:\n        {\n          mesh = new Mesh(_planeGeometry, _material);\n          break;\n        }\n      case CYLINDER:\n        {\n          var geometry = new CylinderGeometry(shape.radiusTop, shape.radiusBottom, shape.height, shape.numSegments);\n          mesh = new Mesh(geometry, _material);\n          shape.geometryId = geometry.id;\n          break;\n        }\n      case CONVEXPOLYHEDRON:\n        {\n          var _geometry = createConvexPolyhedronGeometry(shape);\n          mesh = new Mesh(_geometry, _material);\n          shape.geometryId = _geometry.id;\n          break;\n        }\n      case TRIMESH:\n        {\n          var _geometry2 = createTrimeshGeometry(shape);\n          mesh = new Mesh(_geometry2, _material);\n          shape.geometryId = _geometry2.id;\n          break;\n        }\n      case HEIGHTFIELD:\n        {\n          var _geometry3 = createHeightfieldGeometry(shape);\n          mesh = new Mesh(_geometry3, _material);\n          shape.geometryId = _geometry3.id;\n          break;\n        }\n    }\n    scene.add(mesh);\n    return mesh;\n  }\n  function scaleMesh(mesh, shape) {\n    var _Shape$types2 = Shape.types,\n      SPHERE = _Shape$types2.SPHERE,\n      BOX = _Shape$types2.BOX,\n      PLANE = _Shape$types2.PLANE,\n      CYLINDER = _Shape$types2.CYLINDER,\n      CONVEXPOLYHEDRON = _Shape$types2.CONVEXPOLYHEDRON,\n      TRIMESH = _Shape$types2.TRIMESH,\n      HEIGHTFIELD = _Shape$types2.HEIGHTFIELD;\n    switch (shape.type) {\n      case SPHERE:\n        {\n          var radius = shape.radius;\n          mesh.scale.set(radius * scale, radius * scale, radius * scale);\n          break;\n        }\n      case BOX:\n        {\n          mesh.scale.copy(shape.halfExtents);\n          mesh.scale.multiplyScalar(2 * scale);\n          break;\n        }\n      case PLANE:\n        {\n          break;\n        }\n      case CYLINDER:\n        {\n          mesh.scale.set(1 * scale, 1 * scale, 1 * scale);\n          break;\n        }\n      case CONVEXPOLYHEDRON:\n        {\n          mesh.scale.set(1 * scale, 1 * scale, 1 * scale);\n          break;\n        }\n      case TRIMESH:\n        {\n          mesh.scale.copy(shape.scale).multiplyScalar(scale);\n          break;\n        }\n      case HEIGHTFIELD:\n        {\n          mesh.scale.set(1 * scale, 1 * scale, 1 * scale);\n          break;\n        }\n    }\n  }\n  function typeMatch(mesh, shape) {\n    if (!mesh) return false;\n    var geometry = mesh.geometry;\n    return geometry instanceof SphereGeometry && shape.type === Shape.types.SPHERE || geometry instanceof BoxGeometry && shape.type === Shape.types.BOX || geometry instanceof PlaneGeometry && shape.type === Shape.types.PLANE || geometry.id === shape.geometryId && shape.type === Shape.types.CYLINDER || geometry.id === shape.geometryId && shape.type === Shape.types.CONVEXPOLYHEDRON || geometry.id === shape.geometryId && shape.type === Shape.types.TRIMESH || geometry.id === shape.geometryId && shape.type === Shape.types.HEIGHTFIELD;\n  }\n  function updateMesh(index, shape) {\n    var mesh = _meshes[index];\n    var didCreateNewMesh = false;\n    if (!typeMatch(mesh, shape)) {\n      if (mesh) scene.remove(mesh);\n      _meshes[index] = mesh = createMesh(shape);\n      didCreateNewMesh = true;\n    }\n    scaleMesh(mesh, shape);\n    return didCreateNewMesh;\n  }\n  function update() {\n    var meshes = _meshes;\n    var shapeWorldPosition = _tempVec0;\n    var shapeWorldQuaternion = _tempQuat0;\n    var meshIndex = 0;\n    var _iterator2 = _createForOfIteratorHelper(world.bodies),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var body = _step2.value;\n        for (var _i13 = 0; _i13 !== body.shapes.length; _i13++) {\n          var shape = body.shapes[_i13];\n          var didCreateNewMesh = updateMesh(meshIndex, shape);\n          var _mesh = meshes[meshIndex];\n          if (_mesh) {\n            // Get world position\n            body.quaternion.vmult(body.shapeOffsets[_i13], shapeWorldPosition);\n            body.position.vadd(shapeWorldPosition, shapeWorldPosition); // Get world quaternion\n\n            body.quaternion.mult(body.shapeOrientations[_i13], shapeWorldQuaternion); // Copy to meshes\n\n            _mesh.position.copy(shapeWorldPosition);\n            _mesh.quaternion.copy(shapeWorldQuaternion);\n            if (didCreateNewMesh && onInit instanceof Function) onInit(body, _mesh, shape);\n            if (!didCreateNewMesh && onUpdate instanceof Function) onUpdate(body, _mesh, shape);\n          }\n          meshIndex++;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    for (var i = meshIndex; i < meshes.length; i++) {\n      var mesh = meshes[i];\n      if (mesh) scene.remove(mesh);\n    }\n    meshes.length = meshIndex;\n  }\n  return {\n    update: update\n  };\n}\nvar debugContext = /*#__PURE__*/createContext(null);\nvar useDebugContext = function useDebugContext() {\n  return useContext(debugContext);\n};\nvar physicsContext = /*#__PURE__*/createContext(null);\nvar usePhysicsContext = function usePhysicsContext() {\n  var context = useContext(physicsContext);\n  if (!context) throw new Error('Physics context not found. @react-three/cannon & components can only be used within a Physics provider');\n  return context;\n};\nvar q$2 = new Quaternion$2();\nvar s$1 = new Vector3(1, 1, 1);\nvar v$1 = new Vector3();\nvar m$1 = new Matrix4();\nvar getMatrix = function getMatrix(o) {\n  if (o instanceof InstancedMesh) {\n    o.getMatrixAt(parseInt(o.uuid.split('/')[1]), m$1);\n    return m$1;\n  }\n  return o.matrix;\n};\nfunction DebugProvider(_ref) {\n  var children = _ref.children,\n    _ref$color = _ref.color,\n    color = _ref$color === void 0 ? 'black' : _ref$color,\n    _ref$impl = _ref.impl,\n    impl = _ref$impl === void 0 ? CannonDebugger : _ref$impl,\n    _ref$scale = _ref.scale,\n    scale = _ref$scale === void 0 ? 1 : _ref$scale;\n  var _useState = useState({\n      bodies: [],\n      bodyMap: {}\n    }),\n    _useState2 = _slicedToArray(_useState, 1),\n    _useState2$ = _useState2[0],\n    bodies = _useState2$.bodies,\n    bodyMap = _useState2$.bodyMap;\n  var _usePhysicsContext = usePhysicsContext(),\n    refs = _usePhysicsContext.refs;\n  var _useState3 = useState(function () {\n      return new Scene();\n    }),\n    _useState4 = _slicedToArray(_useState3, 1),\n    scene = _useState4[0];\n  var cannonDebuggerRef = useRef(impl(scene, {\n    bodies: bodies\n  }, {\n    color: color,\n    scale: scale\n  }));\n  useFrame(function () {\n    for (var uuid in bodyMap) {\n      getMatrix(refs[uuid]).decompose(v$1, q$2, s$1);\n      bodyMap[uuid].position.copy(v$1);\n      bodyMap[uuid].quaternion.copy(q$2);\n    }\n    cannonDebuggerRef.current.update();\n  });\n  var api = useMemo(function () {\n    return {\n      add: function add(uuid, props, type) {\n        var body = propsToBody({\n          props: props,\n          type: type,\n          uuid: uuid\n        });\n        bodies.push(body);\n        bodyMap[uuid] = body;\n      },\n      remove: function remove(uuid) {\n        var index = bodies.indexOf(bodyMap[uuid]);\n        if (index !== -1) bodies.splice(index, 1);\n        delete bodyMap[uuid];\n      }\n    };\n  }, [bodies, bodyMap]);\n  return /*#__PURE__*/jsxs(debugContext.Provider, {\n    value: api,\n    children: [/*#__PURE__*/jsx(\"primitive\", {\n      object: scene\n    }), children]\n  });\n}\nvar temp = new Object3D();\nfunction useForwardedRef(ref) {\n  var nullRef = useRef(null);\n  return ref && typeof ref !== 'function' ? ref : nullRef;\n}\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction getUUID(ref, index) {\n  var suffix = index === undefined ? '' : \"/\".concat(index);\n  if (typeof ref === 'function') return null;\n  return ref && ref.current && \"\".concat(ref.current.uuid).concat(suffix);\n}\nvar e = new Euler();\nvar q$1 = new Quaternion$2();\nvar quaternionToRotation = function quaternionToRotation(callback) {\n  return function (v) {\n    return callback(e.setFromQuaternion(q$1.fromArray(v)).toArray());\n  };\n};\nvar incrementingId = 0;\nfunction subscribe(ref, worker, subscriptions, type, index, target) {\n  if (target === void 0) {\n    target = 'bodies';\n  }\n  return function (callback) {\n    var id = incrementingId++;\n    subscriptions[id] = _defineProperty({}, type, callback);\n    var uuid = getUUID(ref, index);\n    uuid && worker.subscribe({\n      props: {\n        id: id,\n        target: target,\n        type: type\n      },\n      uuid: uuid\n    });\n    return function () {\n      delete subscriptions[id];\n      worker.unsubscribe({\n        props: id\n      });\n    };\n  };\n}\nfunction prepare(object, _ref) {\n  var _object$position, _object$rotation;\n  var _ref$position = _ref.position,\n    position = _ref$position === void 0 ? [0, 0, 0] : _ref$position,\n    _ref$rotation = _ref.rotation,\n    rotation = _ref$rotation === void 0 ? [0, 0, 0] : _ref$rotation,\n    _ref$userData = _ref.userData,\n    userData = _ref$userData === void 0 ? {} : _ref$userData;\n  object.userData = userData;\n  (_object$position = object.position).set.apply(_object$position, _toConsumableArray(position));\n  (_object$rotation = object.rotation).set.apply(_object$rotation, _toConsumableArray(rotation));\n  object.updateMatrix();\n}\nfunction setupCollision(events, _ref2, uuid) {\n  var onCollide = _ref2.onCollide,\n    onCollideBegin = _ref2.onCollideBegin,\n    onCollideEnd = _ref2.onCollideEnd;\n  events[uuid] = {\n    collide: onCollide,\n    collideBegin: onCollideBegin,\n    collideEnd: onCollideEnd\n  };\n}\nfunction useBody(type, fn, argsFn, fwdRef, deps) {\n  if (fwdRef === void 0) {\n    fwdRef = null;\n  }\n  if (deps === void 0) {\n    deps = [];\n  }\n  var ref = useForwardedRef(fwdRef);\n  var _usePhysicsContext2 = usePhysicsContext(),\n    events = _usePhysicsContext2.events,\n    refs = _usePhysicsContext2.refs,\n    scaleOverrides = _usePhysicsContext2.scaleOverrides,\n    subscriptions = _usePhysicsContext2.subscriptions,\n    worker = _usePhysicsContext2.worker;\n  var debugApi = useDebugContext();\n  useLayoutEffect(function () {\n    if (!ref.current) {\n      // When the reference isn't used we create a stub\n      // The body doesn't have a visual representation but can still be constrained\n      // Yes, this type may be technically incorrect\n      ref.current = new Object3D();\n    }\n    var object = ref.current;\n    var currentWorker = worker;\n    var objectCount = object instanceof InstancedMesh ? (object.instanceMatrix.setUsage(DynamicDrawUsage), object.count) : 1;\n    var uuid = object instanceof InstancedMesh ? new Array(objectCount).fill(0).map(function (_, i) {\n      return \"\".concat(object.uuid, \"/\").concat(i);\n    }) : [object.uuid];\n    var props = object instanceof InstancedMesh ? uuid.map(function (id, i) {\n      var props = fn(i);\n      prepare(temp, props);\n      object.setMatrixAt(i, temp.matrix);\n      object.instanceMatrix.needsUpdate = true;\n      refs[id] = object;\n      debugApi == null ? void 0 : debugApi.add(id, props, type);\n      setupCollision(events, props, id);\n      return _objectSpread(_objectSpread({}, props), {}, {\n        args: argsFn(props.args)\n      });\n    }) : uuid.map(function (id, i) {\n      var props = fn(i);\n      prepare(object, props);\n      refs[id] = object;\n      debugApi == null ? void 0 : debugApi.add(id, props, type);\n      setupCollision(events, props, id);\n      return _objectSpread(_objectSpread({}, props), {}, {\n        args: argsFn(props.args)\n      });\n    });\n\n    // Register on mount, unregister on unmount\n    currentWorker.addBodies({\n      props: props.map(function (_ref3) {\n        var onCollide = _ref3.onCollide,\n          onCollideBegin = _ref3.onCollideBegin,\n          onCollideEnd = _ref3.onCollideEnd,\n          serializableProps = _objectWithoutProperties(_ref3, _excluded3);\n        return _objectSpread({\n          onCollide: Boolean(onCollide)\n        }, serializableProps);\n      }),\n      type: type,\n      uuid: uuid\n    });\n    return function () {\n      uuid.forEach(function (id) {\n        delete refs[id];\n        debugApi == null ? void 0 : debugApi.remove(id);\n        delete events[id];\n      });\n      currentWorker.removeBodies({\n        uuid: uuid\n      });\n    };\n  }, deps);\n  var api = useMemo(function () {\n    var makeAtomic = function makeAtomic(type, index) {\n      var op = \"set\".concat(capitalize(type));\n      return {\n        set: function set(value) {\n          var uuid = getUUID(ref, index);\n          uuid && worker[op]({\n            props: value,\n            uuid: uuid\n          });\n        },\n        subscribe: subscribe(ref, worker, subscriptions, type, index)\n      };\n    };\n    var makeQuaternion = function makeQuaternion(index) {\n      var type = 'quaternion';\n      return {\n        copy: function copy(_ref4) {\n          var w = _ref4.w,\n            x = _ref4.x,\n            y = _ref4.y,\n            z = _ref4.z;\n          var uuid = getUUID(ref, index);\n          uuid && worker.setQuaternion({\n            props: [x, y, z, w],\n            uuid: uuid\n          });\n        },\n        set: function set(x, y, z, w) {\n          var uuid = getUUID(ref, index);\n          uuid && worker.setQuaternion({\n            props: [x, y, z, w],\n            uuid: uuid\n          });\n        },\n        subscribe: subscribe(ref, worker, subscriptions, type, index)\n      };\n    };\n    var makeRotation = function makeRotation(index) {\n      return {\n        copy: function copy(_ref5) {\n          var x = _ref5.x,\n            y = _ref5.y,\n            z = _ref5.z;\n          var uuid = getUUID(ref, index);\n          uuid && worker.setRotation({\n            props: [x, y, z],\n            uuid: uuid\n          });\n        },\n        set: function set(x, y, z) {\n          var uuid = getUUID(ref, index);\n          uuid && worker.setRotation({\n            props: [x, y, z],\n            uuid: uuid\n          });\n        },\n        subscribe: function subscribe(callback) {\n          var id = incrementingId++;\n          var target = 'bodies';\n          var type = 'quaternion';\n          var uuid = getUUID(ref, index);\n          subscriptions[id] = _defineProperty({}, type, quaternionToRotation(callback));\n          uuid && worker.subscribe({\n            props: {\n              id: id,\n              target: target,\n              type: type\n            },\n            uuid: uuid\n          });\n          return function () {\n            delete subscriptions[id];\n            worker.unsubscribe({\n              props: id\n            });\n          };\n        }\n      };\n    };\n    var makeVec = function makeVec(type, index) {\n      var op = \"set\".concat(capitalize(type));\n      return {\n        copy: function copy(_ref6) {\n          var x = _ref6.x,\n            y = _ref6.y,\n            z = _ref6.z;\n          var uuid = getUUID(ref, index);\n          uuid && worker[op]({\n            props: [x, y, z],\n            uuid: uuid\n          });\n        },\n        set: function set(x, y, z) {\n          var uuid = getUUID(ref, index);\n          uuid && worker[op]({\n            props: [x, y, z],\n            uuid: uuid\n          });\n        },\n        subscribe: subscribe(ref, worker, subscriptions, type, index)\n      };\n    };\n    function makeApi(index) {\n      return {\n        allowSleep: makeAtomic('allowSleep', index),\n        angularDamping: makeAtomic('angularDamping', index),\n        angularFactor: makeVec('angularFactor', index),\n        angularVelocity: makeVec('angularVelocity', index),\n        applyForce: function applyForce(force, worldPoint) {\n          var uuid = getUUID(ref, index);\n          uuid && worker.applyForce({\n            props: [force, worldPoint],\n            uuid: uuid\n          });\n        },\n        applyImpulse: function applyImpulse(impulse, worldPoint) {\n          var uuid = getUUID(ref, index);\n          uuid && worker.applyImpulse({\n            props: [impulse, worldPoint],\n            uuid: uuid\n          });\n        },\n        applyLocalForce: function applyLocalForce(force, localPoint) {\n          var uuid = getUUID(ref, index);\n          uuid && worker.applyLocalForce({\n            props: [force, localPoint],\n            uuid: uuid\n          });\n        },\n        applyLocalImpulse: function applyLocalImpulse(impulse, localPoint) {\n          var uuid = getUUID(ref, index);\n          uuid && worker.applyLocalImpulse({\n            props: [impulse, localPoint],\n            uuid: uuid\n          });\n        },\n        applyTorque: function applyTorque(torque) {\n          var uuid = getUUID(ref, index);\n          uuid && worker.applyTorque({\n            props: [torque],\n            uuid: uuid\n          });\n        },\n        collisionFilterGroup: makeAtomic('collisionFilterGroup', index),\n        collisionFilterMask: makeAtomic('collisionFilterMask', index),\n        collisionResponse: makeAtomic('collisionResponse', index),\n        fixedRotation: makeAtomic('fixedRotation', index),\n        isTrigger: makeAtomic('isTrigger', index),\n        linearDamping: makeAtomic('linearDamping', index),\n        linearFactor: makeVec('linearFactor', index),\n        mass: makeAtomic('mass', index),\n        material: makeAtomic('material', index),\n        position: makeVec('position', index),\n        quaternion: makeQuaternion(index),\n        rotation: makeRotation(index),\n        scaleOverride: function scaleOverride(scale) {\n          var uuid = getUUID(ref, index);\n          if (uuid) scaleOverrides[uuid] = _construct(Vector3, _toConsumableArray(scale));\n        },\n        sleep: function sleep() {\n          var uuid = getUUID(ref, index);\n          uuid && worker.sleep({\n            uuid: uuid\n          });\n        },\n        sleepSpeedLimit: makeAtomic('sleepSpeedLimit', index),\n        sleepTimeLimit: makeAtomic('sleepTimeLimit', index),\n        userData: makeAtomic('userData', index),\n        velocity: makeVec('velocity', index),\n        wakeUp: function wakeUp() {\n          var uuid = getUUID(ref, index);\n          uuid && worker.wakeUp({\n            uuid: uuid\n          });\n        }\n      };\n    }\n    var cache = {};\n    return _objectSpread(_objectSpread({}, makeApi(undefined)), {}, {\n      at: function at(index) {\n        return cache[index] || (cache[index] = makeApi(index));\n      }\n    });\n  }, []);\n  return [ref, api];\n}\nfunction makeTriplet(v) {\n  return v instanceof Vector3 ? [v.x, v.y, v.z] : v;\n}\nfunction usePlane(fn, fwdRef, deps) {\n  return useBody('Plane', fn, function () {\n    return [];\n  }, fwdRef, deps);\n}\nfunction useBox(fn, fwdRef, deps) {\n  var defaultBoxArgs = [1, 1, 1];\n  return useBody('Box', fn, function (args) {\n    if (args === void 0) {\n      args = defaultBoxArgs;\n    }\n    return args;\n  }, fwdRef, deps);\n}\nfunction useCylinder(fn, fwdRef, deps) {\n  return useBody('Cylinder', fn, function (args) {\n    if (args === void 0) {\n      args = [];\n    }\n    return args;\n  }, fwdRef, deps);\n}\nfunction useHeightfield(fn, fwdRef, deps) {\n  return useBody('Heightfield', fn, function (args) {\n    return args;\n  }, fwdRef, deps);\n}\nfunction useParticle(fn, fwdRef, deps) {\n  return useBody('Particle', fn, function () {\n    return [];\n  }, fwdRef, deps);\n}\nfunction useSphere(fn, fwdRef, deps) {\n  return useBody('Sphere', fn, function (args) {\n    if (args === void 0) {\n      args = [1];\n    }\n    if (!Array.isArray(args)) throw new Error('useSphere args must be an array');\n    return [args[0]];\n  }, fwdRef, deps);\n}\nfunction useTrimesh(fn, fwdRef, deps) {\n  return useBody('Trimesh', fn, function (args) {\n    return args;\n  }, fwdRef, deps);\n}\nfunction useConvexPolyhedron(fn, fwdRef, deps) {\n  return useBody('ConvexPolyhedron', fn, function (_temp) {\n    var _ref58 = _temp === void 0 ? [] : _temp,\n      _ref59 = _slicedToArray(_ref58, 5),\n      vertices = _ref59[0],\n      faces = _ref59[1],\n      normals = _ref59[2],\n      axes = _ref59[3],\n      boundingSphereRadius = _ref59[4];\n    return [vertices && vertices.map(makeTriplet), faces, normals && normals.map(makeTriplet), axes && axes.map(makeTriplet), boundingSphereRadius];\n  }, fwdRef, deps);\n}\nfunction useCompoundBody(fn, fwdRef, deps) {\n  return useBody('Compound', fn, function (args) {\n    return args;\n  }, fwdRef, deps);\n}\nfunction useConstraint(type, bodyA, bodyB, optns, deps) {\n  if (optns === void 0) {\n    optns = {};\n  }\n  if (deps === void 0) {\n    deps = [];\n  }\n  var _usePhysicsContext3 = usePhysicsContext(),\n    worker = _usePhysicsContext3.worker;\n  var uuid = MathUtils.generateUUID();\n  var refA = useForwardedRef(bodyA);\n  var refB = useForwardedRef(bodyB);\n  useEffect(function () {\n    if (refA.current && refB.current) {\n      worker.addConstraint({\n        props: [refA.current.uuid, refB.current.uuid, optns],\n        type: type,\n        uuid: uuid\n      });\n      return function () {\n        return worker.removeConstraint({\n          uuid: uuid\n        });\n      };\n    }\n  }, deps);\n  var api = useMemo(function () {\n    var enableDisable = {\n      disable: function disable() {\n        return worker.disableConstraint({\n          uuid: uuid\n        });\n      },\n      enable: function enable() {\n        return worker.enableConstraint({\n          uuid: uuid\n        });\n      }\n    };\n    if (type === 'Hinge') {\n      return _objectSpread(_objectSpread({}, enableDisable), {}, {\n        disableMotor: function disableMotor() {\n          return worker.disableConstraintMotor({\n            uuid: uuid\n          });\n        },\n        enableMotor: function enableMotor() {\n          return worker.enableConstraintMotor({\n            uuid: uuid\n          });\n        },\n        setMotorMaxForce: function setMotorMaxForce(value) {\n          return worker.setConstraintMotorMaxForce({\n            props: value,\n            uuid: uuid\n          });\n        },\n        setMotorSpeed: function setMotorSpeed(value) {\n          return worker.setConstraintMotorSpeed({\n            props: value,\n            uuid: uuid\n          });\n        }\n      });\n    }\n    return enableDisable;\n  }, deps);\n  return [refA, refB, api];\n}\nfunction usePointToPointConstraint(bodyA, bodyB, optns, deps) {\n  if (bodyA === void 0) {\n    bodyA = null;\n  }\n  if (bodyB === void 0) {\n    bodyB = null;\n  }\n  if (deps === void 0) {\n    deps = [];\n  }\n  return useConstraint('PointToPoint', bodyA, bodyB, optns, deps);\n}\nfunction useConeTwistConstraint(bodyA, bodyB, optns, deps) {\n  if (bodyA === void 0) {\n    bodyA = null;\n  }\n  if (bodyB === void 0) {\n    bodyB = null;\n  }\n  if (deps === void 0) {\n    deps = [];\n  }\n  return useConstraint('ConeTwist', bodyA, bodyB, optns, deps);\n}\nfunction useDistanceConstraint(bodyA, bodyB, optns, deps) {\n  if (bodyA === void 0) {\n    bodyA = null;\n  }\n  if (bodyB === void 0) {\n    bodyB = null;\n  }\n  if (deps === void 0) {\n    deps = [];\n  }\n  return useConstraint('Distance', bodyA, bodyB, optns, deps);\n}\nfunction useHingeConstraint(bodyA, bodyB, optns, deps) {\n  if (bodyA === void 0) {\n    bodyA = null;\n  }\n  if (bodyB === void 0) {\n    bodyB = null;\n  }\n  if (deps === void 0) {\n    deps = [];\n  }\n  return useConstraint('Hinge', bodyA, bodyB, optns, deps);\n}\nfunction useLockConstraint(bodyA, bodyB, optns, deps) {\n  if (bodyA === void 0) {\n    bodyA = null;\n  }\n  if (bodyB === void 0) {\n    bodyB = null;\n  }\n  if (deps === void 0) {\n    deps = [];\n  }\n  return useConstraint('Lock', bodyA, bodyB, optns, deps);\n}\nfunction useSpring(bodyA, bodyB, optns, deps) {\n  if (bodyA === void 0) {\n    bodyA = null;\n  }\n  if (bodyB === void 0) {\n    bodyB = null;\n  }\n  if (deps === void 0) {\n    deps = [];\n  }\n  var _usePhysicsContext4 = usePhysicsContext(),\n    worker = _usePhysicsContext4.worker;\n  var _useState5 = useState(function () {\n      return MathUtils.generateUUID();\n    }),\n    _useState6 = _slicedToArray(_useState5, 1),\n    uuid = _useState6[0];\n  var refA = useForwardedRef(bodyA);\n  var refB = useForwardedRef(bodyB);\n  useEffect(function () {\n    if (refA.current && refB.current) {\n      worker.addSpring({\n        props: [refA.current.uuid, refB.current.uuid, optns],\n        uuid: uuid\n      });\n      return function () {\n        worker.removeSpring({\n          uuid: uuid\n        });\n      };\n    }\n  }, deps);\n  var api = useMemo(function () {\n    return {\n      setDamping: function setDamping(value) {\n        return worker.setSpringDamping({\n          props: value,\n          uuid: uuid\n        });\n      },\n      setRestLength: function setRestLength(value) {\n        return worker.setSpringRestLength({\n          props: value,\n          uuid: uuid\n        });\n      },\n      setStiffness: function setStiffness(value) {\n        return worker.setSpringStiffness({\n          props: value,\n          uuid: uuid\n        });\n      }\n    };\n  }, deps);\n  return [refA, refB, api];\n}\nfunction useRay(mode, options, callback, deps) {\n  if (deps === void 0) {\n    deps = [];\n  }\n  var _usePhysicsContext5 = usePhysicsContext(),\n    worker = _usePhysicsContext5.worker,\n    events = _usePhysicsContext5.events;\n  var _useState7 = useState(function () {\n      return MathUtils.generateUUID();\n    }),\n    _useState8 = _slicedToArray(_useState7, 1),\n    uuid = _useState8[0];\n  useEffect(function () {\n    events[uuid] = {\n      rayhit: callback\n    };\n    worker.addRay({\n      props: _objectSpread(_objectSpread({}, options), {}, {\n        mode: mode\n      }),\n      uuid: uuid\n    });\n    return function () {\n      worker.removeRay({\n        uuid: uuid\n      });\n      delete events[uuid];\n    };\n  }, deps);\n}\nfunction useRaycastClosest(options, callback, deps) {\n  if (deps === void 0) {\n    deps = [];\n  }\n  useRay('Closest', options, callback, deps);\n}\nfunction useRaycastAny(options, callback, deps) {\n  if (deps === void 0) {\n    deps = [];\n  }\n  useRay('Any', options, callback, deps);\n}\nfunction useRaycastAll(options, callback, deps) {\n  if (deps === void 0) {\n    deps = [];\n  }\n  useRay('All', options, callback, deps);\n}\nfunction isString(v) {\n  return typeof v === 'string';\n}\nfunction useRaycastVehicle(fn, fwdRef, deps) {\n  if (fwdRef === void 0) {\n    fwdRef = null;\n  }\n  if (deps === void 0) {\n    deps = [];\n  }\n  var ref = useForwardedRef(fwdRef);\n  var _usePhysicsContext6 = usePhysicsContext(),\n    worker = _usePhysicsContext6.worker,\n    subscriptions = _usePhysicsContext6.subscriptions;\n  useLayoutEffect(function () {\n    if (!ref.current) {\n      // When the reference isn't used we create a stub\n      // The body doesn't have a visual representation but can still be constrained\n      // Yes, this type may be technically incorrect\n      ref.current = new Object3D();\n    }\n    var currentWorker = worker;\n    var uuid = ref.current.uuid;\n    var _fn = fn(),\n      chassisBody = _fn.chassisBody,\n      _fn$indexForwardAxis = _fn.indexForwardAxis,\n      indexForwardAxis = _fn$indexForwardAxis === void 0 ? 2 : _fn$indexForwardAxis,\n      _fn$indexRightAxis = _fn.indexRightAxis,\n      indexRightAxis = _fn$indexRightAxis === void 0 ? 0 : _fn$indexRightAxis,\n      _fn$indexUpAxis = _fn.indexUpAxis,\n      indexUpAxis = _fn$indexUpAxis === void 0 ? 1 : _fn$indexUpAxis,\n      wheelInfos = _fn.wheelInfos,\n      wheels = _fn.wheels;\n    var chassisBodyUUID = getUUID(chassisBody);\n    var wheelUUIDs = wheels.map(function (ref) {\n      return getUUID(ref);\n    });\n    if (!chassisBodyUUID || !wheelUUIDs.every(isString)) return;\n    currentWorker.addRaycastVehicle({\n      props: [chassisBodyUUID, wheelUUIDs, wheelInfos, indexForwardAxis, indexRightAxis, indexUpAxis],\n      uuid: uuid\n    });\n    return function () {\n      currentWorker.removeRaycastVehicle({\n        uuid: uuid\n      });\n    };\n  }, deps);\n  var api = useMemo(function () {\n    return {\n      applyEngineForce: function applyEngineForce(value, wheelIndex) {\n        var uuid = getUUID(ref);\n        uuid && worker.applyRaycastVehicleEngineForce({\n          props: [value, wheelIndex],\n          uuid: uuid\n        });\n      },\n      setBrake: function setBrake(brake, wheelIndex) {\n        var uuid = getUUID(ref);\n        uuid && worker.setRaycastVehicleBrake({\n          props: [brake, wheelIndex],\n          uuid: uuid\n        });\n      },\n      setSteeringValue: function setSteeringValue(value, wheelIndex) {\n        var uuid = getUUID(ref);\n        uuid && worker.setRaycastVehicleSteeringValue({\n          props: [value, wheelIndex],\n          uuid: uuid\n        });\n      },\n      sliding: {\n        subscribe: subscribe(ref, worker, subscriptions, 'sliding', undefined, 'vehicles')\n      }\n    };\n  }, deps);\n  return [ref, api];\n}\nfunction useContactMaterial(materialA, materialB, options, deps) {\n  if (deps === void 0) {\n    deps = [];\n  }\n  var _usePhysicsContext7 = usePhysicsContext(),\n    worker = _usePhysicsContext7.worker;\n  var _useState9 = useState(function () {\n      return MathUtils.generateUUID();\n    }),\n    _useState10 = _slicedToArray(_useState9, 1),\n    uuid = _useState10[0];\n  useEffect(function () {\n    worker.addContactMaterial({\n      props: [materialA, materialB, options],\n      uuid: uuid\n    });\n    return function () {\n      worker.removeContactMaterial({\n        uuid: uuid\n      });\n    };\n  }, deps);\n}\nvar v = new Vector3();\nvar s = new Vector3(1, 1, 1);\nvar q = new Quaternion$2();\nvar m = new Matrix4();\nfunction apply(index, positions, quaternions, scale, object) {\n  if (scale === void 0) {\n    scale = s;\n  }\n  if (index !== undefined) {\n    m.compose(v.fromArray(positions, index * 3), q.fromArray(quaternions, index * 4), scale);\n    if (object) {\n      object.matrixAutoUpdate = false;\n      object.matrix.copy(m);\n    }\n    return m;\n  }\n  return m.identity();\n}\nfunction PhysicsProvider(_ref) {\n  var _ref$allowSleep2 = _ref.allowSleep,\n    allowSleep = _ref$allowSleep2 === void 0 ? false : _ref$allowSleep2,\n    _ref$axisIndex2 = _ref.axisIndex,\n    axisIndex = _ref$axisIndex2 === void 0 ? 0 : _ref$axisIndex2,\n    _ref$broadphase2 = _ref.broadphase,\n    broadphase = _ref$broadphase2 === void 0 ? 'Naive' : _ref$broadphase2,\n    children = _ref.children,\n    _ref$defaultContactMa2 = _ref.defaultContactMaterial,\n    defaultContactMaterial = _ref$defaultContactMa2 === void 0 ? {\n      contactEquationStiffness: 1e6\n    } : _ref$defaultContactMa2,\n    _ref$frictionGravity2 = _ref.frictionGravity,\n    frictionGravity = _ref$frictionGravity2 === void 0 ? null : _ref$frictionGravity2,\n    _ref$gravity2 = _ref.gravity,\n    gravity = _ref$gravity2 === void 0 ? [0, -9.81, 0] : _ref$gravity2,\n    _ref$isPaused = _ref.isPaused,\n    isPaused = _ref$isPaused === void 0 ? false : _ref$isPaused,\n    _ref$iterations2 = _ref.iterations,\n    iterations = _ref$iterations2 === void 0 ? 5 : _ref$iterations2,\n    _ref$maxSubSteps = _ref.maxSubSteps,\n    maxSubSteps = _ref$maxSubSteps === void 0 ? 10 : _ref$maxSubSteps,\n    _ref$quatNormalizeFas2 = _ref.quatNormalizeFast,\n    quatNormalizeFast = _ref$quatNormalizeFas2 === void 0 ? false : _ref$quatNormalizeFas2,\n    _ref$quatNormalizeSki2 = _ref.quatNormalizeSkip,\n    quatNormalizeSkip = _ref$quatNormalizeSki2 === void 0 ? 0 : _ref$quatNormalizeSki2,\n    _ref$shouldInvalidate = _ref.shouldInvalidate,\n    shouldInvalidate = _ref$shouldInvalidate === void 0 ? true : _ref$shouldInvalidate,\n    _ref$size2 = _ref.size,\n    size = _ref$size2 === void 0 ? 1000 : _ref$size2,\n    _ref$solver2 = _ref.solver,\n    solver = _ref$solver2 === void 0 ? 'GS' : _ref$solver2,\n    _ref$stepSize = _ref.stepSize,\n    stepSize = _ref$stepSize === void 0 ? 1 / 60 : _ref$stepSize,\n    _ref$tolerance2 = _ref.tolerance,\n    tolerance = _ref$tolerance2 === void 0 ? 0.001 : _ref$tolerance2;\n  var _useThree = useThree(),\n    invalidate = _useThree.invalidate;\n  var _useState11 = useState(function () {\n      return {\n        bodies: {},\n        events: {},\n        refs: {},\n        scaleOverrides: {},\n        subscriptions: {},\n        worker: new CannonWorkerAPI({\n          allowSleep: allowSleep,\n          axisIndex: axisIndex,\n          broadphase: broadphase,\n          defaultContactMaterial: defaultContactMaterial,\n          frictionGravity: frictionGravity,\n          gravity: gravity,\n          iterations: iterations,\n          quatNormalizeFast: quatNormalizeFast,\n          quatNormalizeSkip: quatNormalizeSkip,\n          size: size,\n          solver: solver,\n          tolerance: tolerance\n        })\n      };\n    }),\n    _useState12 = _slicedToArray(_useState11, 1),\n    _useState12$ = _useState12[0],\n    bodies = _useState12$.bodies,\n    events = _useState12$.events,\n    refs = _useState12$.refs,\n    scaleOverrides = _useState12$.scaleOverrides,\n    subscriptions = _useState12$.subscriptions,\n    worker = _useState12$.worker;\n  var timeSinceLastCalled = 0;\n  var loop = useCallback(function (_, delta) {\n    if (isPaused) return;\n    timeSinceLastCalled += delta;\n    worker.step({\n      maxSubSteps: maxSubSteps,\n      stepSize: stepSize,\n      timeSinceLastCalled: timeSinceLastCalled\n    });\n    timeSinceLastCalled = 0;\n  }, [isPaused, maxSubSteps, stepSize]);\n  var collideHandler = function collideHandler(_ref2) {\n    var _events$target;\n    var body = _ref2.body,\n      _ref2$contact = _ref2.contact,\n      bi = _ref2$contact.bi,\n      bj = _ref2$contact.bj,\n      contactRest = _objectWithoutProperties(_ref2$contact, _excluded4),\n      target = _ref2.target,\n      rest = _objectWithoutProperties(_ref2, _excluded5);\n    var cb = (_events$target = events[target]) == null ? void 0 : _events$target.collide;\n    cb && cb(_objectSpread({\n      body: refs[body],\n      contact: _objectSpread({\n        bi: refs[bi],\n        bj: refs[bj]\n      }, contactRest),\n      target: refs[target]\n    }, rest));\n  };\n  var collideBeginHandler = function collideBeginHandler(_ref3) {\n    var _events$bodyA, _events$bodyB;\n    var bodyA = _ref3.bodyA,\n      bodyB = _ref3.bodyB;\n    var cbA = (_events$bodyA = events[bodyA]) == null ? void 0 : _events$bodyA.collideBegin;\n    cbA && cbA({\n      body: refs[bodyB],\n      op: 'event',\n      target: refs[bodyA],\n      type: 'collideBegin'\n    });\n    var cbB = (_events$bodyB = events[bodyB]) == null ? void 0 : _events$bodyB.collideBegin;\n    cbB && cbB({\n      body: refs[bodyA],\n      op: 'event',\n      target: refs[bodyB],\n      type: 'collideBegin'\n    });\n  };\n  var collideEndHandler = function collideEndHandler(_ref4) {\n    var _events$bodyA2, _events$bodyB2;\n    var bodyA = _ref4.bodyA,\n      bodyB = _ref4.bodyB;\n    var cbA = (_events$bodyA2 = events[bodyA]) == null ? void 0 : _events$bodyA2.collideEnd;\n    cbA && cbA({\n      body: refs[bodyB],\n      op: 'event',\n      target: refs[bodyA],\n      type: 'collideEnd'\n    });\n    var cbB = (_events$bodyB2 = events[bodyB]) == null ? void 0 : _events$bodyB2.collideEnd;\n    cbB && cbB({\n      body: refs[bodyA],\n      op: 'event',\n      target: refs[bodyB],\n      type: 'collideEnd'\n    });\n  };\n  var frameHandler = function frameHandler(_ref5) {\n    var active = _ref5.active,\n      _ref5$bodies = _ref5.bodies,\n      uuids = _ref5$bodies === void 0 ? [] : _ref5$bodies,\n      observations = _ref5.observations,\n      positions = _ref5.positions,\n      quaternions = _ref5.quaternions;\n    for (var i = 0; i < uuids.length; i++) {\n      bodies[uuids[i]] = i;\n    }\n    observations.forEach(function (_ref6) {\n      var _ref60 = _slicedToArray(_ref6, 3),\n        id = _ref60[0],\n        value = _ref60[1],\n        type = _ref60[2];\n      var subscription = subscriptions[id] || {};\n      var cb = subscription[type];\n      // HELP: We clearly know the type of the callback, but typescript can't deal with it\n      cb && cb(value);\n    });\n    if (active) {\n      for (var _i14 = 0, _Object$values = Object.values(refs); _i14 < _Object$values.length; _i14++) {\n        var ref = _Object$values[_i14];\n        if (ref instanceof InstancedMesh) {\n          for (var _i15 = 0; _i15 < ref.count; _i15++) {\n            var uuid = \"\".concat(ref.uuid, \"/\").concat(_i15);\n            var index = bodies[uuid];\n            if (index !== undefined) {\n              ref.setMatrixAt(_i15, apply(index, positions, quaternions, scaleOverrides[uuid]));\n              ref.instanceMatrix.needsUpdate = true;\n            }\n          }\n        } else {\n          var scale = scaleOverrides[ref.uuid] || ref.scale;\n          apply(bodies[ref.uuid], positions, quaternions, scale, ref);\n        }\n      }\n      if (shouldInvalidate) {\n        invalidate();\n      }\n    }\n  };\n  var rayhitHandler = function rayhitHandler(_ref7) {\n    var _events$uuid;\n    var body = _ref7.body,\n      _ref7$ray = _ref7.ray,\n      uuid = _ref7$ray.uuid,\n      rayRest = _objectWithoutProperties(_ref7$ray, _excluded6),\n      rest = _objectWithoutProperties(_ref7, _excluded7);\n    var cb = (_events$uuid = events[uuid]) == null ? void 0 : _events$uuid.rayhit;\n    cb && cb(_objectSpread({\n      body: body ? refs[body] : null,\n      ray: _objectSpread({\n        uuid: uuid\n      }, rayRest)\n    }, rest));\n  };\n\n  // Run loop *after* all the physics objects have ran theirs!\n  // Otherwise the buffers will be invalidated by the browser\n  useFrame(loop);\n  useEffect(function () {\n    worker.connect();\n    worker.init();\n    worker.on('collide', collideHandler);\n    worker.on('collideBegin', collideBeginHandler);\n    worker.on('collideEnd', collideEndHandler);\n    worker.on('frame', frameHandler);\n    worker.on('rayhit', rayhitHandler);\n    return function () {\n      worker.terminate();\n      worker.removeAllListeners();\n    };\n  }, []);\n  useEffect(function () {\n    worker.axisIndex = axisIndex;\n  }, [axisIndex]);\n  useEffect(function () {\n    worker.broadphase = broadphase;\n  }, [broadphase]);\n  useEffect(function () {\n    worker.gravity = gravity;\n  }, [gravity]);\n  useEffect(function () {\n    worker.iterations = iterations;\n  }, [iterations]);\n  useEffect(function () {\n    worker.tolerance = tolerance;\n  }, [tolerance]);\n  var value = useMemo(function () {\n    return {\n      bodies: bodies,\n      events: events,\n      refs: refs,\n      scaleOverrides: scaleOverrides,\n      subscriptions: subscriptions,\n      worker: worker\n    };\n  }, [bodies, events, refs, subscriptions, worker]);\n  return /*#__PURE__*/jsx(physicsContext.Provider, {\n    value: value,\n    children: children\n  });\n}\nexport { DebugProvider as Debug, PhysicsProvider as Physics, useBox, useCompoundBody, useConeTwistConstraint, useContactMaterial, useConvexPolyhedron, useCylinder, useDistanceConstraint, useHeightfield, useHingeConstraint, useLockConstraint, useParticle, usePlane, usePointToPointConstraint, useRaycastAll, useRaycastAny, useRaycastClosest, useRaycastVehicle, useSphere, useSpring, useTrimesh };"],"names":["_excluded3","_excluded4","_excluded5","_excluded6","_excluded7","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","minLen","_arrayLikeToArray","n","prototype","toString","call","slice","constructor","name","from","test","_unsupportedIterableToArray","F","s","done","value","e","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2","return","arr","len","arr2","_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","_isNativeReflectConstruct","result","Super","NewTarget","this","ReflectOwnKeys","events","exports","R","ReflectApply","receiver","args","Function","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","EventEmitter","init","once","emitter","Promise","resolve","reject","errorListener","removeListener","resolver","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","_getMaxListeners","that","_addListener","type","prepend","m","existing","warning","create","newListener","emit","unshift","warned","w","Error","String","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","ret","unwrapListeners","arrayClone","listenerCount","copy","addEventListener","wrapListener","arg","removeEventListener","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","rawListeners","eventNames","EventEmitter$1","createURL","base64","sourcemapArg","enableUnicodeArg","sourcemap","enableUnicode","binaryString","atob","binaryView","Uint8Array","charCodeAt","fromCharCode","Uint16Array","buffer","decodeBase64","start","indexOf","body","substring","blob","Blob","URL","createObjectURL","url","WorkerFactory","options","Worker","CannonWorkerAPI","_EventEmitter$","_super","_ref","_this","_ref$allowSleep","allowSleep","_ref$axisIndex","axisIndex","_ref$broadphase","broadphase","_ref$defaultContactMa","defaultContactMaterial","contactEquationStiffness","_ref$frictionGravity","frictionGravity","_ref$gravity","gravity","_ref$iterations","iterations","_ref$quatNormalizeFas","quatNormalizeFast","_ref$quatNormalizeSki","quatNormalizeSkip","_ref$size","size","_ref$solver","solver","_ref$tolerance","tolerance","config","buffers","positions","Float32Array","quaternions","postMessage","op","props","_ref2","uuid","_ref3","_ref3$props","refA","refB","optns","_ref4","_ref5","_ref6","_ref6$props","chassisBodyUUID","wheelUUIDs","wheelInfos","indexForwardAxis","indexRightAxis","indexUpAxis","_ref7","_ref7$props","_ref8","_ref9","_ref10","_ref11","_ref12","_ref13","_this2","worker","onmessage","data","_step","_iterator","messageQueue","_ref14","_ref15","_ref16","_ref17","_this$config","_ref18","_ref19","_ref20","_ref21","_ref22","_ref23","_ref24","_ref25","_ref26","_ref27","_ref28","_ref29","_ref30","_ref31","_ref32","_ref33","_ref34","_ref35","_ref36","_ref37","_ref38","_ref39","_ref40","_ref40$props","x","y","z","_ref41","_ref42","_ref43","_ref44","_ref45","_ref46","_ref47","_ref48","_ref49","_ref50","_ref51","_this$worker","_this$buffers","byteLength","_ref52","_ref52$props","id","_this$worker2","terminate","_ref53","_ref54","Mat3$1","elements","vector","Vec3$1","v","matrix","A","B","T","a11","a12","a13","a21","a22","a23","a31","a32","a33","b11","b12","b13","b21","b22","b23","b31","b32","b33","t","b","j","eqns","nr","np","p","k","multiplier","Infinity","row","column","r","reverse_eqns$1","_multiplier","_multiplier2","q","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","tmp","M","vx","vy","vz","Math","sqrt","invN","ninv","dot","px","py","pz","scalar","t1","t2","norm","Vec3_tangents_n$1","inorm","randVec","Vec3_tangents_randVec$1","abs","cross","precision","negate","antip_neg$1","almostEquals","ZERO","UNIT_X","UNIT_Y","UNIT_Z","AABB$1","lowerBound","upperBound","points","quaternion","skinSize","l","u","vmult","tmp$1$1","vadd","aabb","min","max","l1","u1","l2","u2","overlapsX","overlapsY","overlapsZ","a","c","d","g","h","frame","corners","transformIntoFrame_corners$1","getCorners","corner","pointToLocal","setFromPoints","pointToWorld","ray","direction","dirFracX","dirFracY","dirFracZ","t3","t4","t5","t6","tmin","tmax","EventTarget","includes","splice","event","listenerArray","Quaternion$1","angle","sin","cos","targetAxis","normalize","acos","isAntiparallelTo","sfv_t1$1","sfv_t2$1","tangents","setFromAxisAngle","PI","_a","pow","quat","ax","ay","az","aw","bx","by","bz","bw","conjugate","inorm2","qx","qy","qz","qw","ix","iy","iz","iw","order","heading","attitude","bank","atan2","sqx","sqy","sqz","asin","c1","c2","c3","s1","s2","s3","toQuat","omega","cosom","sinom","scale0","scale1","angularVelocity","dt","angularFactor","half_dt","Shape$1","idCounter","boundingSphereRadius","collisionResponse","collisionFilterGroup","collisionFilterMask","material","mass","pos","types","SPHERE","PLANE","BOX","COMPOUND","CONVEXPOLYHEDRON","HEIGHTFIELD","PARTICLE","CYLINDER","TRIMESH","Transform$1","worldPoint","pointToLocalFrame","localPoint","pointToWorldFrame","localVector","vsub","tmpQuat$1$1","worldVector","ConvexPolyhedron","_Shape$","_super2","_this3","_props","_props$vertices","vertices","_props$faces","faces","_props$normals","normals","axes","faceNormals","computeNormals","updateBoundingSphereRadius","worldVertices","worldVerticesNeedsUpdate","worldFaceNormals","worldFaceNormalsNeedsUpdate","uniqueAxes","uniqueEdges","computeEdges","edges","edge","face","numVertices","found","clone","getFaceNormal","vertex","_j","va","vb","vc","computeNormal","posA","quatA","hullB","posB","quatB","separatingNormal","minDist","maxDist","WorldNormal","closestFaceB","dmax","MAX_VALUE","worldVertsB1","_b","worldb","clipFaceAgainstHull","faceListA","faceListB","faceANormalWS3","Worldnormal1","deltaC","worldEdge0","worldEdge1","Cross","dmin","hullA","_i","_d","testSepAxis","numFacesA","fi","_i3","_d3","numFacesB","_i2","_fi","_d2","e0","e1","almostZero","dist","axis","project","maxminA","maxminB","maxA","minA","maxB","minB","d0","d1","aabbmax","aabbmin","computeLocalAABB","face_i","faceANormalWS","edge0","WorldEdge0","worldPlaneAnormal1","planeNormalWS1","worldA1","localPlaneNormal","planeNormalWS","pVtxIn","pVtxOut","closestFaceA","polyA","connectedFaces","numVerticesA","_i4","_a2","_b2","otherFace","_localPlaneEq","getPlaneConstantOfFace","_planeEqWS","clipFaceAgainstPlane","localPlaneEq","planeEqWS","_i5","depth","log","point","normal","inVertices","outVertices","planeNormal","planeConstant","n_dot_first","n_dot_last","numVerts","firstVertex","lastVertex","vi","newv","_newv","lerp","_newv2","verts","worldVerts","_v","N","worldNormals","max2","norm2","lengthSquared","minx","miny","minz","maxx","maxy","maxz","tempWorldVertex","_v2","scale","offset","_v3","_i6","_v4","_i7","_v5","pointInside","getAveragePointLocal","_v6","vToP","r1","vToPointInside","r2","cb","ab","isZero","shape","localAxis","project_localAxis","localOrigin","project_localOrigin","vs","setZero","vectorToLocalFrame","add","val","_temp2","Box","_Shape$2","_super3","halfExtents","_this4","convexPolyhedronRepresentation","updateConvexPolyhedronRepresentation","sx","sy","sz","V","calculateInertia","sixTargetVectors","sides","ex","callback","worldCornerTempPos","worldCornersTemp","wc","_wc","BODY_TYPES","BODY_SLEEP_STATES","Body","_EventTarget","_super4","_this5","world","vlambda","previousPosition","interpolatedPosition","initPosition","velocity","initVelocity","force","invMass","linearDamping","STATIC","DYNAMIC","sleepState","AWAKE","sleepSpeedLimit","sleepTimeLimit","timeLastSleepy","wakeUpAfterNarrowphase","torque","initQuaternion","previousQuaternion","interpolatedQuaternion","initAngularVelocity","shapes","shapeOffsets","shapeOrientations","inertia","invInertia","invInertiaWorld","invMassSolve","invInertiaSolve","invInertiaWorldSolve","fixedRotation","angularDamping","linearFactor","aabbNeedsUpdate","boundingRadius","wlambda","isTrigger","addShape","updateMassProperties","prevState","SLEEPING","dispatchEvent","wakeupEvent","time","speedSquared","speedLimitSquared","SLEEPY","sleepyEvent","wakeUp","sleep","sleepEvent","KINEMATIC","_offset","_orientation","orientation","updateBoundingRadius","radius","tmpVec","tmpQuat","bodyQuat","shapeAABB","updateAABB_shapeAABB","mult","calculateWorldAABB","extend","I","m1","uiw_m1","m2","uiw_m2","setRotationFromQuaternion","transpose","mmult","relativePoint","rotForce","Body_applyForce_rotForce","localForce","worldForce","Body_applyLocalForce_worldForce","relativePointWorld","Body_applyLocalForce_relativePointWorld","vectorToWorldFrame","applyForce","impulse","velo","Body_applyImpulse_velo","rotVelo","Body_applyImpulse_rotVelo","localImpulse","worldImpulse","Body_applyLocalImpulse_worldImpulse","Body_applyLocalImpulse_relativePoint","applyImpulse","Body_updateMassProperties_halfExtents","fixed","updateAABB","updateInertiaWorld","quatNormalize","angularVelo","iMdt","tx","ty","tz","integrate","normalizeFast","COLLIDE_EVENT_NAME","RaycastResult$1","rayFromWorld","rayToWorld","hitNormalWorld","hitPointWorld","hasHit","hitFaceIndex","distance","shouldStop","RAY_MODES$1","Ray$1","_Shape$types$SPHERE$","_Shape$types$PLANE$","_Shape$types$BOX$","_Shape$types$CYLINDER2","_Shape$types$CONVEXPO2","_Shape$types$HEIGHTFI2","_Shape$types$TRIMESH$","to","checkCollisionResponse","skipBackfaces","mode","ANY","_intersectSphere","_intersectPlane","_intersectBox","_intersectConvex","_intersectHeightfield","_intersectTrimesh","reset","updateDirection","getAABB","tmpAABB$1$1","tmpArray$1","aabbQuery","intersectBodies","xi","intersectBody_xi$1","qi","intersectBody_qi$1","intersectShape","bodies","intersectBody","v0$1","intersect$1","distanceTo","distanceFromIntersection$1","intersectMethod","box","reportedShape","worldNormal","planeToFrom","n_dot_dir","planePointToFrom","dir_scaled_with_t","reportIntersection","elementSize","localRay","intersectHeightfield_localRay$1","iMinX","iMinY","iMaxX","iMaxY","intersectHeightfield_index$1","getIndexOfPosition","getAabbAtIndex","overlapsRay","getConvexTrianglePillar","pillarOffset","worldPillarOffset$1","pillarConvex","intersectConvexOptions$1","sphere","delta","intersectionPoint","Ray_intersectSphere_intersectionPoint$1","Ray_intersectSphere_normal$1","d2","intersectConvex_normal$1","intersectConvex_vector$1","faceList","fromToDistance","Nfaces","faceNormal","_q","intersectPoint$1","a$1","b$1","c$1","pointInTriangle","mesh","intersectTrimesh_normal$1","triangles","intersectTrimesh_triangles$1","treeTransform","intersectTrimesh_treeTransform$1","localDirection","intersectTrimesh_localDirection$1","localFrom","intersectTrimesh_localFrom$1","localTo","intersectTrimesh_localTo$1","worldIntersectPoint","intersectTrimesh_worldIntersectPoint$1","intersectTrimesh_worldNormal$1","indices","fromToDistanceSquared","distanceSquared","tree","rayQuery","trianglesIndex","getNormal","getVertex","squaredDistance","ALL","CLOSEST","v1$1","v2$1","dot00","dot01","dot02","dot11","dot12","Material","friction","restitution","performance$1","globalThis","performance","now","nowOffset","Date","timing","navigationStart","Mat3","Vec3","reverse_eqns","_multiplier3","_multiplier4","Vec3_tangents_n","Vec3_tangents_randVec","antip_neg","AABB","tmp$1","transformIntoFrame_corners","Quaternion","sfv_t1","sfv_t2","_a7","Shape","Transform","tmpQuat$1","RaycastResult","RAY_MODES","Ray","_Shape$types$SPHERE2","_Shape$types$PLANE2","_Shape$types$BOX2","_Shape$types$CYLINDER3","_Shape$types$CONVEXPO3","_Shape$types$HEIGHTFI3","_Shape$types$TRIMESH2","tmpAABB$1","tmpArray","intersectBody_xi","intersectBody_qi","v0","intersect","distanceFromIntersection","intersectHeightfield_localRay","intersectHeightfield_index","worldPillarOffset","intersectConvexOptions","Ray_intersectSphere_intersectionPoint","Ray_intersectSphere_normal","intersectConvex_normal","intersectConvex_vector","_q2","intersectPoint","intersectTrimesh_normal","intersectTrimesh_triangles","intersectTrimesh_treeTransform","intersectTrimesh_localDirection","intersectTrimesh_localFrom","intersectTrimesh_localTo","intersectTrimesh_worldIntersectPoint","intersectTrimesh_worldNormal","v1","v2","_nowOffset","debugContext","createContext","physicsContext","usePhysicsContext","useContext","Vector3","Matrix4","temp","Object3D","useForwardedRef","ref","nullRef","useRef","capitalize","str","charAt","toUpperCase","getUUID","suffix","current","Euler","q$1","incrementingId","subscribe","subscriptions","unsubscribe","prepare","_object$position","_object$rotation","_ref$position","_ref$rotation","rotation","_ref$userData","userData","updateMatrix","setupCollision","onCollide","onCollideBegin","onCollideEnd","collide","collideBegin","collideEnd","useBody","fn","argsFn","fwdRef","deps","_usePhysicsContext2","refs","scaleOverrides","debugApi","useLayoutEffect","currentWorker","objectCount","InstancedMesh","instanceMatrix","setUsage","DynamicDrawUsage","fill","map","_","setMatrixAt","needsUpdate","addBodies","serializableProps","remove","removeBodies","api","useMemo","makeAtomic","makeQuaternion","setQuaternion","makeRotation","setRotation","setFromQuaternion","fromArray","toArray","quaternionToRotation","makeVec","makeApi","applyLocalForce","applyLocalImpulse","applyTorque","scaleOverride","cache","at","usePlane","useSphere","compose","matrixAutoUpdate","identity","PhysicsProvider","_ref$allowSleep2","_ref$axisIndex2","_ref$broadphase2","children","_ref$defaultContactMa2","_ref$frictionGravity2","_ref$gravity2","_ref$isPaused","isPaused","_ref$iterations2","_ref$maxSubSteps","maxSubSteps","_ref$quatNormalizeFas2","_ref$quatNormalizeSki2","_ref$shouldInvalidate","shouldInvalidate","_ref$size2","_ref$solver2","_ref$stepSize","stepSize","_ref$tolerance2","invalidate","_useState11","useState","_useState12$","timeSinceLastCalled","loop","useCallback","collideHandler","_events$target","_ref2$contact","contact","bi","bj","contactRest","rest","collideBeginHandler","_events$bodyA","_events$bodyB","bodyA","bodyB","cbA","cbB","collideEndHandler","_events$bodyA2","_events$bodyB2","frameHandler","active","_ref5$bodies","uuids","observations","_ref60","_i14","_Object$values","values","_i15","rayhitHandler","_events$uuid","_ref7$ray","rayRest","rayhit","useEffect","connect","jsx","Provider"],"sourceRoot":""}